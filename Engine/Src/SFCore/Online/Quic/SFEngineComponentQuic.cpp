////////////////////////////////////////////////////////////////////////////////
// 
// CopyRight (c) Kyungkun Ko
// 
// Author : KyungKun Ko
//
// Description : Autogenerated header, Engine
//
////////////////////////////////////////////////////////////////////////////////


#include "SFTypedefs.h"
#include "ResultCode/SFResultCodeSystem.h"
#include "Online/Quic/SFEngineComponentQuic.h"
#include <msquic.h>
#include <openssl/x509.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include "Online/HTTP/SFHTTPClientSystem.h"
#include "Online/Quic/SFQuicService.h"
#include "Util/SFTrace.h"

namespace SF
{

    //
    // The protocol name used in the Application Layer Protocol Negotiation (ALPN).
    //
    //static const QUIC_BUFFER Alpn = { sizeof("sample") - 1, (uint8_t*)"sample" };
    static const QUIC_BUFFER QuicAlpn = { sizeof("h3") - 1, (uint8_t*)"h3" }; // HTTP3


    class QuicService : public IQuicService
    {
    private:

        // quic api handle
        const QUIC_API_TABLE* m_MsQuic{};

        // last status
        QUIC_STATUS m_Status;

        // quic registration handle
        HQUIC m_Registration{};

        std::unordered_map<std::string, HQUIC> m_Configurations;


    public:

        virtual const QUIC_API_TABLE* GetQuic() const override { return m_MsQuic; }
        virtual HQUIC GetRegistration() const override { return m_Registration; }
        virtual HQUIC GetConfiguration(const String& configurationName) const override
        {
            auto itFound = m_Configurations.find(configurationName);
            if (itFound != m_Configurations.end())
            {
                return itFound->second;
            }
            return nullptr;
        }
        virtual const QUIC_BUFFER* GetAlpnBuffers(size_t& outNumAlpn) const override
        {
            outNumAlpn = 1;
            return (QUIC_BUFFER*)&QuicAlpn;
        }

        Result Initialize()
        {
            Result hr;

            SFLog(Quic, Info, "Initializing QuicService");

            // Initialize MsQuic
            m_Status = MsQuicOpen2(&m_MsQuic);
            if (QUIC_FAILED(m_Status))
            {
                SFLog(Quic, Error, "MsQuicOpen2 failed: {}", m_Status);
                return QuicStatusToResult(m_Status);
            }

            // Create a registration
            QUIC_REGISTRATION_CONFIG RegConfig = { "Http3Client", QUIC_EXECUTION_PROFILE_TYPE_REAL_TIME };
            m_Status = m_MsQuic->RegistrationOpen(&RegConfig, &m_Registration);
            if (QUIC_FAILED(m_Status))
            {
                SFLog(Quic, Error, "RegistrationOpen failed: {}", m_Status);
                MsQuicClose(m_MsQuic);
                m_MsQuic = nullptr;
                return QuicStatusToResult(m_Status);
            }

            SFCheck(Quic, CreateClientConfiguration());
            SFCheck(Quic, CreateServerConfiguration());

            return hr;
        }

        void Terminate()
        {
            if (m_Registration)
            {
                QUIC_UINT62 shutdownCode = 503; // service not available
                // shutdown kills all connections
                // QUIC_CONNECTION_SHUTDOWN_FLAG_NONE for graceful shutdown
                m_MsQuic->RegistrationShutdown(m_Registration, QUIC_CONNECTION_SHUTDOWN_FLAG_NONE, shutdownCode);

                // close waits connections
                m_MsQuic->RegistrationClose(m_Registration);
                m_Registration = {};
            }

            if (m_MsQuic)
            {
                MsQuicClose(m_MsQuic);
                m_MsQuic = nullptr;
            }
        }

        struct QuicCertConfig
        {
            QUIC_CREDENTIAL_CONFIG QuicConfig{};
            QUIC_CERTIFICATE_PKCS12 Pk12{};
            QUIC_CERTIFICATE_HASH CertHash{};

            QuicCertConfig()
            {
                QuicConfig.Type = QUIC_CREDENTIAL_TYPE_NONE;
                QuicConfig.Flags = QUIC_CREDENTIAL_FLAG_CLIENT; // default client
            }

            void SetPk12(int asn1BlobLen, unsigned char* pAsn1Blob)
            {
                Pk12.Asn1Blob = pAsn1Blob;
                Pk12.Asn1BlobLength = asn1BlobLen;

                QuicConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_PKCS12;
                QuicConfig.CertificatePkcs12 = &Pk12;

            }
        };

        Result SetupCertConfigPK12(QuicCertConfig& CredConfig)
        {
            Result hr;

            X509* x509{};
            if (Service::HTTP->GetTrustedCerts().size() > 0)
            {
                STACK_OF(X509_INFO)* x509Stack = Service::HTTP->GetTrustedCerts()[0];
                if (sk_X509_INFO_num(x509Stack) > 0)
                {
                    // we just need one
                    X509_INFO* info = sk_X509_INFO_value(x509Stack, 0);
                    if (info->x509)
                    {
                        x509 = info->x509;
                    }
                }
            }

            unsigned char* pAsn1 = nullptr;
            int asn1Len = 0;

            if (x509)
            {
                asn1Len = i2d_X509(x509, &pAsn1);
                if (asn1Len < 0)
                {
                    SFLog(Quic, Error, "Can't get X509 Asn1 blob from the cert: {}", ERR_error_string(ERR_get_error(), NULL));
                }
            }

            if (pAsn1 && asn1Len > 0)
            {
                CredConfig.SetPk12(asn1Len, pAsn1);
            }

            return hr;
        }


        Result SetupCertConfigHash(QuicCertConfig& CredConfig)
        {
            Result hr;

            X509* x509{};
            if (Service::HTTP->GetTrustedCerts().size() > 0)
            {
                STACK_OF(X509_INFO)* x509Stack = Service::HTTP->GetTrustedCerts()[0];
                if (sk_X509_INFO_num(x509Stack) > 0)
                {
                    // we just need one
                    X509_INFO* info = sk_X509_INFO_value(x509Stack, 0);
                    if (info->x509)
                    {
                        x509 = info->x509;
                    }
                }
            }

            uint CertHashLen = sizeof(CredConfig.CertHash.ShaHash); // SHA-1 is 20 bytes
            if (X509_digest(x509, EVP_sha1(), CredConfig.CertHash.ShaHash, &CertHashLen) != 1)
            {
                return ResultCode::UNEXPECTED;
            }

            // The certificate should be in system cert list. otherwise it will fail anyway
            CredConfig.QuicConfig.Type = QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH;
            CredConfig.QuicConfig.CertificateHash = &CredConfig.CertHash;

            return hr;
        }

        Result CreateClientConfiguration()
        {
            Result hr;

            QUIC_SETTINGS Settings = { 0 };
            //
            // Configures the server's settings to allow for the peer to open a single
            // bidirectional stream. By default connections are not configured to allow
            // any streams from the peer.
            //
            Settings.IsSet.PeerBidiStreamCount = TRUE;
            Settings.PeerBidiStreamCount = 1; // Allow 1 bidirectional stream from peer

            // Configures the server's idle timeout.
            Settings.IsSet.IdleTimeoutMs = TRUE;
            Settings.IdleTimeoutMs = 60 & 1000;
            //
            // Configures the server's resumption level to allow for resumption and
            // 0-RTT.
            //
            Settings.ServerResumptionLevel = QUIC_SERVER_RESUME_AND_ZERORTT;
            Settings.IsSet.ServerResumptionLevel = TRUE;

            // Enable Datagram receive
            Settings.IsSet.DatagramReceiveEnabled = 1;


            QuicCertConfig CredConfigHelper{};

            //SFCheck(Quic, SetupCertConfigHash(CredConfigHelper));
            // TODO: probably better with separated flag?
            if (CredConfigHelper.QuicConfig.Type == QUIC_CREDENTIAL_TYPE_NONE) {
                CredConfigHelper.QuicConfig.Flags |= QUIC_CREDENTIAL_FLAG_NO_CERTIFICATE_VALIDATION;
            }

            HQUIC configuration{};
            m_Status = m_MsQuic->ConfigurationOpen(m_Registration, &QuicAlpn, 1, &Settings, sizeof(Settings), nullptr, &configuration);
            if (QUIC_FAILED(m_Status)) {
                SFLog(Quic, Error, "ConfigurationOpen failed: {0}", m_Status);
                return QuicStatusToResult(m_Status);
            }

            // Load ALPN for HTTP/3
            m_Status = m_MsQuic->ConfigurationLoadCredential(configuration, &CredConfigHelper.QuicConfig);
            if (QUIC_FAILED(m_Status)) {
                SFLog(Quic, Error, "ConfigurationLoadCredential failed: {0}", m_Status);
                m_MsQuic->ConfigurationClose(configuration);
                return QuicStatusToResult(m_Status);
            }

            m_Configurations.emplace("client", configuration);

            return hr;
        }


        Result CreateServerConfiguration()
        {
            Result hr;


            QUIC_SETTINGS Settings = { 0 };
            //
            // Configures the server's settings to allow for the peer to open a single
            // bidirectional stream. By default connections are not configured to allow
            // any streams from the peer.
            //
            Settings.IsSet.PeerBidiStreamCount = TRUE;
            Settings.PeerBidiStreamCount = 1; // Allow 1 bidirectional stream from peer

            // Configures the server's idle timeout.
            Settings.IsSet.IdleTimeoutMs = TRUE;
            Settings.IdleTimeoutMs = 60 & 1000;
            //
            // Configures the server's resumption level to allow for resumption and
            // 0-RTT.
            //
            Settings.ServerResumptionLevel = QUIC_SERVER_RESUME_AND_ZERORTT;
            Settings.IsSet.ServerResumptionLevel = TRUE;

            // Enable Datagram receive
            Settings.IsSet.DatagramReceiveEnabled = 1;

            QuicCertConfig CredConfigHelper;

            SFCheck(Quic, SetupCertConfigPK12(CredConfigHelper));
            CredConfigHelper.QuicConfig.Flags = QUIC_CREDENTIAL_FLAG_NONE; // QUIC_CREDENTIAL_FLAG_NONE, server default

            HQUIC configuration{};
            m_Status = m_MsQuic->ConfigurationOpen(m_Registration, &QuicAlpn, 1, &Settings, sizeof(Settings), nullptr, &configuration);
            if (QUIC_FAILED(m_Status)) {
                SFLog(Quic, Error, "ConfigurationOpen failed: {0}", m_Status);
                return QuicStatusToResult(m_Status);
            }

            // Load ALPN for HTTP/3
            m_Status = m_MsQuic->ConfigurationLoadCredential(configuration, &CredConfigHelper.QuicConfig);
            if (QUIC_FAILED(m_Status)) {
                SFLog(Quic, Error, "ConfigurationLoadCredential failed: {0}", m_Status);
                m_MsQuic->ConfigurationClose(configuration);
                return QuicStatusToResult(m_Status);
            }

            m_Configurations.emplace("server", configuration);

            return hr;
        }
    };


    ////////////////////////////////////////////////////////////////////////////////
    //
    //	Module
    //

    EngineComponentQuic::EngineComponentQuic()
        : LibraryComponent(TypeName)
    {

    }

    EngineComponentQuic::~EngineComponentQuic()
    {
    }

    // Initialize server component
    Result EngineComponentQuic::InitializeComponent()
    {
        Result hr = LibraryComponent::InitializeComponent();
        if (!hr.IsSuccess()) return hr;

        m_QuicService.reset(new QuicService);
        SFCheckPtr(Quic, m_QuicService);
        SFCheck(Quic, m_QuicService->Initialize());

        Service::Quic = m_QuicService.get();

        return hr;
    }

    // Terminate server component
    void EngineComponentQuic::DeinitializeComponent()
    {
        LibraryComponent::DeinitializeComponent();

        Service::Quic = nullptr;
        m_QuicService.reset();
    }


}//namespace SF 



