// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOGIN_SF_FLAT_LOGIN_H_
#define FLATBUFFERS_GENERATED_LOGIN_SF_FLAT_LOGIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

#include "SFTypes_generated.h"

namespace SF {
namespace Flat {
namespace Login {

struct LoginCmd;
struct LoginCmdBuilder;

struct LoginRes;
struct LoginResBuilder;

struct LoginWithSteamCmd;
struct LoginWithSteamCmdBuilder;

struct LoginWithSteamRes;
struct LoginWithSteamResBuilder;

struct LoginCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_PASSWORD = 6,
    VT_GAME_ID = 8
  };
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  const ::flatbuffers::String *game_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GAME_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return user_id();
    else if constexpr (Index == 1) return password();
    else if constexpr (Index == 2) return game_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyOffset(verifier, VT_GAME_ID) &&
           verifier.VerifyString(game_id()) &&
           verifier.EndTable();
  }
};

struct LoginCmdBuilder {
  typedef LoginCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(LoginCmd::VT_USER_ID, user_id);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(LoginCmd::VT_PASSWORD, password);
  }
  void add_game_id(::flatbuffers::Offset<::flatbuffers::String> game_id) {
    fbb_.AddOffset(LoginCmd::VT_GAME_ID, game_id);
  }
  explicit LoginCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoginCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoginCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoginCmd> CreateLoginCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0,
    ::flatbuffers::Offset<::flatbuffers::String> game_id = 0) {
  LoginCmdBuilder builder_(_fbb);
  builder_.add_game_id(game_id);
  builder_.add_password(password);
  builder_.add_user_id(user_id);
  return builder_.Finish();
}

struct LoginCmd::Traits {
  using type = LoginCmd;
  static auto constexpr Create = CreateLoginCmd;
  static constexpr auto name = "LoginCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Login.LoginCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "user_id",
    "password",
    "game_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<LoginCmd> CreateLoginCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_id = nullptr,
    const char *password = nullptr,
    const char *game_id = nullptr) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  auto game_id__ = game_id ? _fbb.CreateString(game_id) : 0;
  return SF::Flat::Login::CreateLoginCmd(
      _fbb,
      user_id__,
      password__,
      game_id__);
}

struct LoginRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NICK_NAME = 4,
    VT_ACCOUNT_ID = 6,
    VT_AUTH_TICKET = 8,
    VT_BANNED_REASON = 10,
    VT_ROLE = 12,
    VT_GAME_SERVER_ADDRESS = 14
  };
  const ::flatbuffers::String *nick_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICK_NAME);
  }
  const SF::Flat::AccountID *account_id() const {
    return GetStruct<const SF::Flat::AccountID *>(VT_ACCOUNT_ID);
  }
  uint64_t auth_ticket() const {
    return GetField<uint64_t>(VT_AUTH_TICKET, 0);
  }
  const ::flatbuffers::String *banned_reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BANNED_REASON);
  }
  SF::Flat::EAccountRole role() const {
    return static_cast<SF::Flat::EAccountRole>(GetField<int8_t>(VT_ROLE, 0));
  }
  const ::flatbuffers::String *game_server_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GAME_SERVER_ADDRESS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return nick_name();
    else if constexpr (Index == 1) return account_id();
    else if constexpr (Index == 2) return auth_ticket();
    else if constexpr (Index == 3) return banned_reason();
    else if constexpr (Index == 4) return role();
    else if constexpr (Index == 5) return game_server_address();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICK_NAME) &&
           verifier.VerifyString(nick_name()) &&
           VerifyField<SF::Flat::AccountID>(verifier, VT_ACCOUNT_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_AUTH_TICKET, 8) &&
           VerifyOffset(verifier, VT_BANNED_REASON) &&
           verifier.VerifyString(banned_reason()) &&
           VerifyField<int8_t>(verifier, VT_ROLE, 1) &&
           VerifyOffset(verifier, VT_GAME_SERVER_ADDRESS) &&
           verifier.VerifyString(game_server_address()) &&
           verifier.EndTable();
  }
};

struct LoginResBuilder {
  typedef LoginRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nick_name(::flatbuffers::Offset<::flatbuffers::String> nick_name) {
    fbb_.AddOffset(LoginRes::VT_NICK_NAME, nick_name);
  }
  void add_account_id(const SF::Flat::AccountID *account_id) {
    fbb_.AddStruct(LoginRes::VT_ACCOUNT_ID, account_id);
  }
  void add_auth_ticket(uint64_t auth_ticket) {
    fbb_.AddElement<uint64_t>(LoginRes::VT_AUTH_TICKET, auth_ticket, 0);
  }
  void add_banned_reason(::flatbuffers::Offset<::flatbuffers::String> banned_reason) {
    fbb_.AddOffset(LoginRes::VT_BANNED_REASON, banned_reason);
  }
  void add_role(SF::Flat::EAccountRole role) {
    fbb_.AddElement<int8_t>(LoginRes::VT_ROLE, static_cast<int8_t>(role), 0);
  }
  void add_game_server_address(::flatbuffers::Offset<::flatbuffers::String> game_server_address) {
    fbb_.AddOffset(LoginRes::VT_GAME_SERVER_ADDRESS, game_server_address);
  }
  explicit LoginResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoginRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoginRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoginRes> CreateLoginRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nick_name = 0,
    const SF::Flat::AccountID *account_id = nullptr,
    uint64_t auth_ticket = 0,
    ::flatbuffers::Offset<::flatbuffers::String> banned_reason = 0,
    SF::Flat::EAccountRole role = SF::Flat::EAccountRole::Player,
    ::flatbuffers::Offset<::flatbuffers::String> game_server_address = 0) {
  LoginResBuilder builder_(_fbb);
  builder_.add_auth_ticket(auth_ticket);
  builder_.add_game_server_address(game_server_address);
  builder_.add_banned_reason(banned_reason);
  builder_.add_account_id(account_id);
  builder_.add_nick_name(nick_name);
  builder_.add_role(role);
  return builder_.Finish();
}

struct LoginRes::Traits {
  using type = LoginRes;
  static auto constexpr Create = CreateLoginRes;
  static constexpr auto name = "LoginRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Login.LoginRes";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "nick_name",
    "account_id",
    "auth_ticket",
    "banned_reason",
    "role",
    "game_server_address"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<LoginRes> CreateLoginResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nick_name = nullptr,
    const SF::Flat::AccountID *account_id = nullptr,
    uint64_t auth_ticket = 0,
    const char *banned_reason = nullptr,
    SF::Flat::EAccountRole role = SF::Flat::EAccountRole::Player,
    const char *game_server_address = nullptr) {
  auto nick_name__ = nick_name ? _fbb.CreateString(nick_name) : 0;
  auto banned_reason__ = banned_reason ? _fbb.CreateString(banned_reason) : 0;
  auto game_server_address__ = game_server_address ? _fbb.CreateString(game_server_address) : 0;
  return SF::Flat::Login::CreateLoginRes(
      _fbb,
      nick_name__,
      account_id,
      auth_ticket,
      banned_reason__,
      role,
      game_server_address__);
}

struct LoginWithSteamCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginWithSteamCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_APP_ID = 4,
    VT_STEAM_PLAYER_ID = 6,
    VT_STEAM_PLAYER_NAME = 8,
    VT_STEAM_PLAYER_TOKEN = 10,
    VT_GAME_ID = 12
  };
  uint64_t steam_app_id() const {
    return GetField<uint64_t>(VT_STEAM_APP_ID, 0);
  }
  uint64_t steam_player_id() const {
    return GetField<uint64_t>(VT_STEAM_PLAYER_ID, 0);
  }
  const ::flatbuffers::String *steam_player_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STEAM_PLAYER_NAME);
  }
  const ::flatbuffers::String *steam_player_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STEAM_PLAYER_TOKEN);
  }
  const ::flatbuffers::String *game_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GAME_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return steam_app_id();
    else if constexpr (Index == 1) return steam_player_id();
    else if constexpr (Index == 2) return steam_player_name();
    else if constexpr (Index == 3) return steam_player_token();
    else if constexpr (Index == 4) return game_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_STEAM_APP_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_STEAM_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_STEAM_PLAYER_NAME) &&
           verifier.VerifyString(steam_player_name()) &&
           VerifyOffset(verifier, VT_STEAM_PLAYER_TOKEN) &&
           verifier.VerifyString(steam_player_token()) &&
           VerifyOffset(verifier, VT_GAME_ID) &&
           verifier.VerifyString(game_id()) &&
           verifier.EndTable();
  }
};

struct LoginWithSteamCmdBuilder {
  typedef LoginWithSteamCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_steam_app_id(uint64_t steam_app_id) {
    fbb_.AddElement<uint64_t>(LoginWithSteamCmd::VT_STEAM_APP_ID, steam_app_id, 0);
  }
  void add_steam_player_id(uint64_t steam_player_id) {
    fbb_.AddElement<uint64_t>(LoginWithSteamCmd::VT_STEAM_PLAYER_ID, steam_player_id, 0);
  }
  void add_steam_player_name(::flatbuffers::Offset<::flatbuffers::String> steam_player_name) {
    fbb_.AddOffset(LoginWithSteamCmd::VT_STEAM_PLAYER_NAME, steam_player_name);
  }
  void add_steam_player_token(::flatbuffers::Offset<::flatbuffers::String> steam_player_token) {
    fbb_.AddOffset(LoginWithSteamCmd::VT_STEAM_PLAYER_TOKEN, steam_player_token);
  }
  void add_game_id(::flatbuffers::Offset<::flatbuffers::String> game_id) {
    fbb_.AddOffset(LoginWithSteamCmd::VT_GAME_ID, game_id);
  }
  explicit LoginWithSteamCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoginWithSteamCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoginWithSteamCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoginWithSteamCmd> CreateLoginWithSteamCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t steam_app_id = 0,
    uint64_t steam_player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> steam_player_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> steam_player_token = 0,
    ::flatbuffers::Offset<::flatbuffers::String> game_id = 0) {
  LoginWithSteamCmdBuilder builder_(_fbb);
  builder_.add_steam_player_id(steam_player_id);
  builder_.add_steam_app_id(steam_app_id);
  builder_.add_game_id(game_id);
  builder_.add_steam_player_token(steam_player_token);
  builder_.add_steam_player_name(steam_player_name);
  return builder_.Finish();
}

struct LoginWithSteamCmd::Traits {
  using type = LoginWithSteamCmd;
  static auto constexpr Create = CreateLoginWithSteamCmd;
  static constexpr auto name = "LoginWithSteamCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Login.LoginWithSteamCmd";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "steam_app_id",
    "steam_player_id",
    "steam_player_name",
    "steam_player_token",
    "game_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<LoginWithSteamCmd> CreateLoginWithSteamCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t steam_app_id = 0,
    uint64_t steam_player_id = 0,
    const char *steam_player_name = nullptr,
    const char *steam_player_token = nullptr,
    const char *game_id = nullptr) {
  auto steam_player_name__ = steam_player_name ? _fbb.CreateString(steam_player_name) : 0;
  auto steam_player_token__ = steam_player_token ? _fbb.CreateString(steam_player_token) : 0;
  auto game_id__ = game_id ? _fbb.CreateString(game_id) : 0;
  return SF::Flat::Login::CreateLoginWithSteamCmd(
      _fbb,
      steam_app_id,
      steam_player_id,
      steam_player_name__,
      steam_player_token__,
      game_id__);
}

struct LoginWithSteamRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginWithSteamResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NICK_NAME = 4,
    VT_ACCOUNT_ID = 6,
    VT_AUTH_TICKET = 8,
    VT_BANNED_REASON = 10,
    VT_ROLE = 12,
    VT_GAME_SERVER_ADDRESS = 14
  };
  const ::flatbuffers::String *nick_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICK_NAME);
  }
  const SF::Flat::AccountID *account_id() const {
    return GetStruct<const SF::Flat::AccountID *>(VT_ACCOUNT_ID);
  }
  uint64_t auth_ticket() const {
    return GetField<uint64_t>(VT_AUTH_TICKET, 0);
  }
  const ::flatbuffers::String *banned_reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BANNED_REASON);
  }
  SF::Flat::EAccountRole role() const {
    return static_cast<SF::Flat::EAccountRole>(GetField<int8_t>(VT_ROLE, 0));
  }
  const ::flatbuffers::String *game_server_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GAME_SERVER_ADDRESS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return nick_name();
    else if constexpr (Index == 1) return account_id();
    else if constexpr (Index == 2) return auth_ticket();
    else if constexpr (Index == 3) return banned_reason();
    else if constexpr (Index == 4) return role();
    else if constexpr (Index == 5) return game_server_address();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICK_NAME) &&
           verifier.VerifyString(nick_name()) &&
           VerifyField<SF::Flat::AccountID>(verifier, VT_ACCOUNT_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_AUTH_TICKET, 8) &&
           VerifyOffset(verifier, VT_BANNED_REASON) &&
           verifier.VerifyString(banned_reason()) &&
           VerifyField<int8_t>(verifier, VT_ROLE, 1) &&
           VerifyOffset(verifier, VT_GAME_SERVER_ADDRESS) &&
           verifier.VerifyString(game_server_address()) &&
           verifier.EndTable();
  }
};

struct LoginWithSteamResBuilder {
  typedef LoginWithSteamRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nick_name(::flatbuffers::Offset<::flatbuffers::String> nick_name) {
    fbb_.AddOffset(LoginWithSteamRes::VT_NICK_NAME, nick_name);
  }
  void add_account_id(const SF::Flat::AccountID *account_id) {
    fbb_.AddStruct(LoginWithSteamRes::VT_ACCOUNT_ID, account_id);
  }
  void add_auth_ticket(uint64_t auth_ticket) {
    fbb_.AddElement<uint64_t>(LoginWithSteamRes::VT_AUTH_TICKET, auth_ticket, 0);
  }
  void add_banned_reason(::flatbuffers::Offset<::flatbuffers::String> banned_reason) {
    fbb_.AddOffset(LoginWithSteamRes::VT_BANNED_REASON, banned_reason);
  }
  void add_role(SF::Flat::EAccountRole role) {
    fbb_.AddElement<int8_t>(LoginWithSteamRes::VT_ROLE, static_cast<int8_t>(role), 0);
  }
  void add_game_server_address(::flatbuffers::Offset<::flatbuffers::String> game_server_address) {
    fbb_.AddOffset(LoginWithSteamRes::VT_GAME_SERVER_ADDRESS, game_server_address);
  }
  explicit LoginWithSteamResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoginWithSteamRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoginWithSteamRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoginWithSteamRes> CreateLoginWithSteamRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nick_name = 0,
    const SF::Flat::AccountID *account_id = nullptr,
    uint64_t auth_ticket = 0,
    ::flatbuffers::Offset<::flatbuffers::String> banned_reason = 0,
    SF::Flat::EAccountRole role = SF::Flat::EAccountRole::Player,
    ::flatbuffers::Offset<::flatbuffers::String> game_server_address = 0) {
  LoginWithSteamResBuilder builder_(_fbb);
  builder_.add_auth_ticket(auth_ticket);
  builder_.add_game_server_address(game_server_address);
  builder_.add_banned_reason(banned_reason);
  builder_.add_account_id(account_id);
  builder_.add_nick_name(nick_name);
  builder_.add_role(role);
  return builder_.Finish();
}

struct LoginWithSteamRes::Traits {
  using type = LoginWithSteamRes;
  static auto constexpr Create = CreateLoginWithSteamRes;
  static constexpr auto name = "LoginWithSteamRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Login.LoginWithSteamRes";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "nick_name",
    "account_id",
    "auth_ticket",
    "banned_reason",
    "role",
    "game_server_address"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<LoginWithSteamRes> CreateLoginWithSteamResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nick_name = nullptr,
    const SF::Flat::AccountID *account_id = nullptr,
    uint64_t auth_ticket = 0,
    const char *banned_reason = nullptr,
    SF::Flat::EAccountRole role = SF::Flat::EAccountRole::Player,
    const char *game_server_address = nullptr) {
  auto nick_name__ = nick_name ? _fbb.CreateString(nick_name) : 0;
  auto banned_reason__ = banned_reason ? _fbb.CreateString(banned_reason) : 0;
  auto game_server_address__ = game_server_address ? _fbb.CreateString(game_server_address) : 0;
  return SF::Flat::Login::CreateLoginWithSteamRes(
      _fbb,
      nick_name__,
      account_id,
      auth_ticket,
      banned_reason__,
      role,
      game_server_address__);
}

inline const SF::Flat::Login::LoginWithSteamRes *GetLoginWithSteamRes(const void *buf) {
  return ::flatbuffers::GetRoot<SF::Flat::Login::LoginWithSteamRes>(buf);
}

inline const SF::Flat::Login::LoginWithSteamRes *GetSizePrefixedLoginWithSteamRes(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SF::Flat::Login::LoginWithSteamRes>(buf);
}

inline bool VerifyLoginWithSteamResBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SF::Flat::Login::LoginWithSteamRes>(nullptr);
}

inline bool VerifySizePrefixedLoginWithSteamResBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SF::Flat::Login::LoginWithSteamRes>(nullptr);
}

inline void FinishLoginWithSteamResBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SF::Flat::Login::LoginWithSteamRes> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLoginWithSteamResBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SF::Flat::Login::LoginWithSteamRes> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Login
}  // namespace Flat
}  // namespace SF

#endif  // FLATBUFFERS_GENERATED_LOGIN_SF_FLAT_LOGIN_H_
