// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SFTYPES_SF_FLAT_H_
#define FLATBUFFERS_GENERATED_SFTYPES_SF_FLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace SF {
namespace Flat {

struct TimeSpan;

struct Time32;

struct Time64;

struct Result;

struct GameInstanceUID;

struct TransactionID;

struct Vector4;

struct Quaternion;

struct AttributeString;
struct AttributeStringBuilder;

struct UInt128;

struct Guid;

struct AccountID;

struct CharacterID;

struct GenericError;
struct GenericErrorBuilder;

struct UGCContentInfo;
struct UGCContentInfoBuilder;

struct UGCItemInfo;

struct EntityUID;

struct PlayerPlatformID;

struct PlayerInformation;
struct PlayerInformationBuilder;

struct TotalRankingPlayerInformation;
struct TotalRankingPlayerInformationBuilder;

struct AchievementStat;

struct MatchingQueueTicket;

struct ActorMovement;

struct NamedVariableString;
struct NamedVariableStringBuilder;

struct NamedVariableInt;
struct NamedVariableIntBuilder;

struct NamedVariableUInt;
struct NamedVariableUIntBuilder;

struct NamedVariableInt64;
struct NamedVariableInt64Builder;

struct NamedVariableUInt64;
struct NamedVariableUInt64Builder;

struct NamedVariableFloat;
struct NamedVariableFloatBuilder;

struct NamedVariableDouble;
struct NamedVariableDoubleBuilder;

struct NamedVariableBool;
struct NamedVariableBoolBuilder;

struct NamedVariableGuid;
struct NamedVariableGuidBuilder;

struct NamedVariable;
struct NamedVariableBuilder;

enum class EAccountRole : int8_t {
  Player = 0,
  Tester = 1,
  Dev = 2,
  MIN = Player,
  MAX = Dev
};

inline const EAccountRole (&EnumValuesEAccountRole())[3] {
  static const EAccountRole values[] = {
    EAccountRole::Player,
    EAccountRole::Tester,
    EAccountRole::Dev
  };
  return values;
}

inline const char * const *EnumNamesEAccountRole() {
  static const char * const names[4] = {
    "Player",
    "Tester",
    "Dev",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAccountRole(EAccountRole e) {
  if (::flatbuffers::IsOutRange(e, EAccountRole::Player, EAccountRole::Dev)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEAccountRole()[index];
}

enum class Platform : int8_t {
  BR = 0,
  Steam = 1,
  Facebook = 2,
  MIN = BR,
  MAX = Facebook
};

inline const Platform (&EnumValuesPlatform())[3] {
  static const Platform values[] = {
    Platform::BR,
    Platform::Steam,
    Platform::Facebook
  };
  return values;
}

inline const char * const *EnumNamesPlatform() {
  static const char * const names[4] = {
    "BR",
    "Steam",
    "Facebook",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlatform(Platform e) {
  if (::flatbuffers::IsOutRange(e, Platform::BR, Platform::Facebook)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlatform()[index];
}

enum class GameStateID : int8_t {
  None = 0,
  Red = 1,
  Green = 2,
  Blue = 3,
  MIN = None,
  MAX = Blue
};

inline const GameStateID (&EnumValuesGameStateID())[4] {
  static const GameStateID values[] = {
    GameStateID::None,
    GameStateID::Red,
    GameStateID::Green,
    GameStateID::Blue
  };
  return values;
}

inline const char * const *EnumNamesGameStateID() {
  static const char * const names[5] = {
    "None",
    "Red",
    "Green",
    "Blue",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameStateID(GameStateID e) {
  if (::flatbuffers::IsOutRange(e, GameStateID::None, GameStateID::Blue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameStateID()[index];
}

enum class ChatMessageType : int8_t {
  Zone = 0,
  ZoneGlobal = 1,
  Whisper = 2,
  Channel = 3,
  System = 4,
  MIN = Zone,
  MAX = System
};

inline const ChatMessageType (&EnumValuesChatMessageType())[5] {
  static const ChatMessageType values[] = {
    ChatMessageType::Zone,
    ChatMessageType::ZoneGlobal,
    ChatMessageType::Whisper,
    ChatMessageType::Channel,
    ChatMessageType::System
  };
  return values;
}

inline const char * const *EnumNamesChatMessageType() {
  static const char * const names[6] = {
    "Zone",
    "ZoneGlobal",
    "Whisper",
    "Channel",
    "System",
    nullptr
  };
  return names;
}

inline const char *EnumNameChatMessageType(ChatMessageType e) {
  if (::flatbuffers::IsOutRange(e, ChatMessageType::Zone, ChatMessageType::System)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChatMessageType()[index];
}

enum class NamedVariableValue : uint8_t {
  NONE = 0,
  NamedVariableString = 1,
  NamedVariableBool = 2,
  NamedVariableFloat = 3,
  NamedVariableDouble = 4,
  NamedVariableInt = 5,
  NamedVariableUInt = 6,
  NamedVariableInt64 = 7,
  NamedVariableUInt64 = 8,
  NamedVariableGuid = 9,
  MIN = NONE,
  MAX = NamedVariableGuid
};

inline const NamedVariableValue (&EnumValuesNamedVariableValue())[10] {
  static const NamedVariableValue values[] = {
    NamedVariableValue::NONE,
    NamedVariableValue::NamedVariableString,
    NamedVariableValue::NamedVariableBool,
    NamedVariableValue::NamedVariableFloat,
    NamedVariableValue::NamedVariableDouble,
    NamedVariableValue::NamedVariableInt,
    NamedVariableValue::NamedVariableUInt,
    NamedVariableValue::NamedVariableInt64,
    NamedVariableValue::NamedVariableUInt64,
    NamedVariableValue::NamedVariableGuid
  };
  return values;
}

inline const char * const *EnumNamesNamedVariableValue() {
  static const char * const names[11] = {
    "NONE",
    "NamedVariableString",
    "NamedVariableBool",
    "NamedVariableFloat",
    "NamedVariableDouble",
    "NamedVariableInt",
    "NamedVariableUInt",
    "NamedVariableInt64",
    "NamedVariableUInt64",
    "NamedVariableGuid",
    nullptr
  };
  return names;
}

inline const char *EnumNameNamedVariableValue(NamedVariableValue e) {
  if (::flatbuffers::IsOutRange(e, NamedVariableValue::NONE, NamedVariableValue::NamedVariableGuid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNamedVariableValue()[index];
}

template<typename T> struct NamedVariableValueTraits {
  static const NamedVariableValue enum_value = NamedVariableValue::NONE;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableString> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableString;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableBool> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableBool;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableFloat> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableFloat;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableDouble> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableDouble;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableInt> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableInt;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableUInt> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableUInt;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableInt64> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableInt64;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableUInt64> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableUInt64;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableGuid> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableGuid;
};

bool VerifyNamedVariableValue(::flatbuffers::Verifier &verifier, const void *obj, NamedVariableValue type);
bool VerifyNamedVariableValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<NamedVariableValue> *types);

enum class NotificationType : int8_t {
  None = 0,
  MessageNotify = 1,
  FriendRequest = 2,
  GiftStamina = 3,
  MIN = None,
  MAX = GiftStamina
};

inline const NotificationType (&EnumValuesNotificationType())[4] {
  static const NotificationType values[] = {
    NotificationType::None,
    NotificationType::MessageNotify,
    NotificationType::FriendRequest,
    NotificationType::GiftStamina
  };
  return values;
}

inline const char * const *EnumNamesNotificationType() {
  static const char * const names[5] = {
    "None",
    "MessageNotify",
    "FriendRequest",
    "GiftStamina",
    nullptr
  };
  return names;
}

inline const char *EnumNameNotificationType(NotificationType e) {
  if (::flatbuffers::IsOutRange(e, NotificationType::None, NotificationType::GiftStamina)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNotificationType()[index];
}

enum class PlayerRole : int8_t {
  None = 0,
  Villager = 1,
  Werewolf = 2,
  Seer = 3,
  MIN = None,
  MAX = Seer
};

inline const PlayerRole (&EnumValuesPlayerRole())[4] {
  static const PlayerRole values[] = {
    PlayerRole::None,
    PlayerRole::Villager,
    PlayerRole::Werewolf,
    PlayerRole::Seer
  };
  return values;
}

inline const char * const *EnumNamesPlayerRole() {
  static const char * const names[5] = {
    "None",
    "Villager",
    "Werewolf",
    "Seer",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlayerRole(PlayerRole e) {
  if (::flatbuffers::IsOutRange(e, PlayerRole::None, PlayerRole::Seer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlayerRole()[index];
}

enum class GameWinner : int8_t {
  None = 0,
  Werewolf = 1,
  Villager = 2,
  WereHamster = 3,
  MIN = None,
  MAX = WereHamster
};

inline const GameWinner (&EnumValuesGameWinner())[4] {
  static const GameWinner values[] = {
    GameWinner::None,
    GameWinner::Werewolf,
    GameWinner::Villager,
    GameWinner::WereHamster
  };
  return values;
}

inline const char * const *EnumNamesGameWinner() {
  static const char * const names[5] = {
    "None",
    "Werewolf",
    "Villager",
    "WereHamster",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameWinner(GameWinner e) {
  if (::flatbuffers::IsOutRange(e, GameWinner::None, GameWinner::WereHamster)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameWinner()[index];
}

enum class PlayerKilledReason : int8_t {
  Unknown = 0,
  BlockedByBoardGuard = 1,
  ByWerewolf = 2,
  ByHanging = 3,
  MIN = Unknown,
  MAX = ByHanging
};

inline const PlayerKilledReason (&EnumValuesPlayerKilledReason())[4] {
  static const PlayerKilledReason values[] = {
    PlayerKilledReason::Unknown,
    PlayerKilledReason::BlockedByBoardGuard,
    PlayerKilledReason::ByWerewolf,
    PlayerKilledReason::ByHanging
  };
  return values;
}

inline const char * const *EnumNamesPlayerKilledReason() {
  static const char * const names[5] = {
    "Unknown",
    "BlockedByBoardGuard",
    "ByWerewolf",
    "ByHanging",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlayerKilledReason(PlayerKilledReason e) {
  if (::flatbuffers::IsOutRange(e, PlayerKilledReason::Unknown, PlayerKilledReason::ByHanging)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlayerKilledReason()[index];
}

enum class RankingType : int8_t {
  World = 0,
  MIN = World,
  MAX = World
};

inline const RankingType (&EnumValuesRankingType())[1] {
  static const RankingType values[] = {
    RankingType::World
  };
  return values;
}

inline const char * const *EnumNamesRankingType() {
  static const char * const names[2] = {
    "World",
    nullptr
  };
  return names;
}

inline const char *EnumNameRankingType(RankingType e) {
  if (::flatbuffers::IsOutRange(e, RankingType::World, RankingType::World)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRankingType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TimeSpan FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t milliseconds_;

 public:
  struct Traits;
  TimeSpan()
      : milliseconds_(0) {
  }
  TimeSpan(int64_t _milliseconds)
      : milliseconds_(::flatbuffers::EndianScalar(_milliseconds)) {
  }
  int64_t milliseconds() const {
    return ::flatbuffers::EndianScalar(milliseconds_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return milliseconds();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(TimeSpan, 8);

struct TimeSpan::Traits {
  using type = TimeSpan;
  static constexpr auto name = "TimeSpan";
  static constexpr auto fully_qualified_name = "SF.Flat.TimeSpan";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "milliseconds"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Time32 FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t time_;

 public:
  struct Traits;
  Time32()
      : time_(0) {
  }
  Time32(uint32_t _time)
      : time_(::flatbuffers::EndianScalar(_time)) {
  }
  uint32_t time() const {
    return ::flatbuffers::EndianScalar(time_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return time();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Time32, 4);

struct Time32::Traits {
  using type = Time32;
  static constexpr auto name = "Time32";
  static constexpr auto fully_qualified_name = "SF.Flat.Time32";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "time"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Time64 FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t time_;

 public:
  struct Traits;
  Time64()
      : time_(0) {
  }
  Time64(uint64_t _time)
      : time_(::flatbuffers::EndianScalar(_time)) {
  }
  uint64_t time() const {
    return ::flatbuffers::EndianScalar(time_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return time();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Time64, 8);

struct Time64::Traits {
  using type = Time64;
  static constexpr auto name = "Time64";
  static constexpr auto fully_qualified_name = "SF.Flat.Time64";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "time"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Result FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;

 public:
  struct Traits;
  Result()
      : value_(0) {
  }
  Result(int32_t _value)
      : value_(::flatbuffers::EndianScalar(_value)) {
  }
  int32_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Result, 4);

struct Result::Traits {
  using type = Result;
  static constexpr auto name = "Result";
  static constexpr auto fully_qualified_name = "SF.Flat.Result";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) GameInstanceUID FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t uid_;

 public:
  struct Traits;
  GameInstanceUID()
      : uid_(0) {
  }
  GameInstanceUID(uint32_t _uid)
      : uid_(::flatbuffers::EndianScalar(_uid)) {
  }
  uint32_t uid() const {
    return ::flatbuffers::EndianScalar(uid_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return uid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(GameInstanceUID, 4);

struct GameInstanceUID::Traits {
  using type = GameInstanceUID;
  static constexpr auto name = "GameInstanceUID";
  static constexpr auto fully_qualified_name = "SF.Flat.GameInstanceUID";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "uid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TransactionID FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t transaction_id_;

 public:
  struct Traits;
  TransactionID()
      : transaction_id_(0) {
  }
  TransactionID(uint64_t _transaction_id)
      : transaction_id_(::flatbuffers::EndianScalar(_transaction_id)) {
  }
  uint64_t transaction_id() const {
    return ::flatbuffers::EndianScalar(transaction_id_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return transaction_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(TransactionID, 8);

struct TransactionID::Traits {
  using type = TransactionID;
  static constexpr auto name = "TransactionID";
  static constexpr auto fully_qualified_name = "SF.Flat.TransactionID";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "transaction_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  struct Traits;
  Vector4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vector4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return x();
    else if constexpr (Index == 1) return y();
    else if constexpr (Index == 2) return z();
    else if constexpr (Index == 3) return w();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Vector4, 16);

struct Vector4::Traits {
  using type = Vector4;
  static constexpr auto name = "Vector4";
  static constexpr auto fully_qualified_name = "SF.Flat.Vector4";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "x",
    "y",
    "z",
    "w"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  struct Traits;
  Quaternion()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quaternion(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return x();
    else if constexpr (Index == 1) return y();
    else if constexpr (Index == 2) return z();
    else if constexpr (Index == 3) return w();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Quaternion, 16);

struct Quaternion::Traits {
  using type = Quaternion;
  static constexpr auto name = "Quaternion";
  static constexpr auto fully_qualified_name = "SF.Flat.Quaternion";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "x",
    "y",
    "z",
    "w"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) UInt128 FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t low_;
  uint64_t high_;

 public:
  struct Traits;
  UInt128()
      : low_(0),
        high_(0) {
  }
  UInt128(uint64_t _low, uint64_t _high)
      : low_(::flatbuffers::EndianScalar(_low)),
        high_(::flatbuffers::EndianScalar(_high)) {
  }
  uint64_t low() const {
    return ::flatbuffers::EndianScalar(low_);
  }
  uint64_t high() const {
    return ::flatbuffers::EndianScalar(high_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return low();
    else if constexpr (Index == 1) return high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(UInt128, 16);

struct UInt128::Traits {
  using type = UInt128;
  static constexpr auto name = "UInt128";
  static constexpr auto fully_qualified_name = "SF.Flat.UInt128";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "low",
    "high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Guid FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t low_;
  uint64_t high_;

 public:
  struct Traits;
  Guid()
      : low_(0),
        high_(0) {
  }
  Guid(uint64_t _low, uint64_t _high)
      : low_(::flatbuffers::EndianScalar(_low)),
        high_(::flatbuffers::EndianScalar(_high)) {
  }
  uint64_t low() const {
    return ::flatbuffers::EndianScalar(low_);
  }
  uint64_t high() const {
    return ::flatbuffers::EndianScalar(high_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return low();
    else if constexpr (Index == 1) return high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Guid, 16);

struct Guid::Traits {
  using type = Guid;
  static constexpr auto name = "Guid";
  static constexpr auto fully_qualified_name = "SF.Flat.Guid";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "low",
    "high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) AccountID FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t low_;
  uint64_t high_;

 public:
  struct Traits;
  AccountID()
      : low_(0),
        high_(0) {
  }
  AccountID(uint64_t _low, uint64_t _high)
      : low_(::flatbuffers::EndianScalar(_low)),
        high_(::flatbuffers::EndianScalar(_high)) {
  }
  uint64_t low() const {
    return ::flatbuffers::EndianScalar(low_);
  }
  uint64_t high() const {
    return ::flatbuffers::EndianScalar(high_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return low();
    else if constexpr (Index == 1) return high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(AccountID, 16);

struct AccountID::Traits {
  using type = AccountID;
  static constexpr auto name = "AccountID";
  static constexpr auto fully_qualified_name = "SF.Flat.AccountID";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "low",
    "high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) CharacterID FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t low_;
  uint64_t high_;

 public:
  struct Traits;
  CharacterID()
      : low_(0),
        high_(0) {
  }
  CharacterID(uint64_t _low, uint64_t _high)
      : low_(::flatbuffers::EndianScalar(_low)),
        high_(::flatbuffers::EndianScalar(_high)) {
  }
  uint64_t low() const {
    return ::flatbuffers::EndianScalar(low_);
  }
  uint64_t high() const {
    return ::flatbuffers::EndianScalar(high_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return low();
    else if constexpr (Index == 1) return high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(CharacterID, 16);

struct CharacterID::Traits {
  using type = CharacterID;
  static constexpr auto name = "CharacterID";
  static constexpr auto fully_qualified_name = "SF.Flat.CharacterID";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "low",
    "high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UGCItemInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t table_id_;
  uint32_t utc_expire_;
  uint32_t effect0_;
  uint32_t effect1_;

 public:
  struct Traits;
  UGCItemInfo()
      : table_id_(0),
        utc_expire_(0),
        effect0_(0),
        effect1_(0) {
  }
  UGCItemInfo(uint32_t _table_id, uint32_t _utc_expire, uint32_t _effect0, uint32_t _effect1)
      : table_id_(::flatbuffers::EndianScalar(_table_id)),
        utc_expire_(::flatbuffers::EndianScalar(_utc_expire)),
        effect0_(::flatbuffers::EndianScalar(_effect0)),
        effect1_(::flatbuffers::EndianScalar(_effect1)) {
  }
  uint32_t table_id() const {
    return ::flatbuffers::EndianScalar(table_id_);
  }
  uint32_t utc_expire() const {
    return ::flatbuffers::EndianScalar(utc_expire_);
  }
  uint32_t effect0() const {
    return ::flatbuffers::EndianScalar(effect0_);
  }
  uint32_t effect1() const {
    return ::flatbuffers::EndianScalar(effect1_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return table_id();
    else if constexpr (Index == 1) return utc_expire();
    else if constexpr (Index == 2) return effect0();
    else if constexpr (Index == 3) return effect1();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(UGCItemInfo, 16);

struct UGCItemInfo::Traits {
  using type = UGCItemInfo;
  static constexpr auto name = "UGCItemInfo";
  static constexpr auto fully_qualified_name = "SF.Flat.UGCItemInfo";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "table_id",
    "utc_expire",
    "effect0",
    "effect1"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityUID FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t entity_id_;

 public:
  struct Traits;
  EntityUID()
      : entity_id_(0) {
  }
  EntityUID(uint32_t _entity_id)
      : entity_id_(::flatbuffers::EndianScalar(_entity_id)) {
  }
  uint32_t entity_id() const {
    return ::flatbuffers::EndianScalar(entity_id_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return entity_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(EntityUID, 4);

struct EntityUID::Traits {
  using type = EntityUID;
  static constexpr auto name = "EntityUID";
  static constexpr auto fully_qualified_name = "SF.Flat.EntityUID";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "entity_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PlayerPlatformID FLATBUFFERS_FINAL_CLASS {
 private:
  SF::Flat::AccountID player_id_;
  int8_t platform_data_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  struct Traits;
  PlayerPlatformID()
      : player_id_(),
        platform_data_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  PlayerPlatformID(const SF::Flat::AccountID &_player_id, SF::Flat::Platform _platform_data)
      : player_id_(_player_id),
        platform_data_(::flatbuffers::EndianScalar(static_cast<int8_t>(_platform_data))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  const SF::Flat::AccountID &player_id() const {
    return player_id_;
  }
  SF::Flat::Platform platform_data() const {
    return static_cast<SF::Flat::Platform>(::flatbuffers::EndianScalar(platform_data_));
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else if constexpr (Index == 1) return platform_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(PlayerPlatformID, 24);

struct PlayerPlatformID::Traits {
  using type = PlayerPlatformID;
  static constexpr auto name = "PlayerPlatformID";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayerPlatformID";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id",
    "platform_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AchievementStat FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t achievement_stat_id_;
  int32_t stat_value_;

 public:
  struct Traits;
  AchievementStat()
      : achievement_stat_id_(0),
        stat_value_(0) {
  }
  AchievementStat(uint32_t _achievement_stat_id, int32_t _stat_value)
      : achievement_stat_id_(::flatbuffers::EndianScalar(_achievement_stat_id)),
        stat_value_(::flatbuffers::EndianScalar(_stat_value)) {
  }
  uint32_t achievement_stat_id() const {
    return ::flatbuffers::EndianScalar(achievement_stat_id_);
  }
  int32_t stat_value() const {
    return ::flatbuffers::EndianScalar(stat_value_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return achievement_stat_id();
    else if constexpr (Index == 1) return stat_value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(AchievementStat, 8);

struct AchievementStat::Traits {
  using type = AchievementStat;
  static constexpr auto name = "AchievementStat";
  static constexpr auto fully_qualified_name = "SF.Flat.AchievementStat";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "achievement_stat_id",
    "stat_value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) MatchingQueueTicket FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t queue_uid_;
  uint64_t queue_item_id_;

 public:
  struct Traits;
  MatchingQueueTicket()
      : queue_uid_(0),
        queue_item_id_(0) {
  }
  MatchingQueueTicket(uint64_t _queue_uid, uint64_t _queue_item_id)
      : queue_uid_(::flatbuffers::EndianScalar(_queue_uid)),
        queue_item_id_(::flatbuffers::EndianScalar(_queue_item_id)) {
  }
  uint64_t queue_uid() const {
    return ::flatbuffers::EndianScalar(queue_uid_);
  }
  uint64_t queue_item_id() const {
    return ::flatbuffers::EndianScalar(queue_item_id_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return queue_uid();
    else if constexpr (Index == 1) return queue_item_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(MatchingQueueTicket, 16);

struct MatchingQueueTicket::Traits {
  using type = MatchingQueueTicket;
  static constexpr auto name = "MatchingQueueTicket";
  static constexpr auto fully_qualified_name = "SF.Flat.MatchingQueueTicket";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "queue_uid",
    "queue_item_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ActorMovement FLATBUFFERS_FINAL_CLASS {
 private:
  SF::Flat::Vector4 position_;
  SF::Flat::Vector4 linear_velocity_;
  uint32_t actor_id_;
  float angular_yaw_;
  uint32_t move_frame_;
  uint32_t movement_state_;

 public:
  struct Traits;
  ActorMovement()
      : position_(),
        linear_velocity_(),
        actor_id_(0),
        angular_yaw_(0),
        move_frame_(0),
        movement_state_(0) {
  }
  ActorMovement(const SF::Flat::Vector4 &_position, const SF::Flat::Vector4 &_linear_velocity, uint32_t _actor_id, float _angular_yaw, uint32_t _move_frame, uint32_t _movement_state)
      : position_(_position),
        linear_velocity_(_linear_velocity),
        actor_id_(::flatbuffers::EndianScalar(_actor_id)),
        angular_yaw_(::flatbuffers::EndianScalar(_angular_yaw)),
        move_frame_(::flatbuffers::EndianScalar(_move_frame)),
        movement_state_(::flatbuffers::EndianScalar(_movement_state)) {
  }
  const SF::Flat::Vector4 &position() const {
    return position_;
  }
  const SF::Flat::Vector4 &linear_velocity() const {
    return linear_velocity_;
  }
  uint32_t actor_id() const {
    return ::flatbuffers::EndianScalar(actor_id_);
  }
  float angular_yaw() const {
    return ::flatbuffers::EndianScalar(angular_yaw_);
  }
  uint32_t move_frame() const {
    return ::flatbuffers::EndianScalar(move_frame_);
  }
  uint32_t movement_state() const {
    return ::flatbuffers::EndianScalar(movement_state_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return position();
    else if constexpr (Index == 1) return linear_velocity();
    else if constexpr (Index == 2) return actor_id();
    else if constexpr (Index == 3) return angular_yaw();
    else if constexpr (Index == 4) return move_frame();
    else if constexpr (Index == 5) return movement_state();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(ActorMovement, 48);

struct ActorMovement::Traits {
  using type = ActorMovement;
  static constexpr auto name = "ActorMovement";
  static constexpr auto fully_qualified_name = "SF.Flat.ActorMovement";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "position",
    "linear_velocity",
    "actor_id",
    "angular_yaw",
    "move_frame",
    "movement_state"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AttributeString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeStringBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct AttributeStringBuilder {
  typedef AttributeString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AttributeString::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(AttributeString::VT_VALUE, value);
  }
  explicit AttributeStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AttributeString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AttributeString>(end);
    fbb_.Required(o, AttributeString::VT_NAME);
    fbb_.Required(o, AttributeString::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<AttributeString> CreateAttributeString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  AttributeStringBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

struct AttributeString::Traits {
  using type = AttributeString;
  static auto constexpr Create = CreateAttributeString;
  static constexpr auto name = "AttributeString";
  static constexpr auto fully_qualified_name = "SF.Flat.AttributeString";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<AttributeString> CreateAttributeStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return SF::Flat::CreateAttributeString(
      _fbb,
      name__,
      value__);
}

struct GenericError FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GenericErrorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REASON = 4
  };
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return reason();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct GenericErrorBuilder {
  typedef GenericError Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(GenericError::VT_REASON, reason);
  }
  explicit GenericErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GenericError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GenericError>(end);
    fbb_.Required(o, GenericError::VT_REASON);
    return o;
  }
};

inline ::flatbuffers::Offset<GenericError> CreateGenericError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  GenericErrorBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

struct GenericError::Traits {
  using type = GenericError;
  static auto constexpr Create = CreateGenericError;
  static constexpr auto name = "GenericError";
  static constexpr auto fully_qualified_name = "SF.Flat.GenericError";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "reason"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GenericError> CreateGenericErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return SF::Flat::CreateGenericError(
      _fbb,
      reason__);
}

struct UGCContentInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UGCContentInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UGC_CONTENT_ID = 4,
    VT_DATA_ID = 6,
    VT_CATEGORY = 8,
    VT_DATA_PATH = 10
  };
  const SF::Flat::Guid *ugc_content_id() const {
    return GetStruct<const SF::Flat::Guid *>(VT_UGC_CONTENT_ID);
  }
  uint64_t data_id() const {
    return GetField<uint64_t>(VT_DATA_ID, 0);
  }
  const ::flatbuffers::String *category() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CATEGORY);
  }
  const ::flatbuffers::String *data_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA_PATH);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ugc_content_id();
    else if constexpr (Index == 1) return data_id();
    else if constexpr (Index == 2) return category();
    else if constexpr (Index == 3) return data_path();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SF::Flat::Guid>(verifier, VT_UGC_CONTENT_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_DATA_ID, 8) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.VerifyString(category()) &&
           VerifyOffset(verifier, VT_DATA_PATH) &&
           verifier.VerifyString(data_path()) &&
           verifier.EndTable();
  }
};

struct UGCContentInfoBuilder {
  typedef UGCContentInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ugc_content_id(const SF::Flat::Guid *ugc_content_id) {
    fbb_.AddStruct(UGCContentInfo::VT_UGC_CONTENT_ID, ugc_content_id);
  }
  void add_data_id(uint64_t data_id) {
    fbb_.AddElement<uint64_t>(UGCContentInfo::VT_DATA_ID, data_id, 0);
  }
  void add_category(::flatbuffers::Offset<::flatbuffers::String> category) {
    fbb_.AddOffset(UGCContentInfo::VT_CATEGORY, category);
  }
  void add_data_path(::flatbuffers::Offset<::flatbuffers::String> data_path) {
    fbb_.AddOffset(UGCContentInfo::VT_DATA_PATH, data_path);
  }
  explicit UGCContentInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UGCContentInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UGCContentInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UGCContentInfo> CreateUGCContentInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::Guid *ugc_content_id = nullptr,
    uint64_t data_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> category = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data_path = 0) {
  UGCContentInfoBuilder builder_(_fbb);
  builder_.add_data_id(data_id);
  builder_.add_data_path(data_path);
  builder_.add_category(category);
  builder_.add_ugc_content_id(ugc_content_id);
  return builder_.Finish();
}

struct UGCContentInfo::Traits {
  using type = UGCContentInfo;
  static auto constexpr Create = CreateUGCContentInfo;
  static constexpr auto name = "UGCContentInfo";
  static constexpr auto fully_qualified_name = "SF.Flat.UGCContentInfo";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ugc_content_id",
    "data_id",
    "category",
    "data_path"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<UGCContentInfo> CreateUGCContentInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::Guid *ugc_content_id = nullptr,
    uint64_t data_id = 0,
    const char *category = nullptr,
    const char *data_path = nullptr) {
  auto category__ = category ? _fbb.CreateString(category) : 0;
  auto data_path__ = data_path ? _fbb.CreateString(data_path) : 0;
  return SF::Flat::CreateUGCContentInfo(
      _fbb,
      ugc_content_id,
      data_id,
      category__,
      data_path__);
}

struct PlayerInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInformationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_PLAYER_PLATFORM_ID = 6,
    VT_PROFILE_NAME = 8,
    VT_LAST_ACTIVE_TIME = 10
  };
  const SF::Flat::AccountID *player_id() const {
    return GetStruct<const SF::Flat::AccountID *>(VT_PLAYER_ID);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  const ::flatbuffers::String *profile_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROFILE_NAME);
  }
  uint64_t last_active_time() const {
    return GetField<uint64_t>(VT_LAST_ACTIVE_TIME, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else if constexpr (Index == 1) return player_platform_id();
    else if constexpr (Index == 2) return profile_name();
    else if constexpr (Index == 3) return last_active_time();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SF::Flat::AccountID>(verifier, VT_PLAYER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           VerifyOffset(verifier, VT_PROFILE_NAME) &&
           verifier.VerifyString(profile_name()) &&
           VerifyField<uint64_t>(verifier, VT_LAST_ACTIVE_TIME, 8) &&
           verifier.EndTable();
  }
};

struct PlayerInformationBuilder {
  typedef PlayerInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(const SF::Flat::AccountID *player_id) {
    fbb_.AddStruct(PlayerInformation::VT_PLAYER_ID, player_id);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(PlayerInformation::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  void add_profile_name(::flatbuffers::Offset<::flatbuffers::String> profile_name) {
    fbb_.AddOffset(PlayerInformation::VT_PROFILE_NAME, profile_name);
  }
  void add_last_active_time(uint64_t last_active_time) {
    fbb_.AddElement<uint64_t>(PlayerInformation::VT_LAST_ACTIVE_TIME, last_active_time, 0);
  }
  explicit PlayerInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInformation>(end);
    fbb_.Required(o, PlayerInformation::VT_PLAYER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInformation> CreatePlayerInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::AccountID *player_id = nullptr,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> profile_name = 0,
    uint64_t last_active_time = 0) {
  PlayerInformationBuilder builder_(_fbb);
  builder_.add_last_active_time(last_active_time);
  builder_.add_profile_name(profile_name);
  builder_.add_player_platform_id(player_platform_id);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct PlayerInformation::Traits {
  using type = PlayerInformation;
  static auto constexpr Create = CreatePlayerInformation;
  static constexpr auto name = "PlayerInformation";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayerInformation";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id",
    "player_platform_id",
    "profile_name",
    "last_active_time"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PlayerInformation> CreatePlayerInformationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::AccountID *player_id = nullptr,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    const char *profile_name = nullptr,
    uint64_t last_active_time = 0) {
  auto profile_name__ = profile_name ? _fbb.CreateString(profile_name) : 0;
  return SF::Flat::CreatePlayerInformation(
      _fbb,
      player_id,
      player_platform_id,
      profile_name__,
      last_active_time);
}

struct TotalRankingPlayerInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TotalRankingPlayerInformationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANKING_ID = 4,
    VT_RANKING = 6,
    VT_PLAYER_ID = 8,
    VT_PLAYER_PLATFORM_ID = 10,
    VT_PROFILE_NAME = 12,
    VT_LEVEL = 14,
    VT_SCORE_LOW = 16,
    VT_SCORE_HIGH = 18
  };
  uint32_t ranking_id() const {
    return GetField<uint32_t>(VT_RANKING_ID, 0);
  }
  uint32_t ranking() const {
    return GetField<uint32_t>(VT_RANKING, 0);
  }
  const SF::Flat::AccountID *player_id() const {
    return GetStruct<const SF::Flat::AccountID *>(VT_PLAYER_ID);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  const ::flatbuffers::String *profile_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROFILE_NAME);
  }
  uint32_t level() const {
    return GetField<uint32_t>(VT_LEVEL, 0);
  }
  uint32_t score_low() const {
    return GetField<uint32_t>(VT_SCORE_LOW, 0);
  }
  uint32_t score_high() const {
    return GetField<uint32_t>(VT_SCORE_HIGH, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ranking_id();
    else if constexpr (Index == 1) return ranking();
    else if constexpr (Index == 2) return player_id();
    else if constexpr (Index == 3) return player_platform_id();
    else if constexpr (Index == 4) return profile_name();
    else if constexpr (Index == 5) return level();
    else if constexpr (Index == 6) return score_low();
    else if constexpr (Index == 7) return score_high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RANKING_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_RANKING, 4) &&
           VerifyField<SF::Flat::AccountID>(verifier, VT_PLAYER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           VerifyOffset(verifier, VT_PROFILE_NAME) &&
           verifier.VerifyString(profile_name()) &&
           VerifyField<uint32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCORE_LOW, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCORE_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct TotalRankingPlayerInformationBuilder {
  typedef TotalRankingPlayerInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ranking_id(uint32_t ranking_id) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_RANKING_ID, ranking_id, 0);
  }
  void add_ranking(uint32_t ranking) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_RANKING, ranking, 0);
  }
  void add_player_id(const SF::Flat::AccountID *player_id) {
    fbb_.AddStruct(TotalRankingPlayerInformation::VT_PLAYER_ID, player_id);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(TotalRankingPlayerInformation::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  void add_profile_name(::flatbuffers::Offset<::flatbuffers::String> profile_name) {
    fbb_.AddOffset(TotalRankingPlayerInformation::VT_PROFILE_NAME, profile_name);
  }
  void add_level(uint32_t level) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_LEVEL, level, 0);
  }
  void add_score_low(uint32_t score_low) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_SCORE_LOW, score_low, 0);
  }
  void add_score_high(uint32_t score_high) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_SCORE_HIGH, score_high, 0);
  }
  explicit TotalRankingPlayerInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TotalRankingPlayerInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TotalRankingPlayerInformation>(end);
    fbb_.Required(o, TotalRankingPlayerInformation::VT_PLAYER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<TotalRankingPlayerInformation> CreateTotalRankingPlayerInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ranking_id = 0,
    uint32_t ranking = 0,
    const SF::Flat::AccountID *player_id = nullptr,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> profile_name = 0,
    uint32_t level = 0,
    uint32_t score_low = 0,
    uint32_t score_high = 0) {
  TotalRankingPlayerInformationBuilder builder_(_fbb);
  builder_.add_score_high(score_high);
  builder_.add_score_low(score_low);
  builder_.add_level(level);
  builder_.add_profile_name(profile_name);
  builder_.add_player_platform_id(player_platform_id);
  builder_.add_player_id(player_id);
  builder_.add_ranking(ranking);
  builder_.add_ranking_id(ranking_id);
  return builder_.Finish();
}

struct TotalRankingPlayerInformation::Traits {
  using type = TotalRankingPlayerInformation;
  static auto constexpr Create = CreateTotalRankingPlayerInformation;
  static constexpr auto name = "TotalRankingPlayerInformation";
  static constexpr auto fully_qualified_name = "SF.Flat.TotalRankingPlayerInformation";
  static constexpr size_t fields_number = 8;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ranking_id",
    "ranking",
    "player_id",
    "player_platform_id",
    "profile_name",
    "level",
    "score_low",
    "score_high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<TotalRankingPlayerInformation> CreateTotalRankingPlayerInformationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ranking_id = 0,
    uint32_t ranking = 0,
    const SF::Flat::AccountID *player_id = nullptr,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    const char *profile_name = nullptr,
    uint32_t level = 0,
    uint32_t score_low = 0,
    uint32_t score_high = 0) {
  auto profile_name__ = profile_name ? _fbb.CreateString(profile_name) : 0;
  return SF::Flat::CreateTotalRankingPlayerInformation(
      _fbb,
      ranking_id,
      ranking,
      player_id,
      player_platform_id,
      profile_name__,
      level,
      score_low,
      score_high);
}

struct NamedVariableString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableStringBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct NamedVariableStringBuilder {
  typedef NamedVariableString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(NamedVariableString::VT_VALUE, value);
  }
  explicit NamedVariableStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableString>(end);
    fbb_.Required(o, NamedVariableString::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableString> CreateNamedVariableString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  NamedVariableStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableString::Traits {
  using type = NamedVariableString;
  static auto constexpr Create = CreateNamedVariableString;
  static constexpr auto name = "NamedVariableString";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableString";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NamedVariableString> CreateNamedVariableStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return SF::Flat::CreateNamedVariableString(
      _fbb,
      value__);
}

struct NamedVariableInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableIntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct NamedVariableIntBuilder {
  typedef NamedVariableInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(NamedVariableInt::VT_VALUE, value, 0);
  }
  explicit NamedVariableIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableInt> CreateNamedVariableInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  NamedVariableIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableInt::Traits {
  using type = NamedVariableInt;
  static auto constexpr Create = CreateNamedVariableInt;
  static constexpr auto name = "NamedVariableInt";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableInt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableUInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableUIntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct NamedVariableUIntBuilder {
  typedef NamedVariableUInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(NamedVariableUInt::VT_VALUE, value, 0);
  }
  explicit NamedVariableUIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableUInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableUInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableUInt> CreateNamedVariableUInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  NamedVariableUIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableUInt::Traits {
  using type = NamedVariableUInt;
  static auto constexpr Create = CreateNamedVariableUInt;
  static constexpr auto name = "NamedVariableUInt";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableUInt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableInt64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableInt64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableInt64Builder {
  typedef NamedVariableInt64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(NamedVariableInt64::VT_VALUE, value, 0);
  }
  explicit NamedVariableInt64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableInt64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableInt64> CreateNamedVariableInt64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  NamedVariableInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableInt64::Traits {
  using type = NamedVariableInt64;
  static auto constexpr Create = CreateNamedVariableInt64;
  static constexpr auto name = "NamedVariableInt64";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableInt64";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableUInt64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableUInt64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableUInt64Builder {
  typedef NamedVariableUInt64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(NamedVariableUInt64::VT_VALUE, value, 0);
  }
  explicit NamedVariableUInt64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableUInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableUInt64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableUInt64> CreateNamedVariableUInt64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  NamedVariableUInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableUInt64::Traits {
  using type = NamedVariableUInt64;
  static auto constexpr Create = CreateNamedVariableUInt64;
  static constexpr auto name = "NamedVariableUInt64";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableUInt64";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableFloatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct NamedVariableFloatBuilder {
  typedef NamedVariableFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(NamedVariableFloat::VT_VALUE, value, 0.0f);
  }
  explicit NamedVariableFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableFloat> CreateNamedVariableFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  NamedVariableFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableFloat::Traits {
  using type = NamedVariableFloat;
  static auto constexpr Create = CreateNamedVariableFloat;
  static constexpr auto name = "NamedVariableFloat";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableFloat";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableDouble FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableDoubleBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableDoubleBuilder {
  typedef NamedVariableDouble Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(NamedVariableDouble::VT_VALUE, value, 0.0);
  }
  explicit NamedVariableDoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableDouble>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableDouble> CreateNamedVariableDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  NamedVariableDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableDouble::Traits {
  using type = NamedVariableDouble;
  static auto constexpr Create = CreateNamedVariableDouble;
  static constexpr auto name = "NamedVariableDouble";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableDouble";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableBool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableBoolBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct NamedVariableBoolBuilder {
  typedef NamedVariableBool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(NamedVariableBool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit NamedVariableBoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableBool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableBool> CreateNamedVariableBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  NamedVariableBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableBool::Traits {
  using type = NamedVariableBool;
  static auto constexpr Create = CreateNamedVariableBool;
  static constexpr auto name = "NamedVariableBool";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableBool";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableGuid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableGuidBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const SF::Flat::Guid *value() const {
    return GetStruct<const SF::Flat::Guid *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SF::Flat::Guid>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableGuidBuilder {
  typedef NamedVariableGuid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(const SF::Flat::Guid *value) {
    fbb_.AddStruct(NamedVariableGuid::VT_VALUE, value);
  }
  explicit NamedVariableGuidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableGuid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableGuid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableGuid> CreateNamedVariableGuid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::Guid *value = nullptr) {
  NamedVariableGuidBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableGuid::Traits {
  using type = NamedVariableGuid;
  static auto constexpr Create = CreateNamedVariableGuid;
  static constexpr auto name = "NamedVariableGuid";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableGuid";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  SF::Flat::NamedVariableValue value_type() const {
    return static_cast<SF::Flat::NamedVariableValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const SF::Flat::NamedVariableString *value_as_NamedVariableString() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableString ? static_cast<const SF::Flat::NamedVariableString *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableBool *value_as_NamedVariableBool() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableBool ? static_cast<const SF::Flat::NamedVariableBool *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableFloat *value_as_NamedVariableFloat() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableFloat ? static_cast<const SF::Flat::NamedVariableFloat *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableDouble *value_as_NamedVariableDouble() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableDouble ? static_cast<const SF::Flat::NamedVariableDouble *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableInt *value_as_NamedVariableInt() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableInt ? static_cast<const SF::Flat::NamedVariableInt *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableUInt *value_as_NamedVariableUInt() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableUInt ? static_cast<const SF::Flat::NamedVariableUInt *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableInt64 *value_as_NamedVariableInt64() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableInt64 ? static_cast<const SF::Flat::NamedVariableInt64 *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableUInt64 *value_as_NamedVariableUInt64() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableUInt64 ? static_cast<const SF::Flat::NamedVariableUInt64 *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableGuid *value_as_NamedVariableGuid() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableGuid ? static_cast<const SF::Flat::NamedVariableGuid *>(value()) : nullptr;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return value_type();
    else if constexpr (Index == 2) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyNamedVariableValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SF::Flat::NamedVariableString *NamedVariable::value_as<SF::Flat::NamedVariableString>() const {
  return value_as_NamedVariableString();
}

template<> inline const SF::Flat::NamedVariableBool *NamedVariable::value_as<SF::Flat::NamedVariableBool>() const {
  return value_as_NamedVariableBool();
}

template<> inline const SF::Flat::NamedVariableFloat *NamedVariable::value_as<SF::Flat::NamedVariableFloat>() const {
  return value_as_NamedVariableFloat();
}

template<> inline const SF::Flat::NamedVariableDouble *NamedVariable::value_as<SF::Flat::NamedVariableDouble>() const {
  return value_as_NamedVariableDouble();
}

template<> inline const SF::Flat::NamedVariableInt *NamedVariable::value_as<SF::Flat::NamedVariableInt>() const {
  return value_as_NamedVariableInt();
}

template<> inline const SF::Flat::NamedVariableUInt *NamedVariable::value_as<SF::Flat::NamedVariableUInt>() const {
  return value_as_NamedVariableUInt();
}

template<> inline const SF::Flat::NamedVariableInt64 *NamedVariable::value_as<SF::Flat::NamedVariableInt64>() const {
  return value_as_NamedVariableInt64();
}

template<> inline const SF::Flat::NamedVariableUInt64 *NamedVariable::value_as<SF::Flat::NamedVariableUInt64>() const {
  return value_as_NamedVariableUInt64();
}

template<> inline const SF::Flat::NamedVariableGuid *NamedVariable::value_as<SF::Flat::NamedVariableGuid>() const {
  return value_as_NamedVariableGuid();
}

struct NamedVariableBuilder {
  typedef NamedVariable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NamedVariable::VT_NAME, name);
  }
  void add_value_type(SF::Flat::NamedVariableValue value_type) {
    fbb_.AddElement<uint8_t>(NamedVariable::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(NamedVariable::VT_VALUE, value);
  }
  explicit NamedVariableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariable>(end);
    fbb_.Required(o, NamedVariable::VT_NAME);
    fbb_.Required(o, NamedVariable::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariable> CreateNamedVariable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    SF::Flat::NamedVariableValue value_type = SF::Flat::NamedVariableValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  NamedVariableBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct NamedVariable::Traits {
  using type = NamedVariable;
  static auto constexpr Create = CreateNamedVariable;
  static constexpr auto name = "NamedVariable";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariable";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "value_type",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NamedVariable> CreateNamedVariableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    SF::Flat::NamedVariableValue value_type = SF::Flat::NamedVariableValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SF::Flat::CreateNamedVariable(
      _fbb,
      name__,
      value_type,
      value);
}

inline bool VerifyNamedVariableValue(::flatbuffers::Verifier &verifier, const void *obj, NamedVariableValue type) {
  switch (type) {
    case NamedVariableValue::NONE: {
      return true;
    }
    case NamedVariableValue::NamedVariableString: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableBool: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableFloat: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableDouble: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableInt: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableUInt: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableUInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableInt64: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableUInt64: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableUInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableGuid: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableGuid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNamedVariableValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<NamedVariableValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNamedVariableValue(
        verifier,  values->Get(i), types->GetEnum<NamedVariableValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Flat
}  // namespace SF

#endif  // FLATBUFFERS_GENERATED_SFTYPES_SF_FLAT_H_
