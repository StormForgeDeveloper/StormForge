// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SFTYPES_SF_FLAT_H_
#define FLATBUFFERS_GENERATED_SFTYPES_SF_FLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace SF {
namespace Flat {

struct TimeSpan;

struct Vector4;

struct UInt128;

struct GenericError;
struct GenericErrorBuilder;

struct EntityUID;

struct RouteContext;

struct PlayerPlatformID;

struct PlayerInformation;
struct PlayerInformationBuilder;

struct TotalRankingPlayerInformation;
struct TotalRankingPlayerInformationBuilder;

struct AchievementStat;
struct AchievementStatBuilder;

struct MatchingQueueTicket;

struct ActorMovement;
struct ActorMovementBuilder;

struct NamedVariableString;
struct NamedVariableStringBuilder;

struct NamedVariableInt;
struct NamedVariableIntBuilder;

struct NamedVariableUInt;
struct NamedVariableUIntBuilder;

struct NamedVariableInt64;
struct NamedVariableInt64Builder;

struct NamedVariableUInt64;
struct NamedVariableUInt64Builder;

struct NamedVariableFloat;
struct NamedVariableFloatBuilder;

struct NamedVariableDouble;
struct NamedVariableDoubleBuilder;

struct NamedVariableBool;
struct NamedVariableBoolBuilder;

struct NamedVariable;
struct NamedVariableBuilder;

enum class Platform : int8_t {
  BR = 0,
  Steam = 1,
  Facebook = 2,
  MIN = BR,
  MAX = Facebook
};

inline const Platform (&EnumValuesPlatform())[3] {
  static const Platform values[] = {
    Platform::BR,
    Platform::Steam,
    Platform::Facebook
  };
  return values;
}

inline const char * const *EnumNamesPlatform() {
  static const char * const names[4] = {
    "BR",
    "Steam",
    "Facebook",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlatform(Platform e) {
  if (::flatbuffers::IsOutRange(e, Platform::BR, Platform::Facebook)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlatform()[index];
}

enum class GameStateID : int8_t {
  None = 0,
  Red = 1,
  Green = 2,
  Blue = 3,
  MIN = None,
  MAX = Blue
};

inline const GameStateID (&EnumValuesGameStateID())[4] {
  static const GameStateID values[] = {
    GameStateID::None,
    GameStateID::Red,
    GameStateID::Green,
    GameStateID::Blue
  };
  return values;
}

inline const char * const *EnumNamesGameStateID() {
  static const char * const names[5] = {
    "None",
    "Red",
    "Green",
    "Blue",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameStateID(GameStateID e) {
  if (::flatbuffers::IsOutRange(e, GameStateID::None, GameStateID::Blue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameStateID()[index];
}

enum class ChatMessageType : int8_t {
  Zone = 0,
  ZoneGlobal = 1,
  Whisper = 2,
  Channel = 3,
  System = 4,
  MIN = Zone,
  MAX = System
};

inline const ChatMessageType (&EnumValuesChatMessageType())[5] {
  static const ChatMessageType values[] = {
    ChatMessageType::Zone,
    ChatMessageType::ZoneGlobal,
    ChatMessageType::Whisper,
    ChatMessageType::Channel,
    ChatMessageType::System
  };
  return values;
}

inline const char * const *EnumNamesChatMessageType() {
  static const char * const names[6] = {
    "Zone",
    "ZoneGlobal",
    "Whisper",
    "Channel",
    "System",
    nullptr
  };
  return names;
}

inline const char *EnumNameChatMessageType(ChatMessageType e) {
  if (::flatbuffers::IsOutRange(e, ChatMessageType::Zone, ChatMessageType::System)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChatMessageType()[index];
}

enum class NamedVariableValue : uint8_t {
  NONE = 0,
  NamedVariableString = 1,
  NamedVariableBool = 2,
  NamedVariableFloat = 3,
  NamedVariableDouble = 4,
  NamedVariableInt = 5,
  NamedVariableUInt = 6,
  NamedVariableInt64 = 7,
  NamedVariableUInt64 = 8,
  MIN = NONE,
  MAX = NamedVariableUInt64
};

inline const NamedVariableValue (&EnumValuesNamedVariableValue())[9] {
  static const NamedVariableValue values[] = {
    NamedVariableValue::NONE,
    NamedVariableValue::NamedVariableString,
    NamedVariableValue::NamedVariableBool,
    NamedVariableValue::NamedVariableFloat,
    NamedVariableValue::NamedVariableDouble,
    NamedVariableValue::NamedVariableInt,
    NamedVariableValue::NamedVariableUInt,
    NamedVariableValue::NamedVariableInt64,
    NamedVariableValue::NamedVariableUInt64
  };
  return values;
}

inline const char * const *EnumNamesNamedVariableValue() {
  static const char * const names[10] = {
    "NONE",
    "NamedVariableString",
    "NamedVariableBool",
    "NamedVariableFloat",
    "NamedVariableDouble",
    "NamedVariableInt",
    "NamedVariableUInt",
    "NamedVariableInt64",
    "NamedVariableUInt64",
    nullptr
  };
  return names;
}

inline const char *EnumNameNamedVariableValue(NamedVariableValue e) {
  if (::flatbuffers::IsOutRange(e, NamedVariableValue::NONE, NamedVariableValue::NamedVariableUInt64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNamedVariableValue()[index];
}

template<typename T> struct NamedVariableValueTraits {
  static const NamedVariableValue enum_value = NamedVariableValue::NONE;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableString> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableString;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableBool> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableBool;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableFloat> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableFloat;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableDouble> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableDouble;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableInt> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableInt;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableUInt> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableUInt;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableInt64> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableInt64;
};

template<> struct NamedVariableValueTraits<SF::Flat::NamedVariableUInt64> {
  static const NamedVariableValue enum_value = NamedVariableValue::NamedVariableUInt64;
};

bool VerifyNamedVariableValue(::flatbuffers::Verifier &verifier, const void *obj, NamedVariableValue type);
bool VerifyNamedVariableValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<NamedVariableValue> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TimeSpan FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t milliseconds_;

 public:
  struct Traits;
  TimeSpan()
      : milliseconds_(0) {
  }
  TimeSpan(int64_t _milliseconds)
      : milliseconds_(::flatbuffers::EndianScalar(_milliseconds)) {
  }
  int64_t milliseconds() const {
    return ::flatbuffers::EndianScalar(milliseconds_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return milliseconds();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(TimeSpan, 8);

struct TimeSpan::Traits {
  using type = TimeSpan;
  static constexpr auto name = "TimeSpan";
  static constexpr auto fully_qualified_name = "SF.Flat.TimeSpan";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "milliseconds"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  struct Traits;
  Vector4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vector4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return x();
    else if constexpr (Index == 1) return y();
    else if constexpr (Index == 2) return z();
    else if constexpr (Index == 3) return w();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Vector4, 16);

struct Vector4::Traits {
  using type = Vector4;
  static constexpr auto name = "Vector4";
  static constexpr auto fully_qualified_name = "SF.Flat.Vector4";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "x",
    "y",
    "z",
    "w"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) UInt128 FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t low_;
  uint64_t high_;

 public:
  struct Traits;
  UInt128()
      : low_(0),
        high_(0) {
  }
  UInt128(uint64_t _low, uint64_t _high)
      : low_(::flatbuffers::EndianScalar(_low)),
        high_(::flatbuffers::EndianScalar(_high)) {
  }
  uint64_t low() const {
    return ::flatbuffers::EndianScalar(low_);
  }
  uint64_t high() const {
    return ::flatbuffers::EndianScalar(high_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return low();
    else if constexpr (Index == 1) return high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(UInt128, 16);

struct UInt128::Traits {
  using type = UInt128;
  static constexpr auto name = "UInt128";
  static constexpr auto fully_qualified_name = "SF.Flat.UInt128";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "low",
    "high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityUID FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t entity_id_;
  uint32_t server_id_;

 public:
  struct Traits;
  EntityUID()
      : entity_id_(0),
        server_id_(0) {
  }
  EntityUID(uint32_t _entity_id, uint32_t _server_id)
      : entity_id_(::flatbuffers::EndianScalar(_entity_id)),
        server_id_(::flatbuffers::EndianScalar(_server_id)) {
  }
  uint32_t entity_id() const {
    return ::flatbuffers::EndianScalar(entity_id_);
  }
  uint32_t server_id() const {
    return ::flatbuffers::EndianScalar(server_id_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return entity_id();
    else if constexpr (Index == 1) return server_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(EntityUID, 8);

struct EntityUID::Traits {
  using type = EntityUID;
  static constexpr auto name = "EntityUID";
  static constexpr auto fully_qualified_name = "SF.Flat.EntityUID";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "entity_id",
    "server_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RouteContext FLATBUFFERS_FINAL_CLASS {
 private:
  SF::Flat::EntityUID from_;
  SF::Flat::EntityUID to_;

 public:
  struct Traits;
  RouteContext()
      : from_(),
        to_() {
  }
  RouteContext(const SF::Flat::EntityUID &_from, const SF::Flat::EntityUID &_to)
      : from_(_from),
        to_(_to) {
  }
  const SF::Flat::EntityUID &from() const {
    return from_;
  }
  const SF::Flat::EntityUID &to() const {
    return to_;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return from();
    else if constexpr (Index == 1) return to();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(RouteContext, 16);

struct RouteContext::Traits {
  using type = RouteContext;
  static constexpr auto name = "RouteContext";
  static constexpr auto fully_qualified_name = "SF.Flat.RouteContext";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "from",
    "to"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PlayerPlatformID FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t player_id_;
  int8_t platform_data_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  struct Traits;
  PlayerPlatformID()
      : player_id_(0),
        platform_data_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  PlayerPlatformID(uint64_t _player_id, SF::Flat::Platform _platform_data)
      : player_id_(::flatbuffers::EndianScalar(_player_id)),
        platform_data_(::flatbuffers::EndianScalar(static_cast<int8_t>(_platform_data))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  uint64_t player_id() const {
    return ::flatbuffers::EndianScalar(player_id_);
  }
  SF::Flat::Platform platform_data() const {
    return static_cast<SF::Flat::Platform>(::flatbuffers::EndianScalar(platform_data_));
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else if constexpr (Index == 1) return platform_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(PlayerPlatformID, 16);

struct PlayerPlatformID::Traits {
  using type = PlayerPlatformID;
  static constexpr auto name = "PlayerPlatformID";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayerPlatformID";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id",
    "platform_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) MatchingQueueTicket FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t queue_uid_;
  uint64_t queue_item_id_;

 public:
  struct Traits;
  MatchingQueueTicket()
      : queue_uid_(0),
        queue_item_id_(0) {
  }
  MatchingQueueTicket(uint64_t _queue_uid, uint64_t _queue_item_id)
      : queue_uid_(::flatbuffers::EndianScalar(_queue_uid)),
        queue_item_id_(::flatbuffers::EndianScalar(_queue_item_id)) {
  }
  uint64_t queue_uid() const {
    return ::flatbuffers::EndianScalar(queue_uid_);
  }
  uint64_t queue_item_id() const {
    return ::flatbuffers::EndianScalar(queue_item_id_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return queue_uid();
    else if constexpr (Index == 1) return queue_item_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(MatchingQueueTicket, 16);

struct MatchingQueueTicket::Traits {
  using type = MatchingQueueTicket;
  static constexpr auto name = "MatchingQueueTicket";
  static constexpr auto fully_qualified_name = "SF.Flat.MatchingQueueTicket";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "queue_uid",
    "queue_item_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GenericError FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GenericErrorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSACTION_ID = 4,
    VT_RESULT_CODE = 6,
    VT_REASON = 8
  };
  uint64_t transaction_id() const {
    return GetField<uint64_t>(VT_TRANSACTION_ID, 0);
  }
  int32_t result_code() const {
    return GetField<int32_t>(VT_RESULT_CODE, 0);
  }
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return transaction_id();
    else if constexpr (Index == 1) return result_code();
    else if constexpr (Index == 2) return reason();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TRANSACTION_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_RESULT_CODE, 4) &&
           VerifyOffsetRequired(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct GenericErrorBuilder {
  typedef GenericError Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_transaction_id(uint64_t transaction_id) {
    fbb_.AddElement<uint64_t>(GenericError::VT_TRANSACTION_ID, transaction_id, 0);
  }
  void add_result_code(int32_t result_code) {
    fbb_.AddElement<int32_t>(GenericError::VT_RESULT_CODE, result_code, 0);
  }
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(GenericError::VT_REASON, reason);
  }
  explicit GenericErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GenericError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GenericError>(end);
    fbb_.Required(o, GenericError::VT_REASON);
    return o;
  }
};

inline ::flatbuffers::Offset<GenericError> CreateGenericError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t transaction_id = 0,
    int32_t result_code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  GenericErrorBuilder builder_(_fbb);
  builder_.add_transaction_id(transaction_id);
  builder_.add_reason(reason);
  builder_.add_result_code(result_code);
  return builder_.Finish();
}

struct GenericError::Traits {
  using type = GenericError;
  static auto constexpr Create = CreateGenericError;
  static constexpr auto name = "GenericError";
  static constexpr auto fully_qualified_name = "SF.Flat.GenericError";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "transaction_id",
    "result_code",
    "reason"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GenericError> CreateGenericErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t transaction_id = 0,
    int32_t result_code = 0,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return SF::Flat::CreateGenericError(
      _fbb,
      transaction_id,
      result_code,
      reason__);
}

struct PlayerInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInformationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_PLAYER_PLATFORM_ID = 6,
    VT_PROFILE_NAME = 8,
    VT_LAST_ACTIVE_TIME = 10
  };
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  const ::flatbuffers::String *profile_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROFILE_NAME);
  }
  uint64_t last_active_time() const {
    return GetField<uint64_t>(VT_LAST_ACTIVE_TIME, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else if constexpr (Index == 1) return player_platform_id();
    else if constexpr (Index == 2) return profile_name();
    else if constexpr (Index == 3) return last_active_time();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           VerifyOffset(verifier, VT_PROFILE_NAME) &&
           verifier.VerifyString(profile_name()) &&
           VerifyField<uint64_t>(verifier, VT_LAST_ACTIVE_TIME, 8) &&
           verifier.EndTable();
  }
};

struct PlayerInformationBuilder {
  typedef PlayerInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(PlayerInformation::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(PlayerInformation::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  void add_profile_name(::flatbuffers::Offset<::flatbuffers::String> profile_name) {
    fbb_.AddOffset(PlayerInformation::VT_PROFILE_NAME, profile_name);
  }
  void add_last_active_time(uint64_t last_active_time) {
    fbb_.AddElement<uint64_t>(PlayerInformation::VT_LAST_ACTIVE_TIME, last_active_time, 0);
  }
  explicit PlayerInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInformation>(end);
    fbb_.Required(o, PlayerInformation::VT_PLAYER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInformation> CreatePlayerInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> profile_name = 0,
    uint64_t last_active_time = 0) {
  PlayerInformationBuilder builder_(_fbb);
  builder_.add_last_active_time(last_active_time);
  builder_.add_player_id(player_id);
  builder_.add_profile_name(profile_name);
  builder_.add_player_platform_id(player_platform_id);
  return builder_.Finish();
}

struct PlayerInformation::Traits {
  using type = PlayerInformation;
  static auto constexpr Create = CreatePlayerInformation;
  static constexpr auto name = "PlayerInformation";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayerInformation";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id",
    "player_platform_id",
    "profile_name",
    "last_active_time"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PlayerInformation> CreatePlayerInformationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    const char *profile_name = nullptr,
    uint64_t last_active_time = 0) {
  auto profile_name__ = profile_name ? _fbb.CreateString(profile_name) : 0;
  return SF::Flat::CreatePlayerInformation(
      _fbb,
      player_id,
      player_platform_id,
      profile_name__,
      last_active_time);
}

struct TotalRankingPlayerInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TotalRankingPlayerInformationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANKING_ID = 4,
    VT_RANKING = 6,
    VT_PLAYER_ID = 8,
    VT_PLAYER_PLATFORM_ID = 10,
    VT_NICK_NAME = 12,
    VT_LEVEL = 14,
    VT_SCORE_LOW = 16,
    VT_SCORE_HIGH = 18
  };
  uint32_t ranking_id() const {
    return GetField<uint32_t>(VT_RANKING_ID, 0);
  }
  uint32_t ranking() const {
    return GetField<uint32_t>(VT_RANKING, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  const ::flatbuffers::String *nick_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICK_NAME);
  }
  uint32_t level() const {
    return GetField<uint32_t>(VT_LEVEL, 0);
  }
  uint32_t score_low() const {
    return GetField<uint32_t>(VT_SCORE_LOW, 0);
  }
  uint32_t score_high() const {
    return GetField<uint32_t>(VT_SCORE_HIGH, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ranking_id();
    else if constexpr (Index == 1) return ranking();
    else if constexpr (Index == 2) return player_id();
    else if constexpr (Index == 3) return player_platform_id();
    else if constexpr (Index == 4) return nick_name();
    else if constexpr (Index == 5) return level();
    else if constexpr (Index == 6) return score_low();
    else if constexpr (Index == 7) return score_high();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RANKING_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_RANKING, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           VerifyOffset(verifier, VT_NICK_NAME) &&
           verifier.VerifyString(nick_name()) &&
           VerifyField<uint32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCORE_LOW, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCORE_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct TotalRankingPlayerInformationBuilder {
  typedef TotalRankingPlayerInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ranking_id(uint32_t ranking_id) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_RANKING_ID, ranking_id, 0);
  }
  void add_ranking(uint32_t ranking) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_RANKING, ranking, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(TotalRankingPlayerInformation::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(TotalRankingPlayerInformation::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  void add_nick_name(::flatbuffers::Offset<::flatbuffers::String> nick_name) {
    fbb_.AddOffset(TotalRankingPlayerInformation::VT_NICK_NAME, nick_name);
  }
  void add_level(uint32_t level) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_LEVEL, level, 0);
  }
  void add_score_low(uint32_t score_low) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_SCORE_LOW, score_low, 0);
  }
  void add_score_high(uint32_t score_high) {
    fbb_.AddElement<uint32_t>(TotalRankingPlayerInformation::VT_SCORE_HIGH, score_high, 0);
  }
  explicit TotalRankingPlayerInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TotalRankingPlayerInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TotalRankingPlayerInformation>(end);
    fbb_.Required(o, TotalRankingPlayerInformation::VT_PLAYER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<TotalRankingPlayerInformation> CreateTotalRankingPlayerInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ranking_id = 0,
    uint32_t ranking = 0,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> nick_name = 0,
    uint32_t level = 0,
    uint32_t score_low = 0,
    uint32_t score_high = 0) {
  TotalRankingPlayerInformationBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_score_high(score_high);
  builder_.add_score_low(score_low);
  builder_.add_level(level);
  builder_.add_nick_name(nick_name);
  builder_.add_player_platform_id(player_platform_id);
  builder_.add_ranking(ranking);
  builder_.add_ranking_id(ranking_id);
  return builder_.Finish();
}

struct TotalRankingPlayerInformation::Traits {
  using type = TotalRankingPlayerInformation;
  static auto constexpr Create = CreateTotalRankingPlayerInformation;
  static constexpr auto name = "TotalRankingPlayerInformation";
  static constexpr auto fully_qualified_name = "SF.Flat.TotalRankingPlayerInformation";
  static constexpr size_t fields_number = 8;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ranking_id",
    "ranking",
    "player_id",
    "player_platform_id",
    "nick_name",
    "level",
    "score_low",
    "score_high"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<TotalRankingPlayerInformation> CreateTotalRankingPlayerInformationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ranking_id = 0,
    uint32_t ranking = 0,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    const char *nick_name = nullptr,
    uint32_t level = 0,
    uint32_t score_low = 0,
    uint32_t score_high = 0) {
  auto nick_name__ = nick_name ? _fbb.CreateString(nick_name) : 0;
  return SF::Flat::CreateTotalRankingPlayerInformation(
      _fbb,
      ranking_id,
      ranking,
      player_id,
      player_platform_id,
      nick_name__,
      level,
      score_low,
      score_high);
}

struct AchievementStat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AchievementStatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACHIEVEMENT_STAT_ID = 4,
    VT_STAT_VALUE = 6
  };
  uint32_t achievement_stat_id() const {
    return GetField<uint32_t>(VT_ACHIEVEMENT_STAT_ID, 0);
  }
  int32_t stat_value() const {
    return GetField<int32_t>(VT_STAT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return achievement_stat_id();
    else if constexpr (Index == 1) return stat_value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACHIEVEMENT_STAT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_STAT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct AchievementStatBuilder {
  typedef AchievementStat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_achievement_stat_id(uint32_t achievement_stat_id) {
    fbb_.AddElement<uint32_t>(AchievementStat::VT_ACHIEVEMENT_STAT_ID, achievement_stat_id, 0);
  }
  void add_stat_value(int32_t stat_value) {
    fbb_.AddElement<int32_t>(AchievementStat::VT_STAT_VALUE, stat_value, 0);
  }
  explicit AchievementStatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AchievementStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AchievementStat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AchievementStat> CreateAchievementStat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t achievement_stat_id = 0,
    int32_t stat_value = 0) {
  AchievementStatBuilder builder_(_fbb);
  builder_.add_stat_value(stat_value);
  builder_.add_achievement_stat_id(achievement_stat_id);
  return builder_.Finish();
}

struct AchievementStat::Traits {
  using type = AchievementStat;
  static auto constexpr Create = CreateAchievementStat;
  static constexpr auto name = "AchievementStat";
  static constexpr auto fully_qualified_name = "SF.Flat.AchievementStat";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "achievement_stat_id",
    "stat_value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ActorMovement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActorMovementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_LINEAR_VELOCITY = 6,
    VT_ACTOR_ID = 8,
    VT_ANGULAR_YAW = 10,
    VT_MOVE_FRAME = 12,
    VT_MOVEMENT_STATE = 14
  };
  const SF::Flat::Vector4 *position() const {
    return GetStruct<const SF::Flat::Vector4 *>(VT_POSITION);
  }
  const SF::Flat::Vector4 *linear_velocity() const {
    return GetStruct<const SF::Flat::Vector4 *>(VT_LINEAR_VELOCITY);
  }
  uint32_t actor_id() const {
    return GetField<uint32_t>(VT_ACTOR_ID, 0);
  }
  float angular_yaw() const {
    return GetField<float>(VT_ANGULAR_YAW, 0.0f);
  }
  uint32_t move_frame() const {
    return GetField<uint32_t>(VT_MOVE_FRAME, 0);
  }
  uint32_t movement_state() const {
    return GetField<uint32_t>(VT_MOVEMENT_STATE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return position();
    else if constexpr (Index == 1) return linear_velocity();
    else if constexpr (Index == 2) return actor_id();
    else if constexpr (Index == 3) return angular_yaw();
    else if constexpr (Index == 4) return move_frame();
    else if constexpr (Index == 5) return movement_state();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SF::Flat::Vector4>(verifier, VT_POSITION, 4) &&
           VerifyField<SF::Flat::Vector4>(verifier, VT_LINEAR_VELOCITY, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACTOR_ID, 4) &&
           VerifyField<float>(verifier, VT_ANGULAR_YAW, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOVE_FRAME, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOVEMENT_STATE, 4) &&
           verifier.EndTable();
  }
};

struct ActorMovementBuilder {
  typedef ActorMovement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const SF::Flat::Vector4 *position) {
    fbb_.AddStruct(ActorMovement::VT_POSITION, position);
  }
  void add_linear_velocity(const SF::Flat::Vector4 *linear_velocity) {
    fbb_.AddStruct(ActorMovement::VT_LINEAR_VELOCITY, linear_velocity);
  }
  void add_actor_id(uint32_t actor_id) {
    fbb_.AddElement<uint32_t>(ActorMovement::VT_ACTOR_ID, actor_id, 0);
  }
  void add_angular_yaw(float angular_yaw) {
    fbb_.AddElement<float>(ActorMovement::VT_ANGULAR_YAW, angular_yaw, 0.0f);
  }
  void add_move_frame(uint32_t move_frame) {
    fbb_.AddElement<uint32_t>(ActorMovement::VT_MOVE_FRAME, move_frame, 0);
  }
  void add_movement_state(uint32_t movement_state) {
    fbb_.AddElement<uint32_t>(ActorMovement::VT_MOVEMENT_STATE, movement_state, 0);
  }
  explicit ActorMovementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActorMovement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActorMovement>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActorMovement> CreateActorMovement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::Vector4 *position = nullptr,
    const SF::Flat::Vector4 *linear_velocity = nullptr,
    uint32_t actor_id = 0,
    float angular_yaw = 0.0f,
    uint32_t move_frame = 0,
    uint32_t movement_state = 0) {
  ActorMovementBuilder builder_(_fbb);
  builder_.add_movement_state(movement_state);
  builder_.add_move_frame(move_frame);
  builder_.add_angular_yaw(angular_yaw);
  builder_.add_actor_id(actor_id);
  builder_.add_linear_velocity(linear_velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct ActorMovement::Traits {
  using type = ActorMovement;
  static auto constexpr Create = CreateActorMovement;
  static constexpr auto name = "ActorMovement";
  static constexpr auto fully_qualified_name = "SF.Flat.ActorMovement";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "position",
    "linear_velocity",
    "actor_id",
    "angular_yaw",
    "move_frame",
    "movement_state"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableStringBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct NamedVariableStringBuilder {
  typedef NamedVariableString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(NamedVariableString::VT_VALUE, value);
  }
  explicit NamedVariableStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableString>(end);
    fbb_.Required(o, NamedVariableString::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableString> CreateNamedVariableString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  NamedVariableStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableString::Traits {
  using type = NamedVariableString;
  static auto constexpr Create = CreateNamedVariableString;
  static constexpr auto name = "NamedVariableString";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableString";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NamedVariableString> CreateNamedVariableStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return SF::Flat::CreateNamedVariableString(
      _fbb,
      value__);
}

struct NamedVariableInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableIntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct NamedVariableIntBuilder {
  typedef NamedVariableInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(NamedVariableInt::VT_VALUE, value, 0);
  }
  explicit NamedVariableIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableInt> CreateNamedVariableInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  NamedVariableIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableInt::Traits {
  using type = NamedVariableInt;
  static auto constexpr Create = CreateNamedVariableInt;
  static constexpr auto name = "NamedVariableInt";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableInt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableUInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableUIntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct NamedVariableUIntBuilder {
  typedef NamedVariableUInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(NamedVariableUInt::VT_VALUE, value, 0);
  }
  explicit NamedVariableUIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableUInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableUInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableUInt> CreateNamedVariableUInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  NamedVariableUIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableUInt::Traits {
  using type = NamedVariableUInt;
  static auto constexpr Create = CreateNamedVariableUInt;
  static constexpr auto name = "NamedVariableUInt";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableUInt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableInt64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableInt64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableInt64Builder {
  typedef NamedVariableInt64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(NamedVariableInt64::VT_VALUE, value, 0);
  }
  explicit NamedVariableInt64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableInt64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableInt64> CreateNamedVariableInt64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  NamedVariableInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableInt64::Traits {
  using type = NamedVariableInt64;
  static auto constexpr Create = CreateNamedVariableInt64;
  static constexpr auto name = "NamedVariableInt64";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableInt64";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableUInt64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableUInt64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableUInt64Builder {
  typedef NamedVariableUInt64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(NamedVariableUInt64::VT_VALUE, value, 0);
  }
  explicit NamedVariableUInt64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableUInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableUInt64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableUInt64> CreateNamedVariableUInt64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  NamedVariableUInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableUInt64::Traits {
  using type = NamedVariableUInt64;
  static auto constexpr Create = CreateNamedVariableUInt64;
  static constexpr auto name = "NamedVariableUInt64";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableUInt64";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableFloatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct NamedVariableFloatBuilder {
  typedef NamedVariableFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(NamedVariableFloat::VT_VALUE, value, 0.0f);
  }
  explicit NamedVariableFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableFloat> CreateNamedVariableFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  NamedVariableFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableFloat::Traits {
  using type = NamedVariableFloat;
  static auto constexpr Create = CreateNamedVariableFloat;
  static constexpr auto name = "NamedVariableFloat";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableFloat";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableDouble FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableDoubleBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct NamedVariableDoubleBuilder {
  typedef NamedVariableDouble Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(NamedVariableDouble::VT_VALUE, value, 0.0);
  }
  explicit NamedVariableDoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableDouble>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableDouble> CreateNamedVariableDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  NamedVariableDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableDouble::Traits {
  using type = NamedVariableDouble;
  static auto constexpr Create = CreateNamedVariableDouble;
  static constexpr auto name = "NamedVariableDouble";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableDouble";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariableBool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableBoolBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct NamedVariableBoolBuilder {
  typedef NamedVariableBool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(NamedVariableBool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit NamedVariableBoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariableBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariableBool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariableBool> CreateNamedVariableBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  NamedVariableBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NamedVariableBool::Traits {
  using type = NamedVariableBool;
  static auto constexpr Create = CreateNamedVariableBool;
  static constexpr auto name = "NamedVariableBool";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariableBool";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NamedVariable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedVariableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  SF::Flat::NamedVariableValue value_type() const {
    return static_cast<SF::Flat::NamedVariableValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const SF::Flat::NamedVariableString *value_as_NamedVariableString() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableString ? static_cast<const SF::Flat::NamedVariableString *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableBool *value_as_NamedVariableBool() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableBool ? static_cast<const SF::Flat::NamedVariableBool *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableFloat *value_as_NamedVariableFloat() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableFloat ? static_cast<const SF::Flat::NamedVariableFloat *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableDouble *value_as_NamedVariableDouble() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableDouble ? static_cast<const SF::Flat::NamedVariableDouble *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableInt *value_as_NamedVariableInt() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableInt ? static_cast<const SF::Flat::NamedVariableInt *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableUInt *value_as_NamedVariableUInt() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableUInt ? static_cast<const SF::Flat::NamedVariableUInt *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableInt64 *value_as_NamedVariableInt64() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableInt64 ? static_cast<const SF::Flat::NamedVariableInt64 *>(value()) : nullptr;
  }
  const SF::Flat::NamedVariableUInt64 *value_as_NamedVariableUInt64() const {
    return value_type() == SF::Flat::NamedVariableValue::NamedVariableUInt64 ? static_cast<const SF::Flat::NamedVariableUInt64 *>(value()) : nullptr;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return value_type();
    else if constexpr (Index == 2) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyNamedVariableValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SF::Flat::NamedVariableString *NamedVariable::value_as<SF::Flat::NamedVariableString>() const {
  return value_as_NamedVariableString();
}

template<> inline const SF::Flat::NamedVariableBool *NamedVariable::value_as<SF::Flat::NamedVariableBool>() const {
  return value_as_NamedVariableBool();
}

template<> inline const SF::Flat::NamedVariableFloat *NamedVariable::value_as<SF::Flat::NamedVariableFloat>() const {
  return value_as_NamedVariableFloat();
}

template<> inline const SF::Flat::NamedVariableDouble *NamedVariable::value_as<SF::Flat::NamedVariableDouble>() const {
  return value_as_NamedVariableDouble();
}

template<> inline const SF::Flat::NamedVariableInt *NamedVariable::value_as<SF::Flat::NamedVariableInt>() const {
  return value_as_NamedVariableInt();
}

template<> inline const SF::Flat::NamedVariableUInt *NamedVariable::value_as<SF::Flat::NamedVariableUInt>() const {
  return value_as_NamedVariableUInt();
}

template<> inline const SF::Flat::NamedVariableInt64 *NamedVariable::value_as<SF::Flat::NamedVariableInt64>() const {
  return value_as_NamedVariableInt64();
}

template<> inline const SF::Flat::NamedVariableUInt64 *NamedVariable::value_as<SF::Flat::NamedVariableUInt64>() const {
  return value_as_NamedVariableUInt64();
}

struct NamedVariableBuilder {
  typedef NamedVariable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NamedVariable::VT_NAME, name);
  }
  void add_value_type(SF::Flat::NamedVariableValue value_type) {
    fbb_.AddElement<uint8_t>(NamedVariable::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(NamedVariable::VT_VALUE, value);
  }
  explicit NamedVariableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedVariable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedVariable>(end);
    fbb_.Required(o, NamedVariable::VT_NAME);
    fbb_.Required(o, NamedVariable::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedVariable> CreateNamedVariable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    SF::Flat::NamedVariableValue value_type = SF::Flat::NamedVariableValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  NamedVariableBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct NamedVariable::Traits {
  using type = NamedVariable;
  static auto constexpr Create = CreateNamedVariable;
  static constexpr auto name = "NamedVariable";
  static constexpr auto fully_qualified_name = "SF.Flat.NamedVariable";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "value_type",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NamedVariable> CreateNamedVariableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    SF::Flat::NamedVariableValue value_type = SF::Flat::NamedVariableValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SF::Flat::CreateNamedVariable(
      _fbb,
      name__,
      value_type,
      value);
}

inline bool VerifyNamedVariableValue(::flatbuffers::Verifier &verifier, const void *obj, NamedVariableValue type) {
  switch (type) {
    case NamedVariableValue::NONE: {
      return true;
    }
    case NamedVariableValue::NamedVariableString: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableBool: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableFloat: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableDouble: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableInt: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableUInt: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableUInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableInt64: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NamedVariableValue::NamedVariableUInt64: {
      auto ptr = reinterpret_cast<const SF::Flat::NamedVariableUInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNamedVariableValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<NamedVariableValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNamedVariableValue(
        verifier,  values->Get(i), types->GetEnum<NamedVariableValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Flat
}  // namespace SF

#endif  // FLATBUFFERS_GENERATED_SFTYPES_SF_FLAT_H_
