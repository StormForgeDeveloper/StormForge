// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAME_SF_FLAT_GAME_H_
#define FLATBUFFERS_GENERATED_GAME_SF_FLAT_GAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "LocalTypes_generated.h"

namespace SF {
namespace Flat {
namespace Game {

struct HeartbeatC2SEvt;
struct HeartbeatC2SEvtBuilder;

struct JoinGameServerCmd;
struct JoinGameServerCmdBuilder;

struct JoinGameServerRes;
struct JoinGameServerResBuilder;

struct GetAchievementStatsCmd;
struct GetAchievementStatsCmdBuilder;

struct GetAchievementStatsRes;
struct GetAchievementStatsResBuilder;

struct Dummy1Cmd;
struct Dummy1CmdBuilder;

struct Dummy1Res;
struct Dummy1ResBuilder;

struct RegisterGCMCmd;
struct RegisterGCMCmdBuilder;

struct RegisterGCMRes;
struct RegisterGCMResBuilder;

struct UnregisterGCMCmd;
struct UnregisterGCMCmdBuilder;

struct UnregisterGCMRes;
struct UnregisterGCMResBuilder;

struct InviteFriendCmd;
struct InviteFriendCmdBuilder;

struct InviteFriendRes;
struct InviteFriendResBuilder;

struct AcceptFriendRequestCmd;
struct AcceptFriendRequestCmdBuilder;

struct AcceptFriendRequestRes;
struct AcceptFriendRequestResBuilder;

struct FriendRequestAcceptedS2CEvt;
struct FriendRequestAcceptedS2CEvtBuilder;

struct RemoveFriendCmd;
struct RemoveFriendCmdBuilder;

struct RemoveFriendRes;
struct RemoveFriendResBuilder;

struct FriendRemovedS2CEvt;
struct FriendRemovedS2CEvtBuilder;

struct GetFriendListCmd;
struct GetFriendListCmdBuilder;

struct GetFriendListRes;
struct GetFriendListResBuilder;

struct GetNotificationListCmd;
struct GetNotificationListCmdBuilder;

struct GetNotificationListRes;
struct GetNotificationListResBuilder;

struct DeleteNotificationCmd;
struct DeleteNotificationCmdBuilder;

struct DeleteNotificationRes;
struct DeleteNotificationResBuilder;

struct SetNotificationReadCmd;
struct SetNotificationReadCmdBuilder;

struct SetNotificationReadRes;
struct SetNotificationReadResBuilder;

struct AcceptNotificationCmd;
struct AcceptNotificationCmdBuilder;

struct AcceptNotificationRes;
struct AcceptNotificationResBuilder;

struct NotifyS2CEvt;
struct NotifyS2CEvtBuilder;

struct FindPlayerByPlatformIdCmd;
struct FindPlayerByPlatformIdCmdBuilder;

struct FindPlayerByPlatformIdRes;
struct FindPlayerByPlatformIdResBuilder;

struct FindPlayerByCharacterNameCmd;
struct FindPlayerByCharacterNameCmdBuilder;

struct FindPlayerByCharacterNameRes;
struct FindPlayerByCharacterNameResBuilder;

struct FindPlayerByPlatformUserNameCmd;
struct FindPlayerByPlatformUserNameCmdBuilder;

struct FindPlayerByPlatformUserNameRes;
struct FindPlayerByPlatformUserNameResBuilder;

struct FindPlayerByEMailCmd;
struct FindPlayerByEMailCmdBuilder;

struct FindPlayerByEMailRes;
struct FindPlayerByEMailResBuilder;

struct FindPlayerByPlayerIDCmd;
struct FindPlayerByPlayerIDCmdBuilder;

struct FindPlayerByPlayerIDRes;
struct FindPlayerByPlayerIDResBuilder;

struct RequestPlayerStatusUpdateCmd;
struct RequestPlayerStatusUpdateCmdBuilder;

struct RequestPlayerStatusUpdateRes;
struct RequestPlayerStatusUpdateResBuilder;

struct NotifyPlayerStatusUpdatedS2CEvt;
struct NotifyPlayerStatusUpdatedS2CEvtBuilder;

struct GetRankingListCmd;
struct GetRankingListCmdBuilder;

struct GetRankingListRes;
struct GetRankingListResBuilder;

struct GetUserGamePlayerInfoCmd;
struct GetUserGamePlayerInfoCmdBuilder;

struct GetUserGamePlayerInfoRes;
struct GetUserGamePlayerInfoResBuilder;

struct GetGamePlayerInfoCmd;
struct GetGamePlayerInfoCmdBuilder;

struct GetGamePlayerInfoRes;
struct GetGamePlayerInfoResBuilder;

struct LevelUpS2CEvt;
struct LevelUpS2CEvtBuilder;

struct SetNickNameCmd;
struct SetNickNameCmdBuilder;

struct SetNickNameRes;
struct SetNickNameResBuilder;

struct CreatePartyCmd;
struct CreatePartyCmdBuilder;

struct CreatePartyRes;
struct CreatePartyResBuilder;

struct JoinPartyCmd;
struct JoinPartyCmdBuilder;

struct JoinPartyRes;
struct JoinPartyResBuilder;

struct PartyPlayerJoinedS2CEvt;
struct PartyPlayerJoinedS2CEvtBuilder;

struct PartyLeaderChangedS2CEvt;
struct PartyLeaderChangedS2CEvtBuilder;

struct LeavePartyCmd;
struct LeavePartyCmdBuilder;

struct LeavePartyRes;
struct LeavePartyResBuilder;

struct PartyPlayerLeftS2CEvt;
struct PartyPlayerLeftS2CEvtBuilder;

struct PartyKickPlayerCmd;
struct PartyKickPlayerCmdBuilder;

struct PartyKickPlayerRes;
struct PartyKickPlayerResBuilder;

struct PartyPlayerKickedS2CEvt;
struct PartyPlayerKickedS2CEvtBuilder;

struct PartyInviteCmd;
struct PartyInviteCmdBuilder;

struct PartyInviteRes;
struct PartyInviteResBuilder;

struct PartyInviteRequestedS2CEvt;
struct PartyInviteRequestedS2CEvtBuilder;

struct PartyQuickChatMessageCmd;
struct PartyQuickChatMessageCmdBuilder;

struct PartyQuickChatMessageRes;
struct PartyQuickChatMessageResBuilder;

struct PartyQuickChatMessageS2CEvt;
struct PartyQuickChatMessageS2CEvtBuilder;

struct PartyChatMessageCmd;
struct PartyChatMessageCmdBuilder;

struct PartyChatMessageRes;
struct PartyChatMessageResBuilder;

struct PartyChatMessageS2CEvt;
struct PartyChatMessageS2CEvtBuilder;

struct JoinGameInstanceCmd;
struct JoinGameInstanceCmdBuilder;

struct JoinGameInstanceRes;
struct JoinGameInstanceResBuilder;

struct LeaveGameInstanceCmd;
struct LeaveGameInstanceCmdBuilder;

struct LeaveGameInstanceRes;
struct LeaveGameInstanceResBuilder;

struct SearchGameInstanceCmd;
struct SearchGameInstanceCmdBuilder;

struct SearchGameInstanceRes;
struct SearchGameInstanceResBuilder;

struct GetCharacterDataInGameInstanceCmd;
struct GetCharacterDataInGameInstanceCmdBuilder;

struct GetCharacterDataInGameInstanceRes;
struct GetCharacterDataInGameInstanceResBuilder;

struct RequestGameMatchCmd;
struct RequestGameMatchCmdBuilder;

struct RequestGameMatchRes;
struct RequestGameMatchResBuilder;

struct GameMatchedS2CEvt;
struct GameMatchedS2CEvtBuilder;

struct GameMatchFailedS2CEvt;
struct GameMatchFailedS2CEvtBuilder;

struct GameMatchingStartedS2CEvt;
struct GameMatchingStartedS2CEvtBuilder;

struct CancelGameMatchCmd;
struct CancelGameMatchCmdBuilder;

struct CancelGameMatchRes;
struct CancelGameMatchResBuilder;

struct GameMatchingCanceledS2CEvt;
struct GameMatchingCanceledS2CEvtBuilder;

struct GetUGCTemplatesCmd;
struct GetUGCTemplatesCmdBuilder;

struct GetUGCTemplatesRes;
struct GetUGCTemplatesResBuilder;

struct SaveUGCCmd;
struct SaveUGCCmdBuilder;

struct SaveUGCRes;
struct SaveUGCResBuilder;

struct SearchUGCCmd;
struct SearchUGCCmdBuilder;

struct SearchUGCRes;
struct SearchUGCResBuilder;

struct GetUGCContentInfoCmd;
struct GetUGCContentInfoCmdBuilder;

struct GetUGCContentInfoRes;
struct GetUGCContentInfoResBuilder;

struct DownloadUGCContentCmd;
struct DownloadUGCContentCmdBuilder;

struct DownloadUGCContentRes;
struct DownloadUGCContentResBuilder;

struct RequestUGCZoneInstanceCmd;
struct RequestUGCZoneInstanceCmdBuilder;

struct RequestUGCZoneInstanceRes;
struct RequestUGCZoneInstanceResBuilder;

struct BuyShopItemPrepareCmd;
struct BuyShopItemPrepareCmdBuilder;

struct BuyShopItemPrepareRes;
struct BuyShopItemPrepareResBuilder;

struct BuyShopItemCmd;
struct BuyShopItemCmdBuilder;

struct BuyShopItemRes;
struct BuyShopItemResBuilder;

struct CreateOrJoinChatChannelCmd;
struct CreateOrJoinChatChannelCmdBuilder;

struct CreateOrJoinChatChannelRes;
struct CreateOrJoinChatChannelResBuilder;

struct JoinChatChannelCmd;
struct JoinChatChannelCmdBuilder;

struct JoinChatChannelRes;
struct JoinChatChannelResBuilder;

struct ChatChannelPlayerJoinedS2CEvt;
struct ChatChannelPlayerJoinedS2CEvtBuilder;

struct ChatChannelLeaderChangedS2CEvt;
struct ChatChannelLeaderChangedS2CEvtBuilder;

struct LeaveChatChannelCmd;
struct LeaveChatChannelCmdBuilder;

struct LeaveChatChannelRes;
struct LeaveChatChannelResBuilder;

struct ChatChannelPlayerLeftS2CEvt;
struct ChatChannelPlayerLeftS2CEvtBuilder;

struct ChatChannelKickPlayerCmd;
struct ChatChannelKickPlayerCmdBuilder;

struct ChatChannelKickPlayerRes;
struct ChatChannelKickPlayerResBuilder;

struct ChatChannelPlayerKickedS2CEvt;
struct ChatChannelPlayerKickedS2CEvtBuilder;

struct ChatChannelChatMessageCmd;
struct ChatChannelChatMessageCmdBuilder;

struct ChatChannelChatMessageRes;
struct ChatChannelChatMessageResBuilder;

struct ChatChannelChatMessageS2CEvt;
struct ChatChannelChatMessageS2CEvtBuilder;

struct WhisperMessageCmd;
struct WhisperMessageCmdBuilder;

struct WhisperMessageRes;
struct WhisperMessageResBuilder;

struct WhisperMessageS2CEvt;
struct WhisperMessageS2CEvtBuilder;

struct CreateCharacterCmd;
struct CreateCharacterCmdBuilder;

struct CreateCharacterRes;
struct CreateCharacterResBuilder;

struct DeleteCharacterCmd;
struct DeleteCharacterCmdBuilder;

struct DeleteCharacterRes;
struct DeleteCharacterResBuilder;

struct GetCharacterListCmd;
struct GetCharacterListCmdBuilder;

struct GetCharacterListRes;
struct GetCharacterListResBuilder;

struct GetCharacterDataCmd;
struct GetCharacterDataCmdBuilder;

struct GetCharacterDataRes;
struct GetCharacterDataResBuilder;

struct SelectCharacterCmd;
struct SelectCharacterCmdBuilder;

struct SelectCharacterRes;
struct SelectCharacterResBuilder;

struct RequestServerNoticeUpdateCmd;
struct RequestServerNoticeUpdateCmdBuilder;

struct RequestServerNoticeUpdateRes;
struct RequestServerNoticeUpdateResBuilder;

struct ServerNoticeS2CEvt;
struct ServerNoticeS2CEvtBuilder;

struct CallFunctionCmd;
struct CallFunctionCmdBuilder;

struct CallFunctionRes;
struct CallFunctionResBuilder;

struct HeartbeatC2SEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeartbeatC2SEvtBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatC2SEvtBuilder {
  typedef HeartbeatC2SEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HeartbeatC2SEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeartbeatC2SEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeartbeatC2SEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HeartbeatC2SEvt> CreateHeartbeatC2SEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatC2SEvtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HeartbeatC2SEvt::Traits {
  using type = HeartbeatC2SEvt;
  static auto constexpr Create = CreateHeartbeatC2SEvt;
  static constexpr auto name = "HeartbeatC2SEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.HeartbeatC2SEvt";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct JoinGameServerCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinGameServerCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACC_ID = 4,
    VT_TICKET = 6,
    VT_LOGIN_ENTITY_UID = 8
  };
  uint64_t acc_id() const {
    return GetField<uint64_t>(VT_ACC_ID, 0);
  }
  uint64_t ticket() const {
    return GetField<uint64_t>(VT_TICKET, 0);
  }
  uint64_t login_entity_uid() const {
    return GetField<uint64_t>(VT_LOGIN_ENTITY_UID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return acc_id();
    else if constexpr (Index == 1) return ticket();
    else if constexpr (Index == 2) return login_entity_uid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ACC_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_TICKET, 8) &&
           VerifyField<uint64_t>(verifier, VT_LOGIN_ENTITY_UID, 8) &&
           verifier.EndTable();
  }
};

struct JoinGameServerCmdBuilder {
  typedef JoinGameServerCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_acc_id(uint64_t acc_id) {
    fbb_.AddElement<uint64_t>(JoinGameServerCmd::VT_ACC_ID, acc_id, 0);
  }
  void add_ticket(uint64_t ticket) {
    fbb_.AddElement<uint64_t>(JoinGameServerCmd::VT_TICKET, ticket, 0);
  }
  void add_login_entity_uid(uint64_t login_entity_uid) {
    fbb_.AddElement<uint64_t>(JoinGameServerCmd::VT_LOGIN_ENTITY_UID, login_entity_uid, 0);
  }
  explicit JoinGameServerCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinGameServerCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinGameServerCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinGameServerCmd> CreateJoinGameServerCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t acc_id = 0,
    uint64_t ticket = 0,
    uint64_t login_entity_uid = 0) {
  JoinGameServerCmdBuilder builder_(_fbb);
  builder_.add_login_entity_uid(login_entity_uid);
  builder_.add_ticket(ticket);
  builder_.add_acc_id(acc_id);
  return builder_.Finish();
}

struct JoinGameServerCmd::Traits {
  using type = JoinGameServerCmd;
  static auto constexpr Create = CreateJoinGameServerCmd;
  static constexpr auto name = "JoinGameServerCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinGameServerCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "acc_id",
    "ticket",
    "login_entity_uid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct JoinGameServerRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinGameServerResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_NICK_NAME = 6,
    VT_GAME_UID = 8,
    VT_PARTY_UID = 10,
    VT_PARTY_LEADER_ID = 12,
    VT_MATCHING_TICKET = 14
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::String *nick_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICK_NAME);
  }
  uint64_t game_uid() const {
    return GetField<uint64_t>(VT_GAME_UID, 0);
  }
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t party_leader_id() const {
    return GetField<uint64_t>(VT_PARTY_LEADER_ID, 0);
  }
  const SF::Flat::MatchingQueueTicket *matching_ticket() const {
    return GetStruct<const SF::Flat::MatchingQueueTicket *>(VT_MATCHING_TICKET);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return nick_name();
    else if constexpr (Index == 2) return game_uid();
    else if constexpr (Index == 3) return party_uid();
    else if constexpr (Index == 4) return party_leader_id();
    else if constexpr (Index == 5) return matching_ticket();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffsetRequired(verifier, VT_NICK_NAME) &&
           verifier.VerifyString(nick_name()) &&
           VerifyField<uint64_t>(verifier, VT_GAME_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_LEADER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::MatchingQueueTicket>(verifier, VT_MATCHING_TICKET, 8) &&
           verifier.EndTable();
  }
};

struct JoinGameServerResBuilder {
  typedef JoinGameServerRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(JoinGameServerRes::VT_RESULT, result, 0);
  }
  void add_nick_name(::flatbuffers::Offset<::flatbuffers::String> nick_name) {
    fbb_.AddOffset(JoinGameServerRes::VT_NICK_NAME, nick_name);
  }
  void add_game_uid(uint64_t game_uid) {
    fbb_.AddElement<uint64_t>(JoinGameServerRes::VT_GAME_UID, game_uid, 0);
  }
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(JoinGameServerRes::VT_PARTY_UID, party_uid, 0);
  }
  void add_party_leader_id(uint64_t party_leader_id) {
    fbb_.AddElement<uint64_t>(JoinGameServerRes::VT_PARTY_LEADER_ID, party_leader_id, 0);
  }
  void add_matching_ticket(const SF::Flat::MatchingQueueTicket *matching_ticket) {
    fbb_.AddStruct(JoinGameServerRes::VT_MATCHING_TICKET, matching_ticket);
  }
  explicit JoinGameServerResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinGameServerRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinGameServerRes>(end);
    fbb_.Required(o, JoinGameServerRes::VT_NICK_NAME);
    fbb_.Required(o, JoinGameServerRes::VT_MATCHING_TICKET);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinGameServerRes> CreateJoinGameServerRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nick_name = 0,
    uint64_t game_uid = 0,
    uint64_t party_uid = 0,
    uint64_t party_leader_id = 0,
    const SF::Flat::MatchingQueueTicket *matching_ticket = nullptr) {
  JoinGameServerResBuilder builder_(_fbb);
  builder_.add_party_leader_id(party_leader_id);
  builder_.add_party_uid(party_uid);
  builder_.add_game_uid(game_uid);
  builder_.add_matching_ticket(matching_ticket);
  builder_.add_nick_name(nick_name);
  builder_.add_result(result);
  return builder_.Finish();
}

struct JoinGameServerRes::Traits {
  using type = JoinGameServerRes;
  static auto constexpr Create = CreateJoinGameServerRes;
  static constexpr auto name = "JoinGameServerRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinGameServerRes";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "nick_name",
    "game_uid",
    "party_uid",
    "party_leader_id",
    "matching_ticket"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<JoinGameServerRes> CreateJoinGameServerResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const char *nick_name = nullptr,
    uint64_t game_uid = 0,
    uint64_t party_uid = 0,
    uint64_t party_leader_id = 0,
    const SF::Flat::MatchingQueueTicket *matching_ticket = nullptr) {
  auto nick_name__ = nick_name ? _fbb.CreateString(nick_name) : 0;
  return SF::Flat::Game::CreateJoinGameServerRes(
      _fbb,
      result,
      nick_name__,
      game_uid,
      party_uid,
      party_leader_id,
      matching_ticket);
}

struct GetAchievementStatsCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAchievementStatsCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4,
    VT_ACHIEVEMENT_STAT_IDFROM = 6,
    VT_ACHIEVEMENT_STAT_IDTO = 8
  };
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  uint32_t achievement_stat_idfrom() const {
    return GetField<uint32_t>(VT_ACHIEVEMENT_STAT_IDFROM, 0);
  }
  uint32_t achievement_stat_idto() const {
    return GetField<uint32_t>(VT_ACHIEVEMENT_STAT_IDTO, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return character_id();
    else if constexpr (Index == 1) return achievement_stat_idfrom();
    else if constexpr (Index == 2) return achievement_stat_idto();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACHIEVEMENT_STAT_IDFROM, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACHIEVEMENT_STAT_IDTO, 4) &&
           verifier.EndTable();
  }
};

struct GetAchievementStatsCmdBuilder {
  typedef GetAchievementStatsCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(GetAchievementStatsCmd::VT_CHARACTER_ID, character_id, 0);
  }
  void add_achievement_stat_idfrom(uint32_t achievement_stat_idfrom) {
    fbb_.AddElement<uint32_t>(GetAchievementStatsCmd::VT_ACHIEVEMENT_STAT_IDFROM, achievement_stat_idfrom, 0);
  }
  void add_achievement_stat_idto(uint32_t achievement_stat_idto) {
    fbb_.AddElement<uint32_t>(GetAchievementStatsCmd::VT_ACHIEVEMENT_STAT_IDTO, achievement_stat_idto, 0);
  }
  explicit GetAchievementStatsCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAchievementStatsCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAchievementStatsCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAchievementStatsCmd> CreateGetAchievementStatsCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t character_id = 0,
    uint32_t achievement_stat_idfrom = 0,
    uint32_t achievement_stat_idto = 0) {
  GetAchievementStatsCmdBuilder builder_(_fbb);
  builder_.add_achievement_stat_idto(achievement_stat_idto);
  builder_.add_achievement_stat_idfrom(achievement_stat_idfrom);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct GetAchievementStatsCmd::Traits {
  using type = GetAchievementStatsCmd;
  static auto constexpr Create = CreateGetAchievementStatsCmd;
  static constexpr auto name = "GetAchievementStatsCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetAchievementStatsCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "character_id",
    "achievement_stat_idfrom",
    "achievement_stat_idto"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetAchievementStatsRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAchievementStatsResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_ACHIEVEMENT_STATS = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::AchievementStat>> *achievement_stats() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::AchievementStat>> *>(VT_ACHIEVEMENT_STATS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return achievement_stats();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffsetRequired(verifier, VT_ACHIEVEMENT_STATS) &&
           verifier.VerifyVector(achievement_stats()) &&
           verifier.VerifyVectorOfTables(achievement_stats()) &&
           verifier.EndTable();
  }
};

struct GetAchievementStatsResBuilder {
  typedef GetAchievementStatsRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetAchievementStatsRes::VT_RESULT, result, 0);
  }
  void add_achievement_stats(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::AchievementStat>>> achievement_stats) {
    fbb_.AddOffset(GetAchievementStatsRes::VT_ACHIEVEMENT_STATS, achievement_stats);
  }
  explicit GetAchievementStatsResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAchievementStatsRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAchievementStatsRes>(end);
    fbb_.Required(o, GetAchievementStatsRes::VT_ACHIEVEMENT_STATS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAchievementStatsRes> CreateGetAchievementStatsRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::AchievementStat>>> achievement_stats = 0) {
  GetAchievementStatsResBuilder builder_(_fbb);
  builder_.add_achievement_stats(achievement_stats);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetAchievementStatsRes::Traits {
  using type = GetAchievementStatsRes;
  static auto constexpr Create = CreateGetAchievementStatsRes;
  static constexpr auto name = "GetAchievementStatsRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetAchievementStatsRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "achievement_stats"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetAchievementStatsRes> CreateGetAchievementStatsResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<::flatbuffers::Offset<SF::Flat::AchievementStat>> *achievement_stats = nullptr) {
  auto achievement_stats__ = achievement_stats ? _fbb.CreateVector<::flatbuffers::Offset<SF::Flat::AchievementStat>>(*achievement_stats) : 0;
  return SF::Flat::Game::CreateGetAchievementStatsRes(
      _fbb,
      result,
      achievement_stats__);
}

struct Dummy1Cmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Dummy1CmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPLITION_STATE = 4
  };
  const ::flatbuffers::String *complition_state() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMPLITION_STATE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return complition_state();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMPLITION_STATE) &&
           verifier.VerifyString(complition_state()) &&
           verifier.EndTable();
  }
};

struct Dummy1CmdBuilder {
  typedef Dummy1Cmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_complition_state(::flatbuffers::Offset<::flatbuffers::String> complition_state) {
    fbb_.AddOffset(Dummy1Cmd::VT_COMPLITION_STATE, complition_state);
  }
  explicit Dummy1CmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dummy1Cmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dummy1Cmd>(end);
    fbb_.Required(o, Dummy1Cmd::VT_COMPLITION_STATE);
    return o;
  }
};

inline ::flatbuffers::Offset<Dummy1Cmd> CreateDummy1Cmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> complition_state = 0) {
  Dummy1CmdBuilder builder_(_fbb);
  builder_.add_complition_state(complition_state);
  return builder_.Finish();
}

struct Dummy1Cmd::Traits {
  using type = Dummy1Cmd;
  static auto constexpr Create = CreateDummy1Cmd;
  static constexpr auto name = "Dummy1Cmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.Dummy1Cmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "complition_state"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Dummy1Cmd> CreateDummy1CmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *complition_state = nullptr) {
  auto complition_state__ = complition_state ? _fbb.CreateString(complition_state) : 0;
  return SF::Flat::Game::CreateDummy1Cmd(
      _fbb,
      complition_state__);
}

struct Dummy1Res FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Dummy1ResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct Dummy1ResBuilder {
  typedef Dummy1Res Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(Dummy1Res::VT_RESULT, result, 0);
  }
  explicit Dummy1ResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dummy1Res> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dummy1Res>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Dummy1Res> CreateDummy1Res(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  Dummy1ResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct Dummy1Res::Traits {
  using type = Dummy1Res;
  static auto constexpr Create = CreateDummy1Res;
  static constexpr auto name = "Dummy1Res";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.Dummy1Res";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RegisterGCMCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegisterGCMCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GCMREGISTERED_ID = 4
  };
  const ::flatbuffers::String *gcmregistered_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GCMREGISTERED_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return gcmregistered_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GCMREGISTERED_ID) &&
           verifier.VerifyString(gcmregistered_id()) &&
           verifier.EndTable();
  }
};

struct RegisterGCMCmdBuilder {
  typedef RegisterGCMCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gcmregistered_id(::flatbuffers::Offset<::flatbuffers::String> gcmregistered_id) {
    fbb_.AddOffset(RegisterGCMCmd::VT_GCMREGISTERED_ID, gcmregistered_id);
  }
  explicit RegisterGCMCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegisterGCMCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegisterGCMCmd>(end);
    fbb_.Required(o, RegisterGCMCmd::VT_GCMREGISTERED_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<RegisterGCMCmd> CreateRegisterGCMCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> gcmregistered_id = 0) {
  RegisterGCMCmdBuilder builder_(_fbb);
  builder_.add_gcmregistered_id(gcmregistered_id);
  return builder_.Finish();
}

struct RegisterGCMCmd::Traits {
  using type = RegisterGCMCmd;
  static auto constexpr Create = CreateRegisterGCMCmd;
  static constexpr auto name = "RegisterGCMCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RegisterGCMCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "gcmregistered_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RegisterGCMCmd> CreateRegisterGCMCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *gcmregistered_id = nullptr) {
  auto gcmregistered_id__ = gcmregistered_id ? _fbb.CreateString(gcmregistered_id) : 0;
  return SF::Flat::Game::CreateRegisterGCMCmd(
      _fbb,
      gcmregistered_id__);
}

struct RegisterGCMRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegisterGCMResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct RegisterGCMResBuilder {
  typedef RegisterGCMRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RegisterGCMRes::VT_RESULT, result, 0);
  }
  explicit RegisterGCMResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegisterGCMRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegisterGCMRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegisterGCMRes> CreateRegisterGCMRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  RegisterGCMResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RegisterGCMRes::Traits {
  using type = RegisterGCMRes;
  static auto constexpr Create = CreateRegisterGCMRes;
  static constexpr auto name = "RegisterGCMRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RegisterGCMRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct UnregisterGCMCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnregisterGCMCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GCMREGISTERED_ID = 4
  };
  const ::flatbuffers::String *gcmregistered_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GCMREGISTERED_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return gcmregistered_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GCMREGISTERED_ID) &&
           verifier.VerifyString(gcmregistered_id()) &&
           verifier.EndTable();
  }
};

struct UnregisterGCMCmdBuilder {
  typedef UnregisterGCMCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gcmregistered_id(::flatbuffers::Offset<::flatbuffers::String> gcmregistered_id) {
    fbb_.AddOffset(UnregisterGCMCmd::VT_GCMREGISTERED_ID, gcmregistered_id);
  }
  explicit UnregisterGCMCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnregisterGCMCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnregisterGCMCmd>(end);
    fbb_.Required(o, UnregisterGCMCmd::VT_GCMREGISTERED_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UnregisterGCMCmd> CreateUnregisterGCMCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> gcmregistered_id = 0) {
  UnregisterGCMCmdBuilder builder_(_fbb);
  builder_.add_gcmregistered_id(gcmregistered_id);
  return builder_.Finish();
}

struct UnregisterGCMCmd::Traits {
  using type = UnregisterGCMCmd;
  static auto constexpr Create = CreateUnregisterGCMCmd;
  static constexpr auto name = "UnregisterGCMCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.UnregisterGCMCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "gcmregistered_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<UnregisterGCMCmd> CreateUnregisterGCMCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *gcmregistered_id = nullptr) {
  auto gcmregistered_id__ = gcmregistered_id ? _fbb.CreateString(gcmregistered_id) : 0;
  return SF::Flat::Game::CreateUnregisterGCMCmd(
      _fbb,
      gcmregistered_id__);
}

struct UnregisterGCMRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnregisterGCMResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct UnregisterGCMResBuilder {
  typedef UnregisterGCMRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(UnregisterGCMRes::VT_RESULT, result, 0);
  }
  explicit UnregisterGCMResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnregisterGCMRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnregisterGCMRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnregisterGCMRes> CreateUnregisterGCMRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  UnregisterGCMResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct UnregisterGCMRes::Traits {
  using type = UnregisterGCMRes;
  static auto constexpr Create = CreateUnregisterGCMRes;
  static constexpr auto name = "UnregisterGCMRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.UnregisterGCMRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct InviteFriendCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InviteFriendCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRIEND_ID = 4
  };
  uint64_t friend_id() const {
    return GetField<uint64_t>(VT_FRIEND_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return friend_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FRIEND_ID, 8) &&
           verifier.EndTable();
  }
};

struct InviteFriendCmdBuilder {
  typedef InviteFriendCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_friend_id(uint64_t friend_id) {
    fbb_.AddElement<uint64_t>(InviteFriendCmd::VT_FRIEND_ID, friend_id, 0);
  }
  explicit InviteFriendCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InviteFriendCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InviteFriendCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InviteFriendCmd> CreateInviteFriendCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t friend_id = 0) {
  InviteFriendCmdBuilder builder_(_fbb);
  builder_.add_friend_id(friend_id);
  return builder_.Finish();
}

struct InviteFriendCmd::Traits {
  using type = InviteFriendCmd;
  static auto constexpr Create = CreateInviteFriendCmd;
  static constexpr auto name = "InviteFriendCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.InviteFriendCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "friend_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct InviteFriendRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InviteFriendResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct InviteFriendResBuilder {
  typedef InviteFriendRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(InviteFriendRes::VT_RESULT, result, 0);
  }
  explicit InviteFriendResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InviteFriendRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InviteFriendRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InviteFriendRes> CreateInviteFriendRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  InviteFriendResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct InviteFriendRes::Traits {
  using type = InviteFriendRes;
  static auto constexpr Create = CreateInviteFriendRes;
  static constexpr auto name = "InviteFriendRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.InviteFriendRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AcceptFriendRequestCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AcceptFriendRequestCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVITER_ID = 4,
    VT_INVITER_PLATFORM_ID = 6
  };
  uint64_t inviter_id() const {
    return GetField<uint64_t>(VT_INVITER_ID, 0);
  }
  const SF::Flat::PlayerPlatformID *inviter_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_INVITER_PLATFORM_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return inviter_id();
    else if constexpr (Index == 1) return inviter_platform_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INVITER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_INVITER_PLATFORM_ID, 8) &&
           verifier.EndTable();
  }
};

struct AcceptFriendRequestCmdBuilder {
  typedef AcceptFriendRequestCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inviter_id(uint64_t inviter_id) {
    fbb_.AddElement<uint64_t>(AcceptFriendRequestCmd::VT_INVITER_ID, inviter_id, 0);
  }
  void add_inviter_platform_id(const SF::Flat::PlayerPlatformID *inviter_platform_id) {
    fbb_.AddStruct(AcceptFriendRequestCmd::VT_INVITER_PLATFORM_ID, inviter_platform_id);
  }
  explicit AcceptFriendRequestCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AcceptFriendRequestCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AcceptFriendRequestCmd>(end);
    fbb_.Required(o, AcceptFriendRequestCmd::VT_INVITER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<AcceptFriendRequestCmd> CreateAcceptFriendRequestCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t inviter_id = 0,
    const SF::Flat::PlayerPlatformID *inviter_platform_id = nullptr) {
  AcceptFriendRequestCmdBuilder builder_(_fbb);
  builder_.add_inviter_id(inviter_id);
  builder_.add_inviter_platform_id(inviter_platform_id);
  return builder_.Finish();
}

struct AcceptFriendRequestCmd::Traits {
  using type = AcceptFriendRequestCmd;
  static auto constexpr Create = CreateAcceptFriendRequestCmd;
  static constexpr auto name = "AcceptFriendRequestCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.AcceptFriendRequestCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "inviter_id",
    "inviter_platform_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AcceptFriendRequestRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AcceptFriendRequestResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_NEW_FRIEND = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const SF::Flat::PlayerInformation *new_friend() const {
    return GetPointer<const SF::Flat::PlayerInformation *>(VT_NEW_FRIEND);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return new_friend();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffsetRequired(verifier, VT_NEW_FRIEND) &&
           verifier.VerifyTable(new_friend()) &&
           verifier.EndTable();
  }
};

struct AcceptFriendRequestResBuilder {
  typedef AcceptFriendRequestRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(AcceptFriendRequestRes::VT_RESULT, result, 0);
  }
  void add_new_friend(::flatbuffers::Offset<SF::Flat::PlayerInformation> new_friend) {
    fbb_.AddOffset(AcceptFriendRequestRes::VT_NEW_FRIEND, new_friend);
  }
  explicit AcceptFriendRequestResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AcceptFriendRequestRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AcceptFriendRequestRes>(end);
    fbb_.Required(o, AcceptFriendRequestRes::VT_NEW_FRIEND);
    return o;
  }
};

inline ::flatbuffers::Offset<AcceptFriendRequestRes> CreateAcceptFriendRequestRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<SF::Flat::PlayerInformation> new_friend = 0) {
  AcceptFriendRequestResBuilder builder_(_fbb);
  builder_.add_new_friend(new_friend);
  builder_.add_result(result);
  return builder_.Finish();
}

struct AcceptFriendRequestRes::Traits {
  using type = AcceptFriendRequestRes;
  static auto constexpr Create = CreateAcceptFriendRequestRes;
  static constexpr auto name = "AcceptFriendRequestRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.AcceptFriendRequestRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "new_friend"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FriendRequestAcceptedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FriendRequestAcceptedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCEPTER = 4
  };
  const SF::Flat::PlayerInformation *accepter() const {
    return GetPointer<const SF::Flat::PlayerInformation *>(VT_ACCEPTER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return accepter();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACCEPTER) &&
           verifier.VerifyTable(accepter()) &&
           verifier.EndTable();
  }
};

struct FriendRequestAcceptedS2CEvtBuilder {
  typedef FriendRequestAcceptedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accepter(::flatbuffers::Offset<SF::Flat::PlayerInformation> accepter) {
    fbb_.AddOffset(FriendRequestAcceptedS2CEvt::VT_ACCEPTER, accepter);
  }
  explicit FriendRequestAcceptedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FriendRequestAcceptedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FriendRequestAcceptedS2CEvt>(end);
    fbb_.Required(o, FriendRequestAcceptedS2CEvt::VT_ACCEPTER);
    return o;
  }
};

inline ::flatbuffers::Offset<FriendRequestAcceptedS2CEvt> CreateFriendRequestAcceptedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SF::Flat::PlayerInformation> accepter = 0) {
  FriendRequestAcceptedS2CEvtBuilder builder_(_fbb);
  builder_.add_accepter(accepter);
  return builder_.Finish();
}

struct FriendRequestAcceptedS2CEvt::Traits {
  using type = FriendRequestAcceptedS2CEvt;
  static auto constexpr Create = CreateFriendRequestAcceptedS2CEvt;
  static constexpr auto name = "FriendRequestAcceptedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FriendRequestAcceptedS2CEvt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "accepter"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RemoveFriendCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveFriendCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRIEND_ID = 4
  };
  uint64_t friend_id() const {
    return GetField<uint64_t>(VT_FRIEND_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return friend_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FRIEND_ID, 8) &&
           verifier.EndTable();
  }
};

struct RemoveFriendCmdBuilder {
  typedef RemoveFriendCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_friend_id(uint64_t friend_id) {
    fbb_.AddElement<uint64_t>(RemoveFriendCmd::VT_FRIEND_ID, friend_id, 0);
  }
  explicit RemoveFriendCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveFriendCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveFriendCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveFriendCmd> CreateRemoveFriendCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t friend_id = 0) {
  RemoveFriendCmdBuilder builder_(_fbb);
  builder_.add_friend_id(friend_id);
  return builder_.Finish();
}

struct RemoveFriendCmd::Traits {
  using type = RemoveFriendCmd;
  static auto constexpr Create = CreateRemoveFriendCmd;
  static constexpr auto name = "RemoveFriendCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RemoveFriendCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "friend_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RemoveFriendRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveFriendResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_FRIEND_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t friend_id() const {
    return GetField<uint64_t>(VT_FRIEND_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return friend_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_FRIEND_ID, 8) &&
           verifier.EndTable();
  }
};

struct RemoveFriendResBuilder {
  typedef RemoveFriendRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RemoveFriendRes::VT_RESULT, result, 0);
  }
  void add_friend_id(uint64_t friend_id) {
    fbb_.AddElement<uint64_t>(RemoveFriendRes::VT_FRIEND_ID, friend_id, 0);
  }
  explicit RemoveFriendResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveFriendRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveFriendRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveFriendRes> CreateRemoveFriendRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t friend_id = 0) {
  RemoveFriendResBuilder builder_(_fbb);
  builder_.add_friend_id(friend_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RemoveFriendRes::Traits {
  using type = RemoveFriendRes;
  static auto constexpr Create = CreateRemoveFriendRes;
  static constexpr auto name = "RemoveFriendRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RemoveFriendRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "friend_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FriendRemovedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FriendRemovedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRIEND_ID = 4
  };
  uint64_t friend_id() const {
    return GetField<uint64_t>(VT_FRIEND_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return friend_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FRIEND_ID, 8) &&
           verifier.EndTable();
  }
};

struct FriendRemovedS2CEvtBuilder {
  typedef FriendRemovedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_friend_id(uint64_t friend_id) {
    fbb_.AddElement<uint64_t>(FriendRemovedS2CEvt::VT_FRIEND_ID, friend_id, 0);
  }
  explicit FriendRemovedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FriendRemovedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FriendRemovedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FriendRemovedS2CEvt> CreateFriendRemovedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t friend_id = 0) {
  FriendRemovedS2CEvtBuilder builder_(_fbb);
  builder_.add_friend_id(friend_id);
  return builder_.Finish();
}

struct FriendRemovedS2CEvt::Traits {
  using type = FriendRemovedS2CEvt;
  static auto constexpr Create = CreateFriendRemovedS2CEvt;
  static constexpr auto name = "FriendRemovedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FriendRemovedS2CEvt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "friend_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetFriendListCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetFriendListCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_INDEX = 4,
    VT_COUNT = 6
  };
  uint16_t start_index() const {
    return GetField<uint16_t>(VT_START_INDEX, 0);
  }
  uint16_t count() const {
    return GetField<uint16_t>(VT_COUNT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return start_index();
    else if constexpr (Index == 1) return count();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_START_INDEX, 2) &&
           VerifyField<uint16_t>(verifier, VT_COUNT, 2) &&
           verifier.EndTable();
  }
};

struct GetFriendListCmdBuilder {
  typedef GetFriendListCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_index(uint16_t start_index) {
    fbb_.AddElement<uint16_t>(GetFriendListCmd::VT_START_INDEX, start_index, 0);
  }
  void add_count(uint16_t count) {
    fbb_.AddElement<uint16_t>(GetFriendListCmd::VT_COUNT, count, 0);
  }
  explicit GetFriendListCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetFriendListCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetFriendListCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetFriendListCmd> CreateGetFriendListCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t start_index = 0,
    uint16_t count = 0) {
  GetFriendListCmdBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_start_index(start_index);
  return builder_.Finish();
}

struct GetFriendListCmd::Traits {
  using type = GetFriendListCmd;
  static auto constexpr Create = CreateGetFriendListCmd;
  static constexpr auto name = "GetFriendListCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetFriendListCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "start_index",
    "count"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetFriendListRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetFriendListResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_MAX_FRIEND_SLOT = 6,
    VT_TOTAL_NUMBER_OF_FRIENDS = 8,
    VT_START_INDEX = 10,
    VT_FRIEND_LIST = 12
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint16_t max_friend_slot() const {
    return GetField<uint16_t>(VT_MAX_FRIEND_SLOT, 0);
  }
  uint16_t total_number_of_friends() const {
    return GetField<uint16_t>(VT_TOTAL_NUMBER_OF_FRIENDS, 0);
  }
  uint16_t start_index() const {
    return GetField<uint16_t>(VT_START_INDEX, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::PlayerInformation>> *friend_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::PlayerInformation>> *>(VT_FRIEND_LIST);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return max_friend_slot();
    else if constexpr (Index == 2) return total_number_of_friends();
    else if constexpr (Index == 3) return start_index();
    else if constexpr (Index == 4) return friend_list();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint16_t>(verifier, VT_MAX_FRIEND_SLOT, 2) &&
           VerifyField<uint16_t>(verifier, VT_TOTAL_NUMBER_OF_FRIENDS, 2) &&
           VerifyField<uint16_t>(verifier, VT_START_INDEX, 2) &&
           VerifyOffsetRequired(verifier, VT_FRIEND_LIST) &&
           verifier.VerifyVector(friend_list()) &&
           verifier.VerifyVectorOfTables(friend_list()) &&
           verifier.EndTable();
  }
};

struct GetFriendListResBuilder {
  typedef GetFriendListRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetFriendListRes::VT_RESULT, result, 0);
  }
  void add_max_friend_slot(uint16_t max_friend_slot) {
    fbb_.AddElement<uint16_t>(GetFriendListRes::VT_MAX_FRIEND_SLOT, max_friend_slot, 0);
  }
  void add_total_number_of_friends(uint16_t total_number_of_friends) {
    fbb_.AddElement<uint16_t>(GetFriendListRes::VT_TOTAL_NUMBER_OF_FRIENDS, total_number_of_friends, 0);
  }
  void add_start_index(uint16_t start_index) {
    fbb_.AddElement<uint16_t>(GetFriendListRes::VT_START_INDEX, start_index, 0);
  }
  void add_friend_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::PlayerInformation>>> friend_list) {
    fbb_.AddOffset(GetFriendListRes::VT_FRIEND_LIST, friend_list);
  }
  explicit GetFriendListResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetFriendListRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetFriendListRes>(end);
    fbb_.Required(o, GetFriendListRes::VT_FRIEND_LIST);
    return o;
  }
};

inline ::flatbuffers::Offset<GetFriendListRes> CreateGetFriendListRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint16_t max_friend_slot = 0,
    uint16_t total_number_of_friends = 0,
    uint16_t start_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::PlayerInformation>>> friend_list = 0) {
  GetFriendListResBuilder builder_(_fbb);
  builder_.add_friend_list(friend_list);
  builder_.add_result(result);
  builder_.add_start_index(start_index);
  builder_.add_total_number_of_friends(total_number_of_friends);
  builder_.add_max_friend_slot(max_friend_slot);
  return builder_.Finish();
}

struct GetFriendListRes::Traits {
  using type = GetFriendListRes;
  static auto constexpr Create = CreateGetFriendListRes;
  static constexpr auto name = "GetFriendListRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetFriendListRes";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "max_friend_slot",
    "total_number_of_friends",
    "start_index",
    "friend_list"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetFriendListRes> CreateGetFriendListResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint16_t max_friend_slot = 0,
    uint16_t total_number_of_friends = 0,
    uint16_t start_index = 0,
    const std::vector<::flatbuffers::Offset<SF::Flat::PlayerInformation>> *friend_list = nullptr) {
  auto friend_list__ = friend_list ? _fbb.CreateVector<::flatbuffers::Offset<SF::Flat::PlayerInformation>>(*friend_list) : 0;
  return SF::Flat::Game::CreateGetFriendListRes(
      _fbb,
      result,
      max_friend_slot,
      total_number_of_friends,
      start_index,
      friend_list__);
}

struct GetNotificationListCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetNotificationListCmdBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetNotificationListCmdBuilder {
  typedef GetNotificationListCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetNotificationListCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetNotificationListCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetNotificationListCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetNotificationListCmd> CreateGetNotificationListCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetNotificationListCmdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetNotificationListCmd::Traits {
  using type = GetNotificationListCmd;
  static auto constexpr Create = CreateGetNotificationListCmd;
  static constexpr auto name = "GetNotificationListCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetNotificationListCmd";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct GetNotificationListRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetNotificationListResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct GetNotificationListResBuilder {
  typedef GetNotificationListRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetNotificationListRes::VT_RESULT, result, 0);
  }
  explicit GetNotificationListResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetNotificationListRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetNotificationListRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetNotificationListRes> CreateGetNotificationListRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  GetNotificationListResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetNotificationListRes::Traits {
  using type = GetNotificationListRes;
  static auto constexpr Create = CreateGetNotificationListRes;
  static constexpr auto name = "GetNotificationListRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetNotificationListRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct DeleteNotificationCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteNotificationCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4
  };
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return notification_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct DeleteNotificationCmdBuilder {
  typedef DeleteNotificationCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(DeleteNotificationCmd::VT_NOTIFICATION_ID, notification_id, 0);
  }
  explicit DeleteNotificationCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteNotificationCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteNotificationCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteNotificationCmd> CreateDeleteNotificationCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t notification_id = 0) {
  DeleteNotificationCmdBuilder builder_(_fbb);
  builder_.add_notification_id(notification_id);
  return builder_.Finish();
}

struct DeleteNotificationCmd::Traits {
  using type = DeleteNotificationCmd;
  static auto constexpr Create = CreateDeleteNotificationCmd;
  static constexpr auto name = "DeleteNotificationCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.DeleteNotificationCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "notification_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct DeleteNotificationRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteNotificationResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_NOTIFICATION_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return notification_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct DeleteNotificationResBuilder {
  typedef DeleteNotificationRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(DeleteNotificationRes::VT_RESULT, result, 0);
  }
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(DeleteNotificationRes::VT_NOTIFICATION_ID, notification_id, 0);
  }
  explicit DeleteNotificationResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteNotificationRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteNotificationRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteNotificationRes> CreateDeleteNotificationRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t notification_id = 0) {
  DeleteNotificationResBuilder builder_(_fbb);
  builder_.add_notification_id(notification_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct DeleteNotificationRes::Traits {
  using type = DeleteNotificationRes;
  static auto constexpr Create = CreateDeleteNotificationRes;
  static constexpr auto name = "DeleteNotificationRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.DeleteNotificationRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "notification_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SetNotificationReadCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetNotificationReadCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4
  };
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return notification_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct SetNotificationReadCmdBuilder {
  typedef SetNotificationReadCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(SetNotificationReadCmd::VT_NOTIFICATION_ID, notification_id, 0);
  }
  explicit SetNotificationReadCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetNotificationReadCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetNotificationReadCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetNotificationReadCmd> CreateSetNotificationReadCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t notification_id = 0) {
  SetNotificationReadCmdBuilder builder_(_fbb);
  builder_.add_notification_id(notification_id);
  return builder_.Finish();
}

struct SetNotificationReadCmd::Traits {
  using type = SetNotificationReadCmd;
  static auto constexpr Create = CreateSetNotificationReadCmd;
  static constexpr auto name = "SetNotificationReadCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SetNotificationReadCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "notification_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SetNotificationReadRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetNotificationReadResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_NOTIFICATION_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return notification_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct SetNotificationReadResBuilder {
  typedef SetNotificationReadRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SetNotificationReadRes::VT_RESULT, result, 0);
  }
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(SetNotificationReadRes::VT_NOTIFICATION_ID, notification_id, 0);
  }
  explicit SetNotificationReadResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetNotificationReadRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetNotificationReadRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetNotificationReadRes> CreateSetNotificationReadRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t notification_id = 0) {
  SetNotificationReadResBuilder builder_(_fbb);
  builder_.add_notification_id(notification_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SetNotificationReadRes::Traits {
  using type = SetNotificationReadRes;
  static auto constexpr Create = CreateSetNotificationReadRes;
  static constexpr auto name = "SetNotificationReadRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SetNotificationReadRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "notification_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AcceptNotificationCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AcceptNotificationCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4
  };
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return notification_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct AcceptNotificationCmdBuilder {
  typedef AcceptNotificationCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(AcceptNotificationCmd::VT_NOTIFICATION_ID, notification_id, 0);
  }
  explicit AcceptNotificationCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AcceptNotificationCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AcceptNotificationCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AcceptNotificationCmd> CreateAcceptNotificationCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t notification_id = 0) {
  AcceptNotificationCmdBuilder builder_(_fbb);
  builder_.add_notification_id(notification_id);
  return builder_.Finish();
}

struct AcceptNotificationCmd::Traits {
  using type = AcceptNotificationCmd;
  static auto constexpr Create = CreateAcceptNotificationCmd;
  static constexpr auto name = "AcceptNotificationCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.AcceptNotificationCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "notification_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AcceptNotificationRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AcceptNotificationResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_NOTIFICATION_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return notification_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct AcceptNotificationResBuilder {
  typedef AcceptNotificationRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(AcceptNotificationRes::VT_RESULT, result, 0);
  }
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(AcceptNotificationRes::VT_NOTIFICATION_ID, notification_id, 0);
  }
  explicit AcceptNotificationResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AcceptNotificationRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AcceptNotificationRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AcceptNotificationRes> CreateAcceptNotificationRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t notification_id = 0) {
  AcceptNotificationResBuilder builder_(_fbb);
  builder_.add_notification_id(notification_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct AcceptNotificationRes::Traits {
  using type = AcceptNotificationRes;
  static auto constexpr Create = CreateAcceptNotificationRes;
  static constexpr auto name = "AcceptNotificationRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.AcceptNotificationRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "notification_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NotifyS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4,
    VT_NOTIFICATION_TYPE = 6,
    VT_PARAMETERS = 8,
    VT_IS_READ = 10,
    VT_TIME_STAMP = 12
  };
  uint32_t notification_id() const {
    return GetField<uint32_t>(VT_NOTIFICATION_ID, 0);
  }
  uint32_t notification_type() const {
    return GetField<uint32_t>(VT_NOTIFICATION_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  uint8_t is_read() const {
    return GetField<uint8_t>(VT_IS_READ, 0);
  }
  uint64_t time_stamp() const {
    return GetField<uint64_t>(VT_TIME_STAMP, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return notification_id();
    else if constexpr (Index == 1) return notification_type();
    else if constexpr (Index == 2) return parameters();
    else if constexpr (Index == 3) return is_read();
    else if constexpr (Index == 4) return time_stamp();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_NOTIFICATION_TYPE, 4) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           VerifyField<uint8_t>(verifier, VT_IS_READ, 1) &&
           VerifyField<uint64_t>(verifier, VT_TIME_STAMP, 8) &&
           verifier.EndTable();
  }
};

struct NotifyS2CEvtBuilder {
  typedef NotifyS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(uint32_t notification_id) {
    fbb_.AddElement<uint32_t>(NotifyS2CEvt::VT_NOTIFICATION_ID, notification_id, 0);
  }
  void add_notification_type(uint32_t notification_type) {
    fbb_.AddElement<uint32_t>(NotifyS2CEvt::VT_NOTIFICATION_TYPE, notification_type, 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters) {
    fbb_.AddOffset(NotifyS2CEvt::VT_PARAMETERS, parameters);
  }
  void add_is_read(uint8_t is_read) {
    fbb_.AddElement<uint8_t>(NotifyS2CEvt::VT_IS_READ, is_read, 0);
  }
  void add_time_stamp(uint64_t time_stamp) {
    fbb_.AddElement<uint64_t>(NotifyS2CEvt::VT_TIME_STAMP, time_stamp, 0);
  }
  explicit NotifyS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyS2CEvt> CreateNotifyS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t notification_id = 0,
    uint32_t notification_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters = 0,
    uint8_t is_read = 0,
    uint64_t time_stamp = 0) {
  NotifyS2CEvtBuilder builder_(_fbb);
  builder_.add_time_stamp(time_stamp);
  builder_.add_parameters(parameters);
  builder_.add_notification_type(notification_type);
  builder_.add_notification_id(notification_id);
  builder_.add_is_read(is_read);
  return builder_.Finish();
}

struct NotifyS2CEvt::Traits {
  using type = NotifyS2CEvt;
  static auto constexpr Create = CreateNotifyS2CEvt;
  static constexpr auto name = "NotifyS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.NotifyS2CEvt";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "notification_id",
    "notification_type",
    "parameters",
    "is_read",
    "time_stamp"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NotifyS2CEvt> CreateNotifyS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t notification_id = 0,
    uint32_t notification_type = 0,
    const std::vector<uint8_t> *parameters = nullptr,
    uint8_t is_read = 0,
    uint64_t time_stamp = 0) {
  auto parameters__ = parameters ? _fbb.CreateVector<uint8_t>(*parameters) : 0;
  return SF::Flat::Game::CreateNotifyS2CEvt(
      _fbb,
      notification_id,
      notification_type,
      parameters__,
      is_read,
      time_stamp);
}

struct FindPlayerByPlatformIdCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByPlatformIdCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLATFORM_PLAYER_ID = 4
  };
  const SF::Flat::PlayerPlatformID *platform_player_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLATFORM_PLAYER_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return platform_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLATFORM_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct FindPlayerByPlatformIdCmdBuilder {
  typedef FindPlayerByPlatformIdCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_platform_player_id(const SF::Flat::PlayerPlatformID *platform_player_id) {
    fbb_.AddStruct(FindPlayerByPlatformIdCmd::VT_PLATFORM_PLAYER_ID, platform_player_id);
  }
  explicit FindPlayerByPlatformIdCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByPlatformIdCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByPlatformIdCmd>(end);
    fbb_.Required(o, FindPlayerByPlatformIdCmd::VT_PLATFORM_PLAYER_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByPlatformIdCmd> CreateFindPlayerByPlatformIdCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SF::Flat::PlayerPlatformID *platform_player_id = nullptr) {
  FindPlayerByPlatformIdCmdBuilder builder_(_fbb);
  builder_.add_platform_player_id(platform_player_id);
  return builder_.Finish();
}

struct FindPlayerByPlatformIdCmd::Traits {
  using type = FindPlayerByPlatformIdCmd;
  static auto constexpr Create = CreateFindPlayerByPlatformIdCmd;
  static constexpr auto name = "FindPlayerByPlatformIdCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByPlatformIdCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "platform_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FindPlayerByPlatformIdRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByPlatformIdResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER_ID = 6,
    VT_PLAYER_PLATFORM_ID = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return player_platform_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           verifier.EndTable();
  }
};

struct FindPlayerByPlatformIdResBuilder {
  typedef FindPlayerByPlatformIdRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(FindPlayerByPlatformIdRes::VT_RESULT, result, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(FindPlayerByPlatformIdRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(FindPlayerByPlatformIdRes::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  explicit FindPlayerByPlatformIdResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByPlatformIdRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByPlatformIdRes>(end);
    fbb_.Required(o, FindPlayerByPlatformIdRes::VT_PLAYER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByPlatformIdRes> CreateFindPlayerByPlatformIdRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr) {
  FindPlayerByPlatformIdResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_player_platform_id(player_platform_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct FindPlayerByPlatformIdRes::Traits {
  using type = FindPlayerByPlatformIdRes;
  static auto constexpr Create = CreateFindPlayerByPlatformIdRes;
  static constexpr auto name = "FindPlayerByPlatformIdRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByPlatformIdRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player_id",
    "player_platform_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FindPlayerByCharacterNameCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByCharacterNameCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_NAME = 4
  };
  const ::flatbuffers::String *character_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return character_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHARACTER_NAME) &&
           verifier.VerifyString(character_name()) &&
           verifier.EndTable();
  }
};

struct FindPlayerByCharacterNameCmdBuilder {
  typedef FindPlayerByCharacterNameCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_name(::flatbuffers::Offset<::flatbuffers::String> character_name) {
    fbb_.AddOffset(FindPlayerByCharacterNameCmd::VT_CHARACTER_NAME, character_name);
  }
  explicit FindPlayerByCharacterNameCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByCharacterNameCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByCharacterNameCmd>(end);
    fbb_.Required(o, FindPlayerByCharacterNameCmd::VT_CHARACTER_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByCharacterNameCmd> CreateFindPlayerByCharacterNameCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> character_name = 0) {
  FindPlayerByCharacterNameCmdBuilder builder_(_fbb);
  builder_.add_character_name(character_name);
  return builder_.Finish();
}

struct FindPlayerByCharacterNameCmd::Traits {
  using type = FindPlayerByCharacterNameCmd;
  static auto constexpr Create = CreateFindPlayerByCharacterNameCmd;
  static constexpr auto name = "FindPlayerByCharacterNameCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByCharacterNameCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "character_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<FindPlayerByCharacterNameCmd> CreateFindPlayerByCharacterNameCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *character_name = nullptr) {
  auto character_name__ = character_name ? _fbb.CreateString(character_name) : 0;
  return SF::Flat::Game::CreateFindPlayerByCharacterNameCmd(
      _fbb,
      character_name__);
}

struct FindPlayerByCharacterNameRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByCharacterNameResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct FindPlayerByCharacterNameResBuilder {
  typedef FindPlayerByCharacterNameRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(FindPlayerByCharacterNameRes::VT_RESULT, result, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(FindPlayerByCharacterNameRes::VT_PLAYER_ID, player_id, 0);
  }
  explicit FindPlayerByCharacterNameResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByCharacterNameRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByCharacterNameRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByCharacterNameRes> CreateFindPlayerByCharacterNameRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0) {
  FindPlayerByCharacterNameResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct FindPlayerByCharacterNameRes::Traits {
  using type = FindPlayerByCharacterNameRes;
  static auto constexpr Create = CreateFindPlayerByCharacterNameRes;
  static constexpr auto name = "FindPlayerByCharacterNameRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByCharacterNameRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FindPlayerByPlatformUserNameCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByPlatformUserNameCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLATFORM_TYPE = 4,
    VT_PLATFORM_USER_NAME = 6
  };
  uint8_t platform_type() const {
    return GetField<uint8_t>(VT_PLATFORM_TYPE, 0);
  }
  const ::flatbuffers::String *platform_user_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLATFORM_USER_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return platform_type();
    else if constexpr (Index == 1) return platform_user_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLATFORM_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_PLATFORM_USER_NAME) &&
           verifier.VerifyString(platform_user_name()) &&
           verifier.EndTable();
  }
};

struct FindPlayerByPlatformUserNameCmdBuilder {
  typedef FindPlayerByPlatformUserNameCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_platform_type(uint8_t platform_type) {
    fbb_.AddElement<uint8_t>(FindPlayerByPlatformUserNameCmd::VT_PLATFORM_TYPE, platform_type, 0);
  }
  void add_platform_user_name(::flatbuffers::Offset<::flatbuffers::String> platform_user_name) {
    fbb_.AddOffset(FindPlayerByPlatformUserNameCmd::VT_PLATFORM_USER_NAME, platform_user_name);
  }
  explicit FindPlayerByPlatformUserNameCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByPlatformUserNameCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByPlatformUserNameCmd>(end);
    fbb_.Required(o, FindPlayerByPlatformUserNameCmd::VT_PLATFORM_USER_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByPlatformUserNameCmd> CreateFindPlayerByPlatformUserNameCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t platform_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> platform_user_name = 0) {
  FindPlayerByPlatformUserNameCmdBuilder builder_(_fbb);
  builder_.add_platform_user_name(platform_user_name);
  builder_.add_platform_type(platform_type);
  return builder_.Finish();
}

struct FindPlayerByPlatformUserNameCmd::Traits {
  using type = FindPlayerByPlatformUserNameCmd;
  static auto constexpr Create = CreateFindPlayerByPlatformUserNameCmd;
  static constexpr auto name = "FindPlayerByPlatformUserNameCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByPlatformUserNameCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "platform_type",
    "platform_user_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<FindPlayerByPlatformUserNameCmd> CreateFindPlayerByPlatformUserNameCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t platform_type = 0,
    const char *platform_user_name = nullptr) {
  auto platform_user_name__ = platform_user_name ? _fbb.CreateString(platform_user_name) : 0;
  return SF::Flat::Game::CreateFindPlayerByPlatformUserNameCmd(
      _fbb,
      platform_type,
      platform_user_name__);
}

struct FindPlayerByPlatformUserNameRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByPlatformUserNameResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER_ID = 6,
    VT_PLAYER_PLATFORM_ID = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return player_platform_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyFieldRequired<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           verifier.EndTable();
  }
};

struct FindPlayerByPlatformUserNameResBuilder {
  typedef FindPlayerByPlatformUserNameRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(FindPlayerByPlatformUserNameRes::VT_RESULT, result, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(FindPlayerByPlatformUserNameRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(FindPlayerByPlatformUserNameRes::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  explicit FindPlayerByPlatformUserNameResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByPlatformUserNameRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByPlatformUserNameRes>(end);
    fbb_.Required(o, FindPlayerByPlatformUserNameRes::VT_PLAYER_PLATFORM_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByPlatformUserNameRes> CreateFindPlayerByPlatformUserNameRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr) {
  FindPlayerByPlatformUserNameResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_player_platform_id(player_platform_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct FindPlayerByPlatformUserNameRes::Traits {
  using type = FindPlayerByPlatformUserNameRes;
  static auto constexpr Create = CreateFindPlayerByPlatformUserNameRes;
  static constexpr auto name = "FindPlayerByPlatformUserNameRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByPlatformUserNameRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player_id",
    "player_platform_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FindPlayerByEMailCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByEMailCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_EMAIL = 4
  };
  const ::flatbuffers::String *player_email() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLAYER_EMAIL);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_email();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PLAYER_EMAIL) &&
           verifier.VerifyString(player_email()) &&
           verifier.EndTable();
  }
};

struct FindPlayerByEMailCmdBuilder {
  typedef FindPlayerByEMailCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_email(::flatbuffers::Offset<::flatbuffers::String> player_email) {
    fbb_.AddOffset(FindPlayerByEMailCmd::VT_PLAYER_EMAIL, player_email);
  }
  explicit FindPlayerByEMailCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByEMailCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByEMailCmd>(end);
    fbb_.Required(o, FindPlayerByEMailCmd::VT_PLAYER_EMAIL);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByEMailCmd> CreateFindPlayerByEMailCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> player_email = 0) {
  FindPlayerByEMailCmdBuilder builder_(_fbb);
  builder_.add_player_email(player_email);
  return builder_.Finish();
}

struct FindPlayerByEMailCmd::Traits {
  using type = FindPlayerByEMailCmd;
  static auto constexpr Create = CreateFindPlayerByEMailCmd;
  static constexpr auto name = "FindPlayerByEMailCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByEMailCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_email"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<FindPlayerByEMailCmd> CreateFindPlayerByEMailCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *player_email = nullptr) {
  auto player_email__ = player_email ? _fbb.CreateString(player_email) : 0;
  return SF::Flat::Game::CreateFindPlayerByEMailCmd(
      _fbb,
      player_email__);
}

struct FindPlayerByEMailRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByEMailResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const SF::Flat::PlayerInformation *player() const {
    return GetPointer<const SF::Flat::PlayerInformation *>(VT_PLAYER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffsetRequired(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
};

struct FindPlayerByEMailResBuilder {
  typedef FindPlayerByEMailRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(FindPlayerByEMailRes::VT_RESULT, result, 0);
  }
  void add_player(::flatbuffers::Offset<SF::Flat::PlayerInformation> player) {
    fbb_.AddOffset(FindPlayerByEMailRes::VT_PLAYER, player);
  }
  explicit FindPlayerByEMailResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByEMailRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByEMailRes>(end);
    fbb_.Required(o, FindPlayerByEMailRes::VT_PLAYER);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByEMailRes> CreateFindPlayerByEMailRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<SF::Flat::PlayerInformation> player = 0) {
  FindPlayerByEMailResBuilder builder_(_fbb);
  builder_.add_player(player);
  builder_.add_result(result);
  return builder_.Finish();
}

struct FindPlayerByEMailRes::Traits {
  using type = FindPlayerByEMailRes;
  static auto constexpr Create = CreateFindPlayerByEMailRes;
  static constexpr auto name = "FindPlayerByEMailRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByEMailRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FindPlayerByPlayerIDCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByPlayerIDCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4
  };
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct FindPlayerByPlayerIDCmdBuilder {
  typedef FindPlayerByPlayerIDCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(FindPlayerByPlayerIDCmd::VT_PLAYER_ID, player_id, 0);
  }
  explicit FindPlayerByPlayerIDCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByPlayerIDCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByPlayerIDCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByPlayerIDCmd> CreateFindPlayerByPlayerIDCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0) {
  FindPlayerByPlayerIDCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct FindPlayerByPlayerIDCmd::Traits {
  using type = FindPlayerByPlayerIDCmd;
  static auto constexpr Create = CreateFindPlayerByPlayerIDCmd;
  static constexpr auto name = "FindPlayerByPlayerIDCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByPlayerIDCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct FindPlayerByPlayerIDRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindPlayerByPlayerIDResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const SF::Flat::PlayerInformation *player() const {
    return GetPointer<const SF::Flat::PlayerInformation *>(VT_PLAYER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffsetRequired(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
};

struct FindPlayerByPlayerIDResBuilder {
  typedef FindPlayerByPlayerIDRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(FindPlayerByPlayerIDRes::VT_RESULT, result, 0);
  }
  void add_player(::flatbuffers::Offset<SF::Flat::PlayerInformation> player) {
    fbb_.AddOffset(FindPlayerByPlayerIDRes::VT_PLAYER, player);
  }
  explicit FindPlayerByPlayerIDResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindPlayerByPlayerIDRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindPlayerByPlayerIDRes>(end);
    fbb_.Required(o, FindPlayerByPlayerIDRes::VT_PLAYER);
    return o;
  }
};

inline ::flatbuffers::Offset<FindPlayerByPlayerIDRes> CreateFindPlayerByPlayerIDRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<SF::Flat::PlayerInformation> player = 0) {
  FindPlayerByPlayerIDResBuilder builder_(_fbb);
  builder_.add_player(player);
  builder_.add_result(result);
  return builder_.Finish();
}

struct FindPlayerByPlayerIDRes::Traits {
  using type = FindPlayerByPlayerIDRes;
  static auto constexpr Create = CreateFindPlayerByPlayerIDRes;
  static constexpr auto name = "FindPlayerByPlayerIDRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.FindPlayerByPlayerIDRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RequestPlayerStatusUpdateCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestPlayerStatusUpdateCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_PLAYER_ID = 4
  };
  const ::flatbuffers::Vector<uint64_t> *target_player_id() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_TARGET_PLAYER_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return target_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET_PLAYER_ID) &&
           verifier.VerifyVector(target_player_id()) &&
           verifier.EndTable();
  }
};

struct RequestPlayerStatusUpdateCmdBuilder {
  typedef RequestPlayerStatusUpdateCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_player_id(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> target_player_id) {
    fbb_.AddOffset(RequestPlayerStatusUpdateCmd::VT_TARGET_PLAYER_ID, target_player_id);
  }
  explicit RequestPlayerStatusUpdateCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestPlayerStatusUpdateCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestPlayerStatusUpdateCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestPlayerStatusUpdateCmd> CreateRequestPlayerStatusUpdateCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> target_player_id = 0) {
  RequestPlayerStatusUpdateCmdBuilder builder_(_fbb);
  builder_.add_target_player_id(target_player_id);
  return builder_.Finish();
}

struct RequestPlayerStatusUpdateCmd::Traits {
  using type = RequestPlayerStatusUpdateCmd;
  static auto constexpr Create = CreateRequestPlayerStatusUpdateCmd;
  static constexpr auto name = "RequestPlayerStatusUpdateCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestPlayerStatusUpdateCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "target_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RequestPlayerStatusUpdateCmd> CreateRequestPlayerStatusUpdateCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *target_player_id = nullptr) {
  auto target_player_id__ = target_player_id ? _fbb.CreateVector<uint64_t>(*target_player_id) : 0;
  return SF::Flat::Game::CreateRequestPlayerStatusUpdateCmd(
      _fbb,
      target_player_id__);
}

struct RequestPlayerStatusUpdateRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestPlayerStatusUpdateResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct RequestPlayerStatusUpdateResBuilder {
  typedef RequestPlayerStatusUpdateRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RequestPlayerStatusUpdateRes::VT_RESULT, result, 0);
  }
  explicit RequestPlayerStatusUpdateResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestPlayerStatusUpdateRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestPlayerStatusUpdateRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestPlayerStatusUpdateRes> CreateRequestPlayerStatusUpdateRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  RequestPlayerStatusUpdateResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RequestPlayerStatusUpdateRes::Traits {
  using type = RequestPlayerStatusUpdateRes;
  static auto constexpr Create = CreateRequestPlayerStatusUpdateRes;
  static constexpr auto name = "RequestPlayerStatusUpdateRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestPlayerStatusUpdateRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct NotifyPlayerStatusUpdatedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyPlayerStatusUpdatedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_LATEST_ACTIVE_TIME = 6,
    VT_IS_IN_GAME = 8
  };
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t latest_active_time() const {
    return GetField<uint32_t>(VT_LATEST_ACTIVE_TIME, 0);
  }
  uint8_t is_in_game() const {
    return GetField<uint8_t>(VT_IS_IN_GAME, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else if constexpr (Index == 1) return latest_active_time();
    else if constexpr (Index == 2) return is_in_game();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_LATEST_ACTIVE_TIME, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_IN_GAME, 1) &&
           verifier.EndTable();
  }
};

struct NotifyPlayerStatusUpdatedS2CEvtBuilder {
  typedef NotifyPlayerStatusUpdatedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(NotifyPlayerStatusUpdatedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_latest_active_time(uint32_t latest_active_time) {
    fbb_.AddElement<uint32_t>(NotifyPlayerStatusUpdatedS2CEvt::VT_LATEST_ACTIVE_TIME, latest_active_time, 0);
  }
  void add_is_in_game(uint8_t is_in_game) {
    fbb_.AddElement<uint8_t>(NotifyPlayerStatusUpdatedS2CEvt::VT_IS_IN_GAME, is_in_game, 0);
  }
  explicit NotifyPlayerStatusUpdatedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyPlayerStatusUpdatedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyPlayerStatusUpdatedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyPlayerStatusUpdatedS2CEvt> CreateNotifyPlayerStatusUpdatedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0,
    uint32_t latest_active_time = 0,
    uint8_t is_in_game = 0) {
  NotifyPlayerStatusUpdatedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_latest_active_time(latest_active_time);
  builder_.add_is_in_game(is_in_game);
  return builder_.Finish();
}

struct NotifyPlayerStatusUpdatedS2CEvt::Traits {
  using type = NotifyPlayerStatusUpdatedS2CEvt;
  static auto constexpr Create = CreateNotifyPlayerStatusUpdatedS2CEvt;
  static constexpr auto name = "NotifyPlayerStatusUpdatedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.NotifyPlayerStatusUpdatedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id",
    "latest_active_time",
    "is_in_game"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetRankingListCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetRankingListCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANKING_TYPE = 4,
    VT_BASE_RANKING = 6,
    VT_COUNT = 8
  };
  uint8_t ranking_type() const {
    return GetField<uint8_t>(VT_RANKING_TYPE, 0);
  }
  uint8_t base_ranking() const {
    return GetField<uint8_t>(VT_BASE_RANKING, 0);
  }
  uint8_t count() const {
    return GetField<uint8_t>(VT_COUNT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ranking_type();
    else if constexpr (Index == 1) return base_ranking();
    else if constexpr (Index == 2) return count();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RANKING_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BASE_RANKING, 1) &&
           VerifyField<uint8_t>(verifier, VT_COUNT, 1) &&
           verifier.EndTable();
  }
};

struct GetRankingListCmdBuilder {
  typedef GetRankingListCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ranking_type(uint8_t ranking_type) {
    fbb_.AddElement<uint8_t>(GetRankingListCmd::VT_RANKING_TYPE, ranking_type, 0);
  }
  void add_base_ranking(uint8_t base_ranking) {
    fbb_.AddElement<uint8_t>(GetRankingListCmd::VT_BASE_RANKING, base_ranking, 0);
  }
  void add_count(uint8_t count) {
    fbb_.AddElement<uint8_t>(GetRankingListCmd::VT_COUNT, count, 0);
  }
  explicit GetRankingListCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetRankingListCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetRankingListCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetRankingListCmd> CreateGetRankingListCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t ranking_type = 0,
    uint8_t base_ranking = 0,
    uint8_t count = 0) {
  GetRankingListCmdBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_base_ranking(base_ranking);
  builder_.add_ranking_type(ranking_type);
  return builder_.Finish();
}

struct GetRankingListCmd::Traits {
  using type = GetRankingListCmd;
  static auto constexpr Create = CreateGetRankingListCmd;
  static constexpr auto name = "GetRankingListCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetRankingListCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ranking_type",
    "base_ranking",
    "count"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetRankingListRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetRankingListResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_RANKING = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::TotalRankingPlayerInformation>> *ranking() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::TotalRankingPlayerInformation>> *>(VT_RANKING);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return ranking();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffsetRequired(verifier, VT_RANKING) &&
           verifier.VerifyVector(ranking()) &&
           verifier.VerifyVectorOfTables(ranking()) &&
           verifier.EndTable();
  }
};

struct GetRankingListResBuilder {
  typedef GetRankingListRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetRankingListRes::VT_RESULT, result, 0);
  }
  void add_ranking(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::TotalRankingPlayerInformation>>> ranking) {
    fbb_.AddOffset(GetRankingListRes::VT_RANKING, ranking);
  }
  explicit GetRankingListResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetRankingListRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetRankingListRes>(end);
    fbb_.Required(o, GetRankingListRes::VT_RANKING);
    return o;
  }
};

inline ::flatbuffers::Offset<GetRankingListRes> CreateGetRankingListRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::TotalRankingPlayerInformation>>> ranking = 0) {
  GetRankingListResBuilder builder_(_fbb);
  builder_.add_ranking(ranking);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetRankingListRes::Traits {
  using type = GetRankingListRes;
  static auto constexpr Create = CreateGetRankingListRes;
  static constexpr auto name = "GetRankingListRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetRankingListRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "ranking"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetRankingListRes> CreateGetRankingListResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<::flatbuffers::Offset<SF::Flat::TotalRankingPlayerInformation>> *ranking = nullptr) {
  auto ranking__ = ranking ? _fbb.CreateVector<::flatbuffers::Offset<SF::Flat::TotalRankingPlayerInformation>>(*ranking) : 0;
  return SF::Flat::Game::CreateGetRankingListRes(
      _fbb,
      result,
      ranking__);
}

struct GetUserGamePlayerInfoCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUserGamePlayerInfoCmdBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetUserGamePlayerInfoCmdBuilder {
  typedef GetUserGamePlayerInfoCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetUserGamePlayerInfoCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUserGamePlayerInfoCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUserGamePlayerInfoCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUserGamePlayerInfoCmd> CreateGetUserGamePlayerInfoCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetUserGamePlayerInfoCmdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetUserGamePlayerInfoCmd::Traits {
  using type = GetUserGamePlayerInfoCmd;
  static auto constexpr Create = CreateGetUserGamePlayerInfoCmd;
  static constexpr auto name = "GetUserGamePlayerInfoCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetUserGamePlayerInfoCmd";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct GetUserGamePlayerInfoRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUserGamePlayerInfoResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_ATTRIBUTES = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ATTRIBUTES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return attributes();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.EndTable();
  }
};

struct GetUserGamePlayerInfoResBuilder {
  typedef GetUserGamePlayerInfoRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetUserGamePlayerInfoRes::VT_RESULT, result, 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> attributes) {
    fbb_.AddOffset(GetUserGamePlayerInfoRes::VT_ATTRIBUTES, attributes);
  }
  explicit GetUserGamePlayerInfoResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUserGamePlayerInfoRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUserGamePlayerInfoRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUserGamePlayerInfoRes> CreateGetUserGamePlayerInfoRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> attributes = 0) {
  GetUserGamePlayerInfoResBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetUserGamePlayerInfoRes::Traits {
  using type = GetUserGamePlayerInfoRes;
  static auto constexpr Create = CreateGetUserGamePlayerInfoRes;
  static constexpr auto name = "GetUserGamePlayerInfoRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetUserGamePlayerInfoRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "attributes"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetUserGamePlayerInfoRes> CreateGetUserGamePlayerInfoResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *attributes = nullptr) {
  auto attributes__ = attributes ? _fbb.CreateVector<uint8_t>(*attributes) : 0;
  return SF::Flat::Game::CreateGetUserGamePlayerInfoRes(
      _fbb,
      result,
      attributes__);
}

struct GetGamePlayerInfoCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetGamePlayerInfoCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4
  };
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct GetGamePlayerInfoCmdBuilder {
  typedef GetGamePlayerInfoCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(GetGamePlayerInfoCmd::VT_PLAYER_ID, player_id, 0);
  }
  explicit GetGamePlayerInfoCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetGamePlayerInfoCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetGamePlayerInfoCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetGamePlayerInfoCmd> CreateGetGamePlayerInfoCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0) {
  GetGamePlayerInfoCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct GetGamePlayerInfoCmd::Traits {
  using type = GetGamePlayerInfoCmd;
  static auto constexpr Create = CreateGetGamePlayerInfoCmd;
  static constexpr auto name = "GetGamePlayerInfoCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetGamePlayerInfoCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetGamePlayerInfoRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetGamePlayerInfoResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER_ID = 6,
    VT_ATTRIBUTES = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ATTRIBUTES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return attributes();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.EndTable();
  }
};

struct GetGamePlayerInfoResBuilder {
  typedef GetGamePlayerInfoRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetGamePlayerInfoRes::VT_RESULT, result, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(GetGamePlayerInfoRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> attributes) {
    fbb_.AddOffset(GetGamePlayerInfoRes::VT_ATTRIBUTES, attributes);
  }
  explicit GetGamePlayerInfoResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetGamePlayerInfoRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetGamePlayerInfoRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetGamePlayerInfoRes> CreateGetGamePlayerInfoRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> attributes = 0) {
  GetGamePlayerInfoResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_attributes(attributes);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetGamePlayerInfoRes::Traits {
  using type = GetGamePlayerInfoRes;
  static auto constexpr Create = CreateGetGamePlayerInfoRes;
  static constexpr auto name = "GetGamePlayerInfoRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetGamePlayerInfoRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player_id",
    "attributes"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetGamePlayerInfoRes> CreateGetGamePlayerInfoResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *attributes = nullptr) {
  auto attributes__ = attributes ? _fbb.CreateVector<uint8_t>(*attributes) : 0;
  return SF::Flat::Game::CreateGetGamePlayerInfoRes(
      _fbb,
      result,
      player_id,
      attributes__);
}

struct LevelUpS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LevelUpS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT_TOTAL_EXP = 4,
    VT_CURRENT_LEVEL = 6
  };
  uint64_t current_total_exp() const {
    return GetField<uint64_t>(VT_CURRENT_TOTAL_EXP, 0);
  }
  uint32_t current_level() const {
    return GetField<uint32_t>(VT_CURRENT_LEVEL, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return current_total_exp();
    else if constexpr (Index == 1) return current_level();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CURRENT_TOTAL_EXP, 8) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT_LEVEL, 4) &&
           verifier.EndTable();
  }
};

struct LevelUpS2CEvtBuilder {
  typedef LevelUpS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_current_total_exp(uint64_t current_total_exp) {
    fbb_.AddElement<uint64_t>(LevelUpS2CEvt::VT_CURRENT_TOTAL_EXP, current_total_exp, 0);
  }
  void add_current_level(uint32_t current_level) {
    fbb_.AddElement<uint32_t>(LevelUpS2CEvt::VT_CURRENT_LEVEL, current_level, 0);
  }
  explicit LevelUpS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LevelUpS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LevelUpS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LevelUpS2CEvt> CreateLevelUpS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t current_total_exp = 0,
    uint32_t current_level = 0) {
  LevelUpS2CEvtBuilder builder_(_fbb);
  builder_.add_current_total_exp(current_total_exp);
  builder_.add_current_level(current_level);
  return builder_.Finish();
}

struct LevelUpS2CEvt::Traits {
  using type = LevelUpS2CEvt;
  static auto constexpr Create = CreateLevelUpS2CEvt;
  static constexpr auto name = "LevelUpS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LevelUpS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "current_total_exp",
    "current_level"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SetNickNameCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetNickNameCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NICK_NAME = 4,
    VT_IS_COST_FREE = 6
  };
  const ::flatbuffers::String *nick_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICK_NAME);
  }
  uint8_t is_cost_free() const {
    return GetField<uint8_t>(VT_IS_COST_FREE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return nick_name();
    else if constexpr (Index == 1) return is_cost_free();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NICK_NAME) &&
           verifier.VerifyString(nick_name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_COST_FREE, 1) &&
           verifier.EndTable();
  }
};

struct SetNickNameCmdBuilder {
  typedef SetNickNameCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nick_name(::flatbuffers::Offset<::flatbuffers::String> nick_name) {
    fbb_.AddOffset(SetNickNameCmd::VT_NICK_NAME, nick_name);
  }
  void add_is_cost_free(uint8_t is_cost_free) {
    fbb_.AddElement<uint8_t>(SetNickNameCmd::VT_IS_COST_FREE, is_cost_free, 0);
  }
  explicit SetNickNameCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetNickNameCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetNickNameCmd>(end);
    fbb_.Required(o, SetNickNameCmd::VT_NICK_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<SetNickNameCmd> CreateSetNickNameCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nick_name = 0,
    uint8_t is_cost_free = 0) {
  SetNickNameCmdBuilder builder_(_fbb);
  builder_.add_nick_name(nick_name);
  builder_.add_is_cost_free(is_cost_free);
  return builder_.Finish();
}

struct SetNickNameCmd::Traits {
  using type = SetNickNameCmd;
  static auto constexpr Create = CreateSetNickNameCmd;
  static constexpr auto name = "SetNickNameCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SetNickNameCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "nick_name",
    "is_cost_free"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SetNickNameCmd> CreateSetNickNameCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nick_name = nullptr,
    uint8_t is_cost_free = 0) {
  auto nick_name__ = nick_name ? _fbb.CreateString(nick_name) : 0;
  return SF::Flat::Game::CreateSetNickNameCmd(
      _fbb,
      nick_name__,
      is_cost_free);
}

struct SetNickNameRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetNickNameResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_TOTAL_GEM = 6,
    VT_TOTAL_GAME_MONEY = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t total_gem() const {
    return GetField<uint64_t>(VT_TOTAL_GEM, 0);
  }
  uint64_t total_game_money() const {
    return GetField<uint64_t>(VT_TOTAL_GAME_MONEY, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return total_gem();
    else if constexpr (Index == 2) return total_game_money();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_GEM, 8) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_GAME_MONEY, 8) &&
           verifier.EndTable();
  }
};

struct SetNickNameResBuilder {
  typedef SetNickNameRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SetNickNameRes::VT_RESULT, result, 0);
  }
  void add_total_gem(uint64_t total_gem) {
    fbb_.AddElement<uint64_t>(SetNickNameRes::VT_TOTAL_GEM, total_gem, 0);
  }
  void add_total_game_money(uint64_t total_game_money) {
    fbb_.AddElement<uint64_t>(SetNickNameRes::VT_TOTAL_GAME_MONEY, total_game_money, 0);
  }
  explicit SetNickNameResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetNickNameRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetNickNameRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetNickNameRes> CreateSetNickNameRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t total_gem = 0,
    uint64_t total_game_money = 0) {
  SetNickNameResBuilder builder_(_fbb);
  builder_.add_total_game_money(total_game_money);
  builder_.add_total_gem(total_gem);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SetNickNameRes::Traits {
  using type = SetNickNameRes;
  static auto constexpr Create = CreateSetNickNameRes;
  static constexpr auto name = "SetNickNameRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SetNickNameRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "total_gem",
    "total_game_money"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CreatePartyCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreatePartyCmdBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CreatePartyCmdBuilder {
  typedef CreatePartyCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CreatePartyCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreatePartyCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreatePartyCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreatePartyCmd> CreateCreatePartyCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CreatePartyCmdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CreatePartyCmd::Traits {
  using type = CreatePartyCmd;
  static auto constexpr Create = CreateCreatePartyCmd;
  static constexpr auto name = "CreatePartyCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CreatePartyCmd";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct CreatePartyRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreatePartyResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PARTY_UID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return party_uid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           verifier.EndTable();
  }
};

struct CreatePartyResBuilder {
  typedef CreatePartyRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CreatePartyRes::VT_RESULT, result, 0);
  }
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(CreatePartyRes::VT_PARTY_UID, party_uid, 0);
  }
  explicit CreatePartyResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreatePartyRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreatePartyRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreatePartyRes> CreateCreatePartyRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t party_uid = 0) {
  CreatePartyResBuilder builder_(_fbb);
  builder_.add_party_uid(party_uid);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CreatePartyRes::Traits {
  using type = CreatePartyRes;
  static auto constexpr Create = CreateCreatePartyRes;
  static constexpr auto name = "CreatePartyRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CreatePartyRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "party_uid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct JoinPartyCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinPartyCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_INVITER_ID = 6
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t inviter_id() const {
    return GetField<uint64_t>(VT_INVITER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return inviter_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_INVITER_ID, 8) &&
           verifier.EndTable();
  }
};

struct JoinPartyCmdBuilder {
  typedef JoinPartyCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(JoinPartyCmd::VT_PARTY_UID, party_uid, 0);
  }
  void add_inviter_id(uint64_t inviter_id) {
    fbb_.AddElement<uint64_t>(JoinPartyCmd::VT_INVITER_ID, inviter_id, 0);
  }
  explicit JoinPartyCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinPartyCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinPartyCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinPartyCmd> CreateJoinPartyCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    uint64_t inviter_id = 0) {
  JoinPartyCmdBuilder builder_(_fbb);
  builder_.add_inviter_id(inviter_id);
  builder_.add_party_uid(party_uid);
  return builder_.Finish();
}

struct JoinPartyCmd::Traits {
  using type = JoinPartyCmd;
  static auto constexpr Create = CreateJoinPartyCmd;
  static constexpr auto name = "JoinPartyCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinPartyCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "inviter_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct JoinPartyRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinPartyResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PARTY_UID = 6,
    VT_PARTY_LEADER_ID = 8,
    VT_CHAT_HISTORY_DATA = 10
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t party_leader_id() const {
    return GetField<uint64_t>(VT_PARTY_LEADER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_history_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_HISTORY_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return party_uid();
    else if constexpr (Index == 2) return party_leader_id();
    else if constexpr (Index == 3) return chat_history_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_LEADER_ID, 8) &&
           VerifyOffset(verifier, VT_CHAT_HISTORY_DATA) &&
           verifier.VerifyVector(chat_history_data()) &&
           verifier.EndTable();
  }
};

struct JoinPartyResBuilder {
  typedef JoinPartyRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(JoinPartyRes::VT_RESULT, result, 0);
  }
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(JoinPartyRes::VT_PARTY_UID, party_uid, 0);
  }
  void add_party_leader_id(uint64_t party_leader_id) {
    fbb_.AddElement<uint64_t>(JoinPartyRes::VT_PARTY_LEADER_ID, party_leader_id, 0);
  }
  void add_chat_history_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_history_data) {
    fbb_.AddOffset(JoinPartyRes::VT_CHAT_HISTORY_DATA, chat_history_data);
  }
  explicit JoinPartyResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinPartyRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinPartyRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinPartyRes> CreateJoinPartyRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t party_uid = 0,
    uint64_t party_leader_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_history_data = 0) {
  JoinPartyResBuilder builder_(_fbb);
  builder_.add_party_leader_id(party_leader_id);
  builder_.add_party_uid(party_uid);
  builder_.add_chat_history_data(chat_history_data);
  builder_.add_result(result);
  return builder_.Finish();
}

struct JoinPartyRes::Traits {
  using type = JoinPartyRes;
  static auto constexpr Create = CreateJoinPartyRes;
  static constexpr auto name = "JoinPartyRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinPartyRes";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "party_uid",
    "party_leader_id",
    "chat_history_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<JoinPartyRes> CreateJoinPartyResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t party_uid = 0,
    uint64_t party_leader_id = 0,
    const std::vector<uint8_t> *chat_history_data = nullptr) {
  auto chat_history_data__ = chat_history_data ? _fbb.CreateVector<uint8_t>(*chat_history_data) : 0;
  return SF::Flat::Game::CreateJoinPartyRes(
      _fbb,
      result,
      party_uid,
      party_leader_id,
      chat_history_data__);
}

struct PartyPlayerJoinedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPlayerJoinedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_JOINED_PLAYER = 6
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  const SF::Flat::PlayerInformation *joined_player() const {
    return GetPointer<const SF::Flat::PlayerInformation *>(VT_JOINED_PLAYER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return joined_player();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyOffsetRequired(verifier, VT_JOINED_PLAYER) &&
           verifier.VerifyTable(joined_player()) &&
           verifier.EndTable();
  }
};

struct PartyPlayerJoinedS2CEvtBuilder {
  typedef PartyPlayerJoinedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(PartyPlayerJoinedS2CEvt::VT_PARTY_UID, party_uid, 0);
  }
  void add_joined_player(::flatbuffers::Offset<SF::Flat::PlayerInformation> joined_player) {
    fbb_.AddOffset(PartyPlayerJoinedS2CEvt::VT_JOINED_PLAYER, joined_player);
  }
  explicit PartyPlayerJoinedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPlayerJoinedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPlayerJoinedS2CEvt>(end);
    fbb_.Required(o, PartyPlayerJoinedS2CEvt::VT_JOINED_PLAYER);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPlayerJoinedS2CEvt> CreatePartyPlayerJoinedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    ::flatbuffers::Offset<SF::Flat::PlayerInformation> joined_player = 0) {
  PartyPlayerJoinedS2CEvtBuilder builder_(_fbb);
  builder_.add_party_uid(party_uid);
  builder_.add_joined_player(joined_player);
  return builder_.Finish();
}

struct PartyPlayerJoinedS2CEvt::Traits {
  using type = PartyPlayerJoinedS2CEvt;
  static auto constexpr Create = CreatePartyPlayerJoinedS2CEvt;
  static constexpr auto name = "PartyPlayerJoinedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyPlayerJoinedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "joined_player"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyLeaderChangedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyLeaderChangedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_NEW_LEADER_ID = 6
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t new_leader_id() const {
    return GetField<uint64_t>(VT_NEW_LEADER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return new_leader_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_NEW_LEADER_ID, 8) &&
           verifier.EndTable();
  }
};

struct PartyLeaderChangedS2CEvtBuilder {
  typedef PartyLeaderChangedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(PartyLeaderChangedS2CEvt::VT_PARTY_UID, party_uid, 0);
  }
  void add_new_leader_id(uint64_t new_leader_id) {
    fbb_.AddElement<uint64_t>(PartyLeaderChangedS2CEvt::VT_NEW_LEADER_ID, new_leader_id, 0);
  }
  explicit PartyLeaderChangedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyLeaderChangedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyLeaderChangedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyLeaderChangedS2CEvt> CreatePartyLeaderChangedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    uint64_t new_leader_id = 0) {
  PartyLeaderChangedS2CEvtBuilder builder_(_fbb);
  builder_.add_new_leader_id(new_leader_id);
  builder_.add_party_uid(party_uid);
  return builder_.Finish();
}

struct PartyLeaderChangedS2CEvt::Traits {
  using type = PartyLeaderChangedS2CEvt;
  static auto constexpr Create = CreatePartyLeaderChangedS2CEvt;
  static constexpr auto name = "PartyLeaderChangedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyLeaderChangedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "new_leader_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct LeavePartyCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeavePartyCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_PLAYER_ID = 6
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct LeavePartyCmdBuilder {
  typedef LeavePartyCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(LeavePartyCmd::VT_PARTY_UID, party_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(LeavePartyCmd::VT_PLAYER_ID, player_id, 0);
  }
  explicit LeavePartyCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeavePartyCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeavePartyCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeavePartyCmd> CreateLeavePartyCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    uint64_t player_id = 0) {
  LeavePartyCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_party_uid(party_uid);
  return builder_.Finish();
}

struct LeavePartyCmd::Traits {
  using type = LeavePartyCmd;
  static auto constexpr Create = CreateLeavePartyCmd;
  static constexpr auto name = "LeavePartyCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LeavePartyCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct LeavePartyRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeavePartyResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct LeavePartyResBuilder {
  typedef LeavePartyRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(LeavePartyRes::VT_RESULT, result, 0);
  }
  explicit LeavePartyResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeavePartyRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeavePartyRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeavePartyRes> CreateLeavePartyRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  LeavePartyResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct LeavePartyRes::Traits {
  using type = LeavePartyRes;
  static auto constexpr Create = CreateLeavePartyRes;
  static constexpr auto name = "LeavePartyRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LeavePartyRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyPlayerLeftS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPlayerLeftS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_LEFT_PLAYER_ID = 6
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t left_player_id() const {
    return GetField<uint64_t>(VT_LEFT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return left_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_LEFT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct PartyPlayerLeftS2CEvtBuilder {
  typedef PartyPlayerLeftS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(PartyPlayerLeftS2CEvt::VT_PARTY_UID, party_uid, 0);
  }
  void add_left_player_id(uint64_t left_player_id) {
    fbb_.AddElement<uint64_t>(PartyPlayerLeftS2CEvt::VT_LEFT_PLAYER_ID, left_player_id, 0);
  }
  explicit PartyPlayerLeftS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPlayerLeftS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPlayerLeftS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPlayerLeftS2CEvt> CreatePartyPlayerLeftS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    uint64_t left_player_id = 0) {
  PartyPlayerLeftS2CEvtBuilder builder_(_fbb);
  builder_.add_left_player_id(left_player_id);
  builder_.add_party_uid(party_uid);
  return builder_.Finish();
}

struct PartyPlayerLeftS2CEvt::Traits {
  using type = PartyPlayerLeftS2CEvt;
  static auto constexpr Create = CreatePartyPlayerLeftS2CEvt;
  static constexpr auto name = "PartyPlayerLeftS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyPlayerLeftS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "left_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyKickPlayerCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyKickPlayerCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_PLAYER_ID = 6,
    VT_PLAYER_TO_KICK = 8
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t player_to_kick() const {
    return GetField<uint64_t>(VT_PLAYER_TO_KICK, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return player_to_kick();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_TO_KICK, 8) &&
           verifier.EndTable();
  }
};

struct PartyKickPlayerCmdBuilder {
  typedef PartyKickPlayerCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(PartyKickPlayerCmd::VT_PARTY_UID, party_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(PartyKickPlayerCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_to_kick(uint64_t player_to_kick) {
    fbb_.AddElement<uint64_t>(PartyKickPlayerCmd::VT_PLAYER_TO_KICK, player_to_kick, 0);
  }
  explicit PartyKickPlayerCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyKickPlayerCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyKickPlayerCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyKickPlayerCmd> CreatePartyKickPlayerCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    uint64_t player_id = 0,
    uint64_t player_to_kick = 0) {
  PartyKickPlayerCmdBuilder builder_(_fbb);
  builder_.add_player_to_kick(player_to_kick);
  builder_.add_player_id(player_id);
  builder_.add_party_uid(party_uid);
  return builder_.Finish();
}

struct PartyKickPlayerCmd::Traits {
  using type = PartyKickPlayerCmd;
  static auto constexpr Create = CreatePartyKickPlayerCmd;
  static constexpr auto name = "PartyKickPlayerCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyKickPlayerCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "player_id",
    "player_to_kick"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyKickPlayerRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyKickPlayerResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct PartyKickPlayerResBuilder {
  typedef PartyKickPlayerRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(PartyKickPlayerRes::VT_RESULT, result, 0);
  }
  explicit PartyKickPlayerResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyKickPlayerRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyKickPlayerRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyKickPlayerRes> CreatePartyKickPlayerRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  PartyKickPlayerResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct PartyKickPlayerRes::Traits {
  using type = PartyKickPlayerRes;
  static auto constexpr Create = CreatePartyKickPlayerRes;
  static constexpr auto name = "PartyKickPlayerRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyKickPlayerRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyPlayerKickedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPlayerKickedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_UID = 4,
    VT_KICKED_PLAYER_ID = 6
  };
  uint64_t party_uid() const {
    return GetField<uint64_t>(VT_PARTY_UID, 0);
  }
  uint64_t kicked_player_id() const {
    return GetField<uint64_t>(VT_KICKED_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return party_uid();
    else if constexpr (Index == 1) return kicked_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_KICKED_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct PartyPlayerKickedS2CEvtBuilder {
  typedef PartyPlayerKickedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_party_uid(uint64_t party_uid) {
    fbb_.AddElement<uint64_t>(PartyPlayerKickedS2CEvt::VT_PARTY_UID, party_uid, 0);
  }
  void add_kicked_player_id(uint64_t kicked_player_id) {
    fbb_.AddElement<uint64_t>(PartyPlayerKickedS2CEvt::VT_KICKED_PLAYER_ID, kicked_player_id, 0);
  }
  explicit PartyPlayerKickedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPlayerKickedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPlayerKickedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPlayerKickedS2CEvt> CreatePartyPlayerKickedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t party_uid = 0,
    uint64_t kicked_player_id = 0) {
  PartyPlayerKickedS2CEvtBuilder builder_(_fbb);
  builder_.add_kicked_player_id(kicked_player_id);
  builder_.add_party_uid(party_uid);
  return builder_.Finish();
}

struct PartyPlayerKickedS2CEvt::Traits {
  using type = PartyPlayerKickedS2CEvt;
  static auto constexpr Create = CreatePartyPlayerKickedS2CEvt;
  static constexpr auto name = "PartyPlayerKickedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyPlayerKickedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "party_uid",
    "kicked_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyInviteCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyInviteCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVITE_TARGET_ID = 4
  };
  uint64_t invite_target_id() const {
    return GetField<uint64_t>(VT_INVITE_TARGET_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return invite_target_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INVITE_TARGET_ID, 8) &&
           verifier.EndTable();
  }
};

struct PartyInviteCmdBuilder {
  typedef PartyInviteCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_invite_target_id(uint64_t invite_target_id) {
    fbb_.AddElement<uint64_t>(PartyInviteCmd::VT_INVITE_TARGET_ID, invite_target_id, 0);
  }
  explicit PartyInviteCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyInviteCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyInviteCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyInviteCmd> CreatePartyInviteCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t invite_target_id = 0) {
  PartyInviteCmdBuilder builder_(_fbb);
  builder_.add_invite_target_id(invite_target_id);
  return builder_.Finish();
}

struct PartyInviteCmd::Traits {
  using type = PartyInviteCmd;
  static auto constexpr Create = CreatePartyInviteCmd;
  static constexpr auto name = "PartyInviteCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyInviteCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "invite_target_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyInviteRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyInviteResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct PartyInviteResBuilder {
  typedef PartyInviteRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(PartyInviteRes::VT_RESULT, result, 0);
  }
  explicit PartyInviteResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyInviteRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyInviteRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyInviteRes> CreatePartyInviteRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  PartyInviteResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct PartyInviteRes::Traits {
  using type = PartyInviteRes;
  static auto constexpr Create = CreatePartyInviteRes;
  static constexpr auto name = "PartyInviteRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyInviteRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyInviteRequestedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyInviteRequestedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVITER_ID = 4,
    VT_INVITER_NAME = 6,
    VT_PARTY_TO_JOIN_UID = 8
  };
  uint64_t inviter_id() const {
    return GetField<uint64_t>(VT_INVITER_ID, 0);
  }
  const ::flatbuffers::String *inviter_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INVITER_NAME);
  }
  uint64_t party_to_join_uid() const {
    return GetField<uint64_t>(VT_PARTY_TO_JOIN_UID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return inviter_id();
    else if constexpr (Index == 1) return inviter_name();
    else if constexpr (Index == 2) return party_to_join_uid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INVITER_ID, 8) &&
           VerifyOffsetRequired(verifier, VT_INVITER_NAME) &&
           verifier.VerifyString(inviter_name()) &&
           VerifyField<uint64_t>(verifier, VT_PARTY_TO_JOIN_UID, 8) &&
           verifier.EndTable();
  }
};

struct PartyInviteRequestedS2CEvtBuilder {
  typedef PartyInviteRequestedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inviter_id(uint64_t inviter_id) {
    fbb_.AddElement<uint64_t>(PartyInviteRequestedS2CEvt::VT_INVITER_ID, inviter_id, 0);
  }
  void add_inviter_name(::flatbuffers::Offset<::flatbuffers::String> inviter_name) {
    fbb_.AddOffset(PartyInviteRequestedS2CEvt::VT_INVITER_NAME, inviter_name);
  }
  void add_party_to_join_uid(uint64_t party_to_join_uid) {
    fbb_.AddElement<uint64_t>(PartyInviteRequestedS2CEvt::VT_PARTY_TO_JOIN_UID, party_to_join_uid, 0);
  }
  explicit PartyInviteRequestedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyInviteRequestedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyInviteRequestedS2CEvt>(end);
    fbb_.Required(o, PartyInviteRequestedS2CEvt::VT_INVITER_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyInviteRequestedS2CEvt> CreatePartyInviteRequestedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t inviter_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> inviter_name = 0,
    uint64_t party_to_join_uid = 0) {
  PartyInviteRequestedS2CEvtBuilder builder_(_fbb);
  builder_.add_party_to_join_uid(party_to_join_uid);
  builder_.add_inviter_id(inviter_id);
  builder_.add_inviter_name(inviter_name);
  return builder_.Finish();
}

struct PartyInviteRequestedS2CEvt::Traits {
  using type = PartyInviteRequestedS2CEvt;
  static auto constexpr Create = CreatePartyInviteRequestedS2CEvt;
  static constexpr auto name = "PartyInviteRequestedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyInviteRequestedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "inviter_id",
    "inviter_name",
    "party_to_join_uid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PartyInviteRequestedS2CEvt> CreatePartyInviteRequestedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t inviter_id = 0,
    const char *inviter_name = nullptr,
    uint64_t party_to_join_uid = 0) {
  auto inviter_name__ = inviter_name ? _fbb.CreateString(inviter_name) : 0;
  return SF::Flat::Game::CreatePartyInviteRequestedS2CEvt(
      _fbb,
      inviter_id,
      inviter_name__,
      party_to_join_uid);
}

struct PartyQuickChatMessageCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyQuickChatMessageCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUICK_CHAT_ID = 4
  };
  uint32_t quick_chat_id() const {
    return GetField<uint32_t>(VT_QUICK_CHAT_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return quick_chat_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_QUICK_CHAT_ID, 4) &&
           verifier.EndTable();
  }
};

struct PartyQuickChatMessageCmdBuilder {
  typedef PartyQuickChatMessageCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_quick_chat_id(uint32_t quick_chat_id) {
    fbb_.AddElement<uint32_t>(PartyQuickChatMessageCmd::VT_QUICK_CHAT_ID, quick_chat_id, 0);
  }
  explicit PartyQuickChatMessageCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyQuickChatMessageCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyQuickChatMessageCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyQuickChatMessageCmd> CreatePartyQuickChatMessageCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t quick_chat_id = 0) {
  PartyQuickChatMessageCmdBuilder builder_(_fbb);
  builder_.add_quick_chat_id(quick_chat_id);
  return builder_.Finish();
}

struct PartyQuickChatMessageCmd::Traits {
  using type = PartyQuickChatMessageCmd;
  static auto constexpr Create = CreatePartyQuickChatMessageCmd;
  static constexpr auto name = "PartyQuickChatMessageCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyQuickChatMessageCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "quick_chat_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyQuickChatMessageRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyQuickChatMessageResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct PartyQuickChatMessageResBuilder {
  typedef PartyQuickChatMessageRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(PartyQuickChatMessageRes::VT_RESULT, result, 0);
  }
  explicit PartyQuickChatMessageResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyQuickChatMessageRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyQuickChatMessageRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyQuickChatMessageRes> CreatePartyQuickChatMessageRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  PartyQuickChatMessageResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct PartyQuickChatMessageRes::Traits {
  using type = PartyQuickChatMessageRes;
  static auto constexpr Create = CreatePartyQuickChatMessageRes;
  static constexpr auto name = "PartyQuickChatMessageRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyQuickChatMessageRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyQuickChatMessageS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyQuickChatMessageS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENDER_ID = 4,
    VT_QUICK_CHAT_ID = 6
  };
  uint64_t sender_id() const {
    return GetField<uint64_t>(VT_SENDER_ID, 0);
  }
  uint32_t quick_chat_id() const {
    return GetField<uint32_t>(VT_QUICK_CHAT_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return sender_id();
    else if constexpr (Index == 1) return quick_chat_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SENDER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_QUICK_CHAT_ID, 4) &&
           verifier.EndTable();
  }
};

struct PartyQuickChatMessageS2CEvtBuilder {
  typedef PartyQuickChatMessageS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sender_id(uint64_t sender_id) {
    fbb_.AddElement<uint64_t>(PartyQuickChatMessageS2CEvt::VT_SENDER_ID, sender_id, 0);
  }
  void add_quick_chat_id(uint32_t quick_chat_id) {
    fbb_.AddElement<uint32_t>(PartyQuickChatMessageS2CEvt::VT_QUICK_CHAT_ID, quick_chat_id, 0);
  }
  explicit PartyQuickChatMessageS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyQuickChatMessageS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyQuickChatMessageS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyQuickChatMessageS2CEvt> CreatePartyQuickChatMessageS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    uint32_t quick_chat_id = 0) {
  PartyQuickChatMessageS2CEvtBuilder builder_(_fbb);
  builder_.add_sender_id(sender_id);
  builder_.add_quick_chat_id(quick_chat_id);
  return builder_.Finish();
}

struct PartyQuickChatMessageS2CEvt::Traits {
  using type = PartyQuickChatMessageS2CEvt;
  static auto constexpr Create = CreatePartyQuickChatMessageS2CEvt;
  static constexpr auto name = "PartyQuickChatMessageS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyQuickChatMessageS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "sender_id",
    "quick_chat_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyChatMessageCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyChatMessageCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_MESSAGE = 4
  };
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct PartyChatMessageCmdBuilder {
  typedef PartyChatMessageCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(PartyChatMessageCmd::VT_CHAT_MESSAGE, chat_message);
  }
  explicit PartyChatMessageCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyChatMessageCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyChatMessageCmd>(end);
    fbb_.Required(o, PartyChatMessageCmd::VT_CHAT_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyChatMessageCmd> CreatePartyChatMessageCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  PartyChatMessageCmdBuilder builder_(_fbb);
  builder_.add_chat_message(chat_message);
  return builder_.Finish();
}

struct PartyChatMessageCmd::Traits {
  using type = PartyChatMessageCmd;
  static auto constexpr Create = CreatePartyChatMessageCmd;
  static constexpr auto name = "PartyChatMessageCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyChatMessageCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PartyChatMessageCmd> CreatePartyChatMessageCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *chat_message = nullptr) {
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::Game::CreatePartyChatMessageCmd(
      _fbb,
      chat_message__);
}

struct PartyChatMessageRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyChatMessageResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct PartyChatMessageResBuilder {
  typedef PartyChatMessageRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(PartyChatMessageRes::VT_RESULT, result, 0);
  }
  explicit PartyChatMessageResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyChatMessageRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyChatMessageRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyChatMessageRes> CreatePartyChatMessageRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  PartyChatMessageResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct PartyChatMessageRes::Traits {
  using type = PartyChatMessageRes;
  static auto constexpr Create = CreatePartyChatMessageRes;
  static constexpr auto name = "PartyChatMessageRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyChatMessageRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PartyChatMessageS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyChatMessageS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENDER_ID = 4,
    VT_SENDER_NAME = 6,
    VT_CHAT_MESSAGE = 8
  };
  uint64_t sender_id() const {
    return GetField<uint64_t>(VT_SENDER_ID, 0);
  }
  const ::flatbuffers::String *sender_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENDER_NAME);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return sender_id();
    else if constexpr (Index == 1) return sender_name();
    else if constexpr (Index == 2) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SENDER_ID, 8) &&
           VerifyOffsetRequired(verifier, VT_SENDER_NAME) &&
           verifier.VerifyString(sender_name()) &&
           VerifyOffsetRequired(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct PartyChatMessageS2CEvtBuilder {
  typedef PartyChatMessageS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sender_id(uint64_t sender_id) {
    fbb_.AddElement<uint64_t>(PartyChatMessageS2CEvt::VT_SENDER_ID, sender_id, 0);
  }
  void add_sender_name(::flatbuffers::Offset<::flatbuffers::String> sender_name) {
    fbb_.AddOffset(PartyChatMessageS2CEvt::VT_SENDER_NAME, sender_name);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(PartyChatMessageS2CEvt::VT_CHAT_MESSAGE, chat_message);
  }
  explicit PartyChatMessageS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyChatMessageS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyChatMessageS2CEvt>(end);
    fbb_.Required(o, PartyChatMessageS2CEvt::VT_SENDER_NAME);
    fbb_.Required(o, PartyChatMessageS2CEvt::VT_CHAT_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyChatMessageS2CEvt> CreatePartyChatMessageS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sender_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  PartyChatMessageS2CEvtBuilder builder_(_fbb);
  builder_.add_sender_id(sender_id);
  builder_.add_chat_message(chat_message);
  builder_.add_sender_name(sender_name);
  return builder_.Finish();
}

struct PartyChatMessageS2CEvt::Traits {
  using type = PartyChatMessageS2CEvt;
  static auto constexpr Create = CreatePartyChatMessageS2CEvt;
  static constexpr auto name = "PartyChatMessageS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.PartyChatMessageS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "sender_id",
    "sender_name",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PartyChatMessageS2CEvt> CreatePartyChatMessageS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    const char *sender_name = nullptr,
    const char *chat_message = nullptr) {
  auto sender_name__ = sender_name ? _fbb.CreateString(sender_name) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::Game::CreatePartyChatMessageS2CEvt(
      _fbb,
      sender_id,
      sender_name__,
      chat_message__);
}

struct JoinGameInstanceCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinGameInstanceCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INS_UID = 4
  };
  uint64_t ins_uid() const {
    return GetField<uint64_t>(VT_INS_UID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ins_uid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INS_UID, 8) &&
           verifier.EndTable();
  }
};

struct JoinGameInstanceCmdBuilder {
  typedef JoinGameInstanceCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ins_uid(uint64_t ins_uid) {
    fbb_.AddElement<uint64_t>(JoinGameInstanceCmd::VT_INS_UID, ins_uid, 0);
  }
  explicit JoinGameInstanceCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinGameInstanceCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinGameInstanceCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinGameInstanceCmd> CreateJoinGameInstanceCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ins_uid = 0) {
  JoinGameInstanceCmdBuilder builder_(_fbb);
  builder_.add_ins_uid(ins_uid);
  return builder_.Finish();
}

struct JoinGameInstanceCmd::Traits {
  using type = JoinGameInstanceCmd;
  static auto constexpr Create = CreateJoinGameInstanceCmd;
  static constexpr auto name = "JoinGameInstanceCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinGameInstanceCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ins_uid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct JoinGameInstanceRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinGameInstanceResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_INS_UID = 6,
    VT_SERVER_PUBLIC_ADDRESS = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t ins_uid() const {
    return GetField<uint64_t>(VT_INS_UID, 0);
  }
  const ::flatbuffers::String *server_public_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVER_PUBLIC_ADDRESS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return ins_uid();
    else if constexpr (Index == 2) return server_public_address();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_INS_UID, 8) &&
           VerifyOffsetRequired(verifier, VT_SERVER_PUBLIC_ADDRESS) &&
           verifier.VerifyString(server_public_address()) &&
           verifier.EndTable();
  }
};

struct JoinGameInstanceResBuilder {
  typedef JoinGameInstanceRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(JoinGameInstanceRes::VT_RESULT, result, 0);
  }
  void add_ins_uid(uint64_t ins_uid) {
    fbb_.AddElement<uint64_t>(JoinGameInstanceRes::VT_INS_UID, ins_uid, 0);
  }
  void add_server_public_address(::flatbuffers::Offset<::flatbuffers::String> server_public_address) {
    fbb_.AddOffset(JoinGameInstanceRes::VT_SERVER_PUBLIC_ADDRESS, server_public_address);
  }
  explicit JoinGameInstanceResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinGameInstanceRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinGameInstanceRes>(end);
    fbb_.Required(o, JoinGameInstanceRes::VT_SERVER_PUBLIC_ADDRESS);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinGameInstanceRes> CreateJoinGameInstanceRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t ins_uid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> server_public_address = 0) {
  JoinGameInstanceResBuilder builder_(_fbb);
  builder_.add_ins_uid(ins_uid);
  builder_.add_server_public_address(server_public_address);
  builder_.add_result(result);
  return builder_.Finish();
}

struct JoinGameInstanceRes::Traits {
  using type = JoinGameInstanceRes;
  static auto constexpr Create = CreateJoinGameInstanceRes;
  static constexpr auto name = "JoinGameInstanceRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinGameInstanceRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "ins_uid",
    "server_public_address"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<JoinGameInstanceRes> CreateJoinGameInstanceResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t ins_uid = 0,
    const char *server_public_address = nullptr) {
  auto server_public_address__ = server_public_address ? _fbb.CreateString(server_public_address) : 0;
  return SF::Flat::Game::CreateJoinGameInstanceRes(
      _fbb,
      result,
      ins_uid,
      server_public_address__);
}

struct LeaveGameInstanceCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaveGameInstanceCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INS_UID = 4
  };
  uint64_t ins_uid() const {
    return GetField<uint64_t>(VT_INS_UID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ins_uid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INS_UID, 8) &&
           verifier.EndTable();
  }
};

struct LeaveGameInstanceCmdBuilder {
  typedef LeaveGameInstanceCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ins_uid(uint64_t ins_uid) {
    fbb_.AddElement<uint64_t>(LeaveGameInstanceCmd::VT_INS_UID, ins_uid, 0);
  }
  explicit LeaveGameInstanceCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaveGameInstanceCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaveGameInstanceCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaveGameInstanceCmd> CreateLeaveGameInstanceCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ins_uid = 0) {
  LeaveGameInstanceCmdBuilder builder_(_fbb);
  builder_.add_ins_uid(ins_uid);
  return builder_.Finish();
}

struct LeaveGameInstanceCmd::Traits {
  using type = LeaveGameInstanceCmd;
  static auto constexpr Create = CreateLeaveGameInstanceCmd;
  static constexpr auto name = "LeaveGameInstanceCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LeaveGameInstanceCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ins_uid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct LeaveGameInstanceRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaveGameInstanceResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct LeaveGameInstanceResBuilder {
  typedef LeaveGameInstanceRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(LeaveGameInstanceRes::VT_RESULT, result, 0);
  }
  explicit LeaveGameInstanceResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaveGameInstanceRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaveGameInstanceRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaveGameInstanceRes> CreateLeaveGameInstanceRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  LeaveGameInstanceResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct LeaveGameInstanceRes::Traits {
  using type = LeaveGameInstanceRes;
  static auto constexpr Create = CreateLeaveGameInstanceRes;
  static constexpr auto name = "LeaveGameInstanceRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LeaveGameInstanceRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SearchGameInstanceCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SearchGameInstanceCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEARCH_KEYWORD = 4,
    VT_ZONE_TABLE_ID = 6
  };
  const ::flatbuffers::String *search_keyword() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEARCH_KEYWORD);
  }
  uint32_t zone_table_id() const {
    return GetField<uint32_t>(VT_ZONE_TABLE_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return search_keyword();
    else if constexpr (Index == 1) return zone_table_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SEARCH_KEYWORD) &&
           verifier.VerifyString(search_keyword()) &&
           VerifyField<uint32_t>(verifier, VT_ZONE_TABLE_ID, 4) &&
           verifier.EndTable();
  }
};

struct SearchGameInstanceCmdBuilder {
  typedef SearchGameInstanceCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_search_keyword(::flatbuffers::Offset<::flatbuffers::String> search_keyword) {
    fbb_.AddOffset(SearchGameInstanceCmd::VT_SEARCH_KEYWORD, search_keyword);
  }
  void add_zone_table_id(uint32_t zone_table_id) {
    fbb_.AddElement<uint32_t>(SearchGameInstanceCmd::VT_ZONE_TABLE_ID, zone_table_id, 0);
  }
  explicit SearchGameInstanceCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SearchGameInstanceCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SearchGameInstanceCmd>(end);
    fbb_.Required(o, SearchGameInstanceCmd::VT_SEARCH_KEYWORD);
    return o;
  }
};

inline ::flatbuffers::Offset<SearchGameInstanceCmd> CreateSearchGameInstanceCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> search_keyword = 0,
    uint32_t zone_table_id = 0) {
  SearchGameInstanceCmdBuilder builder_(_fbb);
  builder_.add_zone_table_id(zone_table_id);
  builder_.add_search_keyword(search_keyword);
  return builder_.Finish();
}

struct SearchGameInstanceCmd::Traits {
  using type = SearchGameInstanceCmd;
  static auto constexpr Create = CreateSearchGameInstanceCmd;
  static constexpr auto name = "SearchGameInstanceCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SearchGameInstanceCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "search_keyword",
    "zone_table_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SearchGameInstanceCmd> CreateSearchGameInstanceCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *search_keyword = nullptr,
    uint32_t zone_table_id = 0) {
  auto search_keyword__ = search_keyword ? _fbb.CreateString(search_keyword) : 0;
  return SF::Flat::Game::CreateSearchGameInstanceCmd(
      _fbb,
      search_keyword__,
      zone_table_id);
}

struct SearchGameInstanceRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SearchGameInstanceResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_GAME_INSTANCES = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *game_instances() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_GAME_INSTANCES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return game_instances();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_GAME_INSTANCES) &&
           verifier.VerifyVector(game_instances()) &&
           verifier.EndTable();
  }
};

struct SearchGameInstanceResBuilder {
  typedef SearchGameInstanceRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SearchGameInstanceRes::VT_RESULT, result, 0);
  }
  void add_game_instances(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_instances) {
    fbb_.AddOffset(SearchGameInstanceRes::VT_GAME_INSTANCES, game_instances);
  }
  explicit SearchGameInstanceResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SearchGameInstanceRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SearchGameInstanceRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SearchGameInstanceRes> CreateSearchGameInstanceRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_instances = 0) {
  SearchGameInstanceResBuilder builder_(_fbb);
  builder_.add_game_instances(game_instances);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SearchGameInstanceRes::Traits {
  using type = SearchGameInstanceRes;
  static auto constexpr Create = CreateSearchGameInstanceRes;
  static constexpr auto name = "SearchGameInstanceRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SearchGameInstanceRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "game_instances"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SearchGameInstanceRes> CreateSearchGameInstanceResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *game_instances = nullptr) {
  auto game_instances__ = game_instances ? _fbb.CreateVector<uint8_t>(*game_instances) : 0;
  return SF::Flat::Game::CreateSearchGameInstanceRes(
      _fbb,
      result,
      game_instances__);
}

struct GetCharacterDataInGameInstanceCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetCharacterDataInGameInstanceCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GAME_INS_UID = 4,
    VT_PLAYER_ID = 6
  };
  uint64_t game_ins_uid() const {
    return GetField<uint64_t>(VT_GAME_INS_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return game_ins_uid();
    else if constexpr (Index == 1) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_GAME_INS_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct GetCharacterDataInGameInstanceCmdBuilder {
  typedef GetCharacterDataInGameInstanceCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_game_ins_uid(uint64_t game_ins_uid) {
    fbb_.AddElement<uint64_t>(GetCharacterDataInGameInstanceCmd::VT_GAME_INS_UID, game_ins_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(GetCharacterDataInGameInstanceCmd::VT_PLAYER_ID, player_id, 0);
  }
  explicit GetCharacterDataInGameInstanceCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetCharacterDataInGameInstanceCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetCharacterDataInGameInstanceCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetCharacterDataInGameInstanceCmd> CreateGetCharacterDataInGameInstanceCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t game_ins_uid = 0,
    uint64_t player_id = 0) {
  GetCharacterDataInGameInstanceCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_game_ins_uid(game_ins_uid);
  return builder_.Finish();
}

struct GetCharacterDataInGameInstanceCmd::Traits {
  using type = GetCharacterDataInGameInstanceCmd;
  static auto constexpr Create = CreateGetCharacterDataInGameInstanceCmd;
  static constexpr auto name = "GetCharacterDataInGameInstanceCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetCharacterDataInGameInstanceCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "game_ins_uid",
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetCharacterDataInGameInstanceRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetCharacterDataInGameInstanceResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAYER_ID = 6,
    VT_GAME_INSTANCES = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *game_instances() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_GAME_INSTANCES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return game_instances();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_GAME_INSTANCES) &&
           verifier.VerifyVector(game_instances()) &&
           verifier.EndTable();
  }
};

struct GetCharacterDataInGameInstanceResBuilder {
  typedef GetCharacterDataInGameInstanceRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetCharacterDataInGameInstanceRes::VT_RESULT, result, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(GetCharacterDataInGameInstanceRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_game_instances(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_instances) {
    fbb_.AddOffset(GetCharacterDataInGameInstanceRes::VT_GAME_INSTANCES, game_instances);
  }
  explicit GetCharacterDataInGameInstanceResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetCharacterDataInGameInstanceRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetCharacterDataInGameInstanceRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetCharacterDataInGameInstanceRes> CreateGetCharacterDataInGameInstanceRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_instances = 0) {
  GetCharacterDataInGameInstanceResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_game_instances(game_instances);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetCharacterDataInGameInstanceRes::Traits {
  using type = GetCharacterDataInGameInstanceRes;
  static auto constexpr Create = CreateGetCharacterDataInGameInstanceRes;
  static constexpr auto name = "GetCharacterDataInGameInstanceRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetCharacterDataInGameInstanceRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "player_id",
    "game_instances"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetCharacterDataInGameInstanceRes> CreateGetCharacterDataInGameInstanceResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *game_instances = nullptr) {
  auto game_instances__ = game_instances ? _fbb.CreateVector<uint8_t>(*game_instances) : 0;
  return SF::Flat::Game::CreateGetCharacterDataInGameInstanceRes(
      _fbb,
      result,
      player_id,
      game_instances__);
}

struct RequestGameMatchCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestGameMatchCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_PLAYER = 4,
    VT_REQUEST_ROLE = 6
  };
  uint8_t num_player() const {
    return GetField<uint8_t>(VT_NUM_PLAYER, 0);
  }
  uint8_t request_role() const {
    return GetField<uint8_t>(VT_REQUEST_ROLE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return num_player();
    else if constexpr (Index == 1) return request_role();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NUM_PLAYER, 1) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_ROLE, 1) &&
           verifier.EndTable();
  }
};

struct RequestGameMatchCmdBuilder {
  typedef RequestGameMatchCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_player(uint8_t num_player) {
    fbb_.AddElement<uint8_t>(RequestGameMatchCmd::VT_NUM_PLAYER, num_player, 0);
  }
  void add_request_role(uint8_t request_role) {
    fbb_.AddElement<uint8_t>(RequestGameMatchCmd::VT_REQUEST_ROLE, request_role, 0);
  }
  explicit RequestGameMatchCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestGameMatchCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestGameMatchCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestGameMatchCmd> CreateRequestGameMatchCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t num_player = 0,
    uint8_t request_role = 0) {
  RequestGameMatchCmdBuilder builder_(_fbb);
  builder_.add_request_role(request_role);
  builder_.add_num_player(num_player);
  return builder_.Finish();
}

struct RequestGameMatchCmd::Traits {
  using type = RequestGameMatchCmd;
  static auto constexpr Create = CreateRequestGameMatchCmd;
  static constexpr auto name = "RequestGameMatchCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestGameMatchCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "num_player",
    "request_role"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RequestGameMatchRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestGameMatchResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_TOTAL_GEM = 6,
    VT_TOTAL_GAME_MONEY = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t total_gem() const {
    return GetField<uint64_t>(VT_TOTAL_GEM, 0);
  }
  uint64_t total_game_money() const {
    return GetField<uint64_t>(VT_TOTAL_GAME_MONEY, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return total_gem();
    else if constexpr (Index == 2) return total_game_money();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_GEM, 8) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_GAME_MONEY, 8) &&
           verifier.EndTable();
  }
};

struct RequestGameMatchResBuilder {
  typedef RequestGameMatchRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RequestGameMatchRes::VT_RESULT, result, 0);
  }
  void add_total_gem(uint64_t total_gem) {
    fbb_.AddElement<uint64_t>(RequestGameMatchRes::VT_TOTAL_GEM, total_gem, 0);
  }
  void add_total_game_money(uint64_t total_game_money) {
    fbb_.AddElement<uint64_t>(RequestGameMatchRes::VT_TOTAL_GAME_MONEY, total_game_money, 0);
  }
  explicit RequestGameMatchResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestGameMatchRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestGameMatchRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestGameMatchRes> CreateRequestGameMatchRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t total_gem = 0,
    uint64_t total_game_money = 0) {
  RequestGameMatchResBuilder builder_(_fbb);
  builder_.add_total_game_money(total_game_money);
  builder_.add_total_gem(total_gem);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RequestGameMatchRes::Traits {
  using type = RequestGameMatchRes;
  static auto constexpr Create = CreateRequestGameMatchRes;
  static constexpr auto name = "RequestGameMatchRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestGameMatchRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "total_gem",
    "total_game_money"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GameMatchedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameMatchedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INS_UID = 4,
    VT_TIME_STAMP = 6,
    VT_GAME_STATE = 8,
    VT_DAY = 10,
    VT_MAX_PLAYER = 12,
    VT_PLAYER_INDEX = 14,
    VT_PLAYER_CHARACTER = 16,
    VT_ROLE = 18,
    VT_DEAD = 20,
    VT_CHAT_HISTORY_DATA = 22,
    VT_GAME_LOG_DATA = 24,
    VT_STAMINA = 26,
    VT_TOTAL_GEM = 28,
    VT_TOTAL_GAME_MONEY = 30
  };
  uint64_t ins_uid() const {
    return GetField<uint64_t>(VT_INS_UID, 0);
  }
  uint32_t time_stamp() const {
    return GetField<uint32_t>(VT_TIME_STAMP, 0);
  }
  SF::Flat::GameStateID game_state() const {
    return static_cast<SF::Flat::GameStateID>(GetField<int8_t>(VT_GAME_STATE, 0));
  }
  uint8_t day() const {
    return GetField<uint8_t>(VT_DAY, 0);
  }
  uint8_t max_player() const {
    return GetField<uint8_t>(VT_MAX_PLAYER, 0);
  }
  uint8_t player_index() const {
    return GetField<uint8_t>(VT_PLAYER_INDEX, 0);
  }
  uint8_t player_character() const {
    return GetField<uint8_t>(VT_PLAYER_CHARACTER, 0);
  }
  uint8_t role() const {
    return GetField<uint8_t>(VT_ROLE, 0);
  }
  uint8_t dead() const {
    return GetField<uint8_t>(VT_DEAD, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_history_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_HISTORY_DATA);
  }
  const ::flatbuffers::Vector<uint8_t> *game_log_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_GAME_LOG_DATA);
  }
  uint32_t stamina() const {
    return GetField<uint32_t>(VT_STAMINA, 0);
  }
  uint64_t total_gem() const {
    return GetField<uint64_t>(VT_TOTAL_GEM, 0);
  }
  uint64_t total_game_money() const {
    return GetField<uint64_t>(VT_TOTAL_GAME_MONEY, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ins_uid();
    else if constexpr (Index == 1) return time_stamp();
    else if constexpr (Index == 2) return game_state();
    else if constexpr (Index == 3) return day();
    else if constexpr (Index == 4) return max_player();
    else if constexpr (Index == 5) return player_index();
    else if constexpr (Index == 6) return player_character();
    else if constexpr (Index == 7) return role();
    else if constexpr (Index == 8) return dead();
    else if constexpr (Index == 9) return chat_history_data();
    else if constexpr (Index == 10) return game_log_data();
    else if constexpr (Index == 11) return stamina();
    else if constexpr (Index == 12) return total_gem();
    else if constexpr (Index == 13) return total_game_money();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INS_UID, 8) &&
           VerifyField<uint32_t>(verifier, VT_TIME_STAMP, 4) &&
           VerifyField<int8_t>(verifier, VT_GAME_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DAY, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAX_PLAYER, 1) &&
           VerifyField<uint8_t>(verifier, VT_PLAYER_INDEX, 1) &&
           VerifyField<uint8_t>(verifier, VT_PLAYER_CHARACTER, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DEAD, 1) &&
           VerifyOffset(verifier, VT_CHAT_HISTORY_DATA) &&
           verifier.VerifyVector(chat_history_data()) &&
           VerifyOffset(verifier, VT_GAME_LOG_DATA) &&
           verifier.VerifyVector(game_log_data()) &&
           VerifyField<uint32_t>(verifier, VT_STAMINA, 4) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_GEM, 8) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_GAME_MONEY, 8) &&
           verifier.EndTable();
  }
};

struct GameMatchedS2CEvtBuilder {
  typedef GameMatchedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ins_uid(uint64_t ins_uid) {
    fbb_.AddElement<uint64_t>(GameMatchedS2CEvt::VT_INS_UID, ins_uid, 0);
  }
  void add_time_stamp(uint32_t time_stamp) {
    fbb_.AddElement<uint32_t>(GameMatchedS2CEvt::VT_TIME_STAMP, time_stamp, 0);
  }
  void add_game_state(SF::Flat::GameStateID game_state) {
    fbb_.AddElement<int8_t>(GameMatchedS2CEvt::VT_GAME_STATE, static_cast<int8_t>(game_state), 0);
  }
  void add_day(uint8_t day) {
    fbb_.AddElement<uint8_t>(GameMatchedS2CEvt::VT_DAY, day, 0);
  }
  void add_max_player(uint8_t max_player) {
    fbb_.AddElement<uint8_t>(GameMatchedS2CEvt::VT_MAX_PLAYER, max_player, 0);
  }
  void add_player_index(uint8_t player_index) {
    fbb_.AddElement<uint8_t>(GameMatchedS2CEvt::VT_PLAYER_INDEX, player_index, 0);
  }
  void add_player_character(uint8_t player_character) {
    fbb_.AddElement<uint8_t>(GameMatchedS2CEvt::VT_PLAYER_CHARACTER, player_character, 0);
  }
  void add_role(uint8_t role) {
    fbb_.AddElement<uint8_t>(GameMatchedS2CEvt::VT_ROLE, role, 0);
  }
  void add_dead(uint8_t dead) {
    fbb_.AddElement<uint8_t>(GameMatchedS2CEvt::VT_DEAD, dead, 0);
  }
  void add_chat_history_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_history_data) {
    fbb_.AddOffset(GameMatchedS2CEvt::VT_CHAT_HISTORY_DATA, chat_history_data);
  }
  void add_game_log_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_log_data) {
    fbb_.AddOffset(GameMatchedS2CEvt::VT_GAME_LOG_DATA, game_log_data);
  }
  void add_stamina(uint32_t stamina) {
    fbb_.AddElement<uint32_t>(GameMatchedS2CEvt::VT_STAMINA, stamina, 0);
  }
  void add_total_gem(uint64_t total_gem) {
    fbb_.AddElement<uint64_t>(GameMatchedS2CEvt::VT_TOTAL_GEM, total_gem, 0);
  }
  void add_total_game_money(uint64_t total_game_money) {
    fbb_.AddElement<uint64_t>(GameMatchedS2CEvt::VT_TOTAL_GAME_MONEY, total_game_money, 0);
  }
  explicit GameMatchedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameMatchedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameMatchedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameMatchedS2CEvt> CreateGameMatchedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ins_uid = 0,
    uint32_t time_stamp = 0,
    SF::Flat::GameStateID game_state = SF::Flat::GameStateID::None,
    uint8_t day = 0,
    uint8_t max_player = 0,
    uint8_t player_index = 0,
    uint8_t player_character = 0,
    uint8_t role = 0,
    uint8_t dead = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_history_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_log_data = 0,
    uint32_t stamina = 0,
    uint64_t total_gem = 0,
    uint64_t total_game_money = 0) {
  GameMatchedS2CEvtBuilder builder_(_fbb);
  builder_.add_total_game_money(total_game_money);
  builder_.add_total_gem(total_gem);
  builder_.add_ins_uid(ins_uid);
  builder_.add_stamina(stamina);
  builder_.add_game_log_data(game_log_data);
  builder_.add_chat_history_data(chat_history_data);
  builder_.add_time_stamp(time_stamp);
  builder_.add_dead(dead);
  builder_.add_role(role);
  builder_.add_player_character(player_character);
  builder_.add_player_index(player_index);
  builder_.add_max_player(max_player);
  builder_.add_day(day);
  builder_.add_game_state(game_state);
  return builder_.Finish();
}

struct GameMatchedS2CEvt::Traits {
  using type = GameMatchedS2CEvt;
  static auto constexpr Create = CreateGameMatchedS2CEvt;
  static constexpr auto name = "GameMatchedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GameMatchedS2CEvt";
  static constexpr size_t fields_number = 14;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ins_uid",
    "time_stamp",
    "game_state",
    "day",
    "max_player",
    "player_index",
    "player_character",
    "role",
    "dead",
    "chat_history_data",
    "game_log_data",
    "stamina",
    "total_gem",
    "total_game_money"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GameMatchedS2CEvt> CreateGameMatchedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ins_uid = 0,
    uint32_t time_stamp = 0,
    SF::Flat::GameStateID game_state = SF::Flat::GameStateID::None,
    uint8_t day = 0,
    uint8_t max_player = 0,
    uint8_t player_index = 0,
    uint8_t player_character = 0,
    uint8_t role = 0,
    uint8_t dead = 0,
    const std::vector<uint8_t> *chat_history_data = nullptr,
    const std::vector<uint8_t> *game_log_data = nullptr,
    uint32_t stamina = 0,
    uint64_t total_gem = 0,
    uint64_t total_game_money = 0) {
  auto chat_history_data__ = chat_history_data ? _fbb.CreateVector<uint8_t>(*chat_history_data) : 0;
  auto game_log_data__ = game_log_data ? _fbb.CreateVector<uint8_t>(*game_log_data) : 0;
  return SF::Flat::Game::CreateGameMatchedS2CEvt(
      _fbb,
      ins_uid,
      time_stamp,
      game_state,
      day,
      max_player,
      player_index,
      player_character,
      role,
      dead,
      chat_history_data__,
      game_log_data__,
      stamina,
      total_gem,
      total_game_money);
}

struct GameMatchFailedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameMatchFailedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FAILED_REASON = 4
  };
  uint32_t failed_reason() const {
    return GetField<uint32_t>(VT_FAILED_REASON, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return failed_reason();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FAILED_REASON, 4) &&
           verifier.EndTable();
  }
};

struct GameMatchFailedS2CEvtBuilder {
  typedef GameMatchFailedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_failed_reason(uint32_t failed_reason) {
    fbb_.AddElement<uint32_t>(GameMatchFailedS2CEvt::VT_FAILED_REASON, failed_reason, 0);
  }
  explicit GameMatchFailedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameMatchFailedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameMatchFailedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameMatchFailedS2CEvt> CreateGameMatchFailedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t failed_reason = 0) {
  GameMatchFailedS2CEvtBuilder builder_(_fbb);
  builder_.add_failed_reason(failed_reason);
  return builder_.Finish();
}

struct GameMatchFailedS2CEvt::Traits {
  using type = GameMatchFailedS2CEvt;
  static auto constexpr Create = CreateGameMatchFailedS2CEvt;
  static constexpr auto name = "GameMatchFailedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GameMatchFailedS2CEvt";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "failed_reason"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GameMatchingStartedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameMatchingStartedS2CEvtBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GameMatchingStartedS2CEvtBuilder {
  typedef GameMatchingStartedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GameMatchingStartedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameMatchingStartedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameMatchingStartedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameMatchingStartedS2CEvt> CreateGameMatchingStartedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GameMatchingStartedS2CEvtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GameMatchingStartedS2CEvt::Traits {
  using type = GameMatchingStartedS2CEvt;
  static auto constexpr Create = CreateGameMatchingStartedS2CEvt;
  static constexpr auto name = "GameMatchingStartedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GameMatchingStartedS2CEvt";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct CancelGameMatchCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CancelGameMatchCmdBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CancelGameMatchCmdBuilder {
  typedef CancelGameMatchCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CancelGameMatchCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CancelGameMatchCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CancelGameMatchCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CancelGameMatchCmd> CreateCancelGameMatchCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CancelGameMatchCmdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CancelGameMatchCmd::Traits {
  using type = CancelGameMatchCmd;
  static auto constexpr Create = CreateCancelGameMatchCmd;
  static constexpr auto name = "CancelGameMatchCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CancelGameMatchCmd";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct CancelGameMatchRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CancelGameMatchResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct CancelGameMatchResBuilder {
  typedef CancelGameMatchRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CancelGameMatchRes::VT_RESULT, result, 0);
  }
  explicit CancelGameMatchResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CancelGameMatchRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CancelGameMatchRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CancelGameMatchRes> CreateCancelGameMatchRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  CancelGameMatchResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CancelGameMatchRes::Traits {
  using type = CancelGameMatchRes;
  static auto constexpr Create = CreateCancelGameMatchRes;
  static constexpr auto name = "CancelGameMatchRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CancelGameMatchRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GameMatchingCanceledS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameMatchingCanceledS2CEvtBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GameMatchingCanceledS2CEvtBuilder {
  typedef GameMatchingCanceledS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GameMatchingCanceledS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameMatchingCanceledS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameMatchingCanceledS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameMatchingCanceledS2CEvt> CreateGameMatchingCanceledS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GameMatchingCanceledS2CEvtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GameMatchingCanceledS2CEvt::Traits {
  using type = GameMatchingCanceledS2CEvt;
  static auto constexpr Create = CreateGameMatchingCanceledS2CEvt;
  static constexpr auto name = "GameMatchingCanceledS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GameMatchingCanceledS2CEvt";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct GetUGCTemplatesCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUGCTemplatesCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAGS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return tags();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           verifier.EndTable();
  }
};

struct GetUGCTemplatesCmdBuilder {
  typedef GetUGCTemplatesCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(GetUGCTemplatesCmd::VT_TAGS, tags);
  }
  explicit GetUGCTemplatesCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUGCTemplatesCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUGCTemplatesCmd>(end);
    fbb_.Required(o, GetUGCTemplatesCmd::VT_TAGS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUGCTemplatesCmd> CreateGetUGCTemplatesCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0) {
  GetUGCTemplatesCmdBuilder builder_(_fbb);
  builder_.add_tags(tags);
  return builder_.Finish();
}

struct GetUGCTemplatesCmd::Traits {
  using type = GetUGCTemplatesCmd;
  static auto constexpr Create = CreateGetUGCTemplatesCmd;
  static constexpr auto name = "GetUGCTemplatesCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetUGCTemplatesCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "tags"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetUGCTemplatesCmd> CreateGetUGCTemplatesCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr) {
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  return SF::Flat::Game::CreateGetUGCTemplatesCmd(
      _fbb,
      tags__);
}

struct GetUGCTemplatesRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUGCTemplatesResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_UGCIDS = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t ugcids() const {
    return GetField<uint64_t>(VT_UGCIDS, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return ugcids();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_UGCIDS, 8) &&
           verifier.EndTable();
  }
};

struct GetUGCTemplatesResBuilder {
  typedef GetUGCTemplatesRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetUGCTemplatesRes::VT_RESULT, result, 0);
  }
  void add_ugcids(uint64_t ugcids) {
    fbb_.AddElement<uint64_t>(GetUGCTemplatesRes::VT_UGCIDS, ugcids, 0);
  }
  explicit GetUGCTemplatesResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUGCTemplatesRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUGCTemplatesRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUGCTemplatesRes> CreateGetUGCTemplatesRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t ugcids = 0) {
  GetUGCTemplatesResBuilder builder_(_fbb);
  builder_.add_ugcids(ugcids);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetUGCTemplatesRes::Traits {
  using type = GetUGCTemplatesRes;
  static auto constexpr Create = CreateGetUGCTemplatesRes;
  static constexpr auto name = "GetUGCTemplatesRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetUGCTemplatesRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "ugcids"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SaveUGCCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SaveUGCCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UGCMETA_DATA = 4,
    VT_UGCCONTENTS = 6
  };
  const ::flatbuffers::Vector<uint8_t> *ugcmeta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_UGCMETA_DATA);
  }
  const ::flatbuffers::Vector<uint8_t> *ugccontents() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_UGCCONTENTS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ugcmeta_data();
    else if constexpr (Index == 1) return ugccontents();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UGCMETA_DATA) &&
           verifier.VerifyVector(ugcmeta_data()) &&
           VerifyOffset(verifier, VT_UGCCONTENTS) &&
           verifier.VerifyVector(ugccontents()) &&
           verifier.EndTable();
  }
};

struct SaveUGCCmdBuilder {
  typedef SaveUGCCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ugcmeta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugcmeta_data) {
    fbb_.AddOffset(SaveUGCCmd::VT_UGCMETA_DATA, ugcmeta_data);
  }
  void add_ugccontents(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugccontents) {
    fbb_.AddOffset(SaveUGCCmd::VT_UGCCONTENTS, ugccontents);
  }
  explicit SaveUGCCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SaveUGCCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SaveUGCCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SaveUGCCmd> CreateSaveUGCCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugcmeta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugccontents = 0) {
  SaveUGCCmdBuilder builder_(_fbb);
  builder_.add_ugccontents(ugccontents);
  builder_.add_ugcmeta_data(ugcmeta_data);
  return builder_.Finish();
}

struct SaveUGCCmd::Traits {
  using type = SaveUGCCmd;
  static auto constexpr Create = CreateSaveUGCCmd;
  static constexpr auto name = "SaveUGCCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SaveUGCCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ugcmeta_data",
    "ugccontents"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SaveUGCCmd> CreateSaveUGCCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *ugcmeta_data = nullptr,
    const std::vector<uint8_t> *ugccontents = nullptr) {
  auto ugcmeta_data__ = ugcmeta_data ? _fbb.CreateVector<uint8_t>(*ugcmeta_data) : 0;
  auto ugccontents__ = ugccontents ? _fbb.CreateVector<uint8_t>(*ugccontents) : 0;
  return SF::Flat::Game::CreateSaveUGCCmd(
      _fbb,
      ugcmeta_data__,
      ugccontents__);
}

struct SaveUGCRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SaveUGCResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_UGCID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t ugcid() const {
    return GetField<uint64_t>(VT_UGCID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return ugcid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_UGCID, 8) &&
           verifier.EndTable();
  }
};

struct SaveUGCResBuilder {
  typedef SaveUGCRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SaveUGCRes::VT_RESULT, result, 0);
  }
  void add_ugcid(uint64_t ugcid) {
    fbb_.AddElement<uint64_t>(SaveUGCRes::VT_UGCID, ugcid, 0);
  }
  explicit SaveUGCResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SaveUGCRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SaveUGCRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SaveUGCRes> CreateSaveUGCRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t ugcid = 0) {
  SaveUGCResBuilder builder_(_fbb);
  builder_.add_ugcid(ugcid);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SaveUGCRes::Traits {
  using type = SaveUGCRes;
  static auto constexpr Create = CreateSaveUGCRes;
  static constexpr auto name = "SaveUGCRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SaveUGCRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "ugcid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SearchUGCCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SearchUGCCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAGS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return tags();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           verifier.EndTable();
  }
};

struct SearchUGCCmdBuilder {
  typedef SearchUGCCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(SearchUGCCmd::VT_TAGS, tags);
  }
  explicit SearchUGCCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SearchUGCCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SearchUGCCmd>(end);
    fbb_.Required(o, SearchUGCCmd::VT_TAGS);
    return o;
  }
};

inline ::flatbuffers::Offset<SearchUGCCmd> CreateSearchUGCCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0) {
  SearchUGCCmdBuilder builder_(_fbb);
  builder_.add_tags(tags);
  return builder_.Finish();
}

struct SearchUGCCmd::Traits {
  using type = SearchUGCCmd;
  static auto constexpr Create = CreateSearchUGCCmd;
  static constexpr auto name = "SearchUGCCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SearchUGCCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "tags"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SearchUGCCmd> CreateSearchUGCCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr) {
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  return SF::Flat::Game::CreateSearchUGCCmd(
      _fbb,
      tags__);
}

struct SearchUGCRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SearchUGCResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct SearchUGCResBuilder {
  typedef SearchUGCRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SearchUGCRes::VT_RESULT, result, 0);
  }
  explicit SearchUGCResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SearchUGCRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SearchUGCRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SearchUGCRes> CreateSearchUGCRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  SearchUGCResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SearchUGCRes::Traits {
  using type = SearchUGCRes;
  static auto constexpr Create = CreateSearchUGCRes;
  static constexpr auto name = "SearchUGCRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SearchUGCRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetUGCContentInfoCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUGCContentInfoCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UGCID = 4
  };
  uint64_t ugcid() const {
    return GetField<uint64_t>(VT_UGCID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ugcid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UGCID, 8) &&
           verifier.EndTable();
  }
};

struct GetUGCContentInfoCmdBuilder {
  typedef GetUGCContentInfoCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ugcid(uint64_t ugcid) {
    fbb_.AddElement<uint64_t>(GetUGCContentInfoCmd::VT_UGCID, ugcid, 0);
  }
  explicit GetUGCContentInfoCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUGCContentInfoCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUGCContentInfoCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUGCContentInfoCmd> CreateGetUGCContentInfoCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ugcid = 0) {
  GetUGCContentInfoCmdBuilder builder_(_fbb);
  builder_.add_ugcid(ugcid);
  return builder_.Finish();
}

struct GetUGCContentInfoCmd::Traits {
  using type = GetUGCContentInfoCmd;
  static auto constexpr Create = CreateGetUGCContentInfoCmd;
  static constexpr auto name = "GetUGCContentInfoCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetUGCContentInfoCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ugcid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetUGCContentInfoRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUGCContentInfoResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_UGCMETA_DATA = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *ugcmeta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_UGCMETA_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return ugcmeta_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_UGCMETA_DATA) &&
           verifier.VerifyVector(ugcmeta_data()) &&
           verifier.EndTable();
  }
};

struct GetUGCContentInfoResBuilder {
  typedef GetUGCContentInfoRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetUGCContentInfoRes::VT_RESULT, result, 0);
  }
  void add_ugcmeta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugcmeta_data) {
    fbb_.AddOffset(GetUGCContentInfoRes::VT_UGCMETA_DATA, ugcmeta_data);
  }
  explicit GetUGCContentInfoResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUGCContentInfoRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUGCContentInfoRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUGCContentInfoRes> CreateGetUGCContentInfoRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugcmeta_data = 0) {
  GetUGCContentInfoResBuilder builder_(_fbb);
  builder_.add_ugcmeta_data(ugcmeta_data);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetUGCContentInfoRes::Traits {
  using type = GetUGCContentInfoRes;
  static auto constexpr Create = CreateGetUGCContentInfoRes;
  static constexpr auto name = "GetUGCContentInfoRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetUGCContentInfoRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "ugcmeta_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetUGCContentInfoRes> CreateGetUGCContentInfoResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *ugcmeta_data = nullptr) {
  auto ugcmeta_data__ = ugcmeta_data ? _fbb.CreateVector<uint8_t>(*ugcmeta_data) : 0;
  return SF::Flat::Game::CreateGetUGCContentInfoRes(
      _fbb,
      result,
      ugcmeta_data__);
}

struct DownloadUGCContentCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DownloadUGCContentCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UGCID = 4,
    VT_IS_INCLUDE_META_DATA = 6
  };
  uint64_t ugcid() const {
    return GetField<uint64_t>(VT_UGCID, 0);
  }
  uint8_t is_include_meta_data() const {
    return GetField<uint8_t>(VT_IS_INCLUDE_META_DATA, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ugcid();
    else if constexpr (Index == 1) return is_include_meta_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UGCID, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_INCLUDE_META_DATA, 1) &&
           verifier.EndTable();
  }
};

struct DownloadUGCContentCmdBuilder {
  typedef DownloadUGCContentCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ugcid(uint64_t ugcid) {
    fbb_.AddElement<uint64_t>(DownloadUGCContentCmd::VT_UGCID, ugcid, 0);
  }
  void add_is_include_meta_data(uint8_t is_include_meta_data) {
    fbb_.AddElement<uint8_t>(DownloadUGCContentCmd::VT_IS_INCLUDE_META_DATA, is_include_meta_data, 0);
  }
  explicit DownloadUGCContentCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DownloadUGCContentCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DownloadUGCContentCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DownloadUGCContentCmd> CreateDownloadUGCContentCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ugcid = 0,
    uint8_t is_include_meta_data = 0) {
  DownloadUGCContentCmdBuilder builder_(_fbb);
  builder_.add_ugcid(ugcid);
  builder_.add_is_include_meta_data(is_include_meta_data);
  return builder_.Finish();
}

struct DownloadUGCContentCmd::Traits {
  using type = DownloadUGCContentCmd;
  static auto constexpr Create = CreateDownloadUGCContentCmd;
  static constexpr auto name = "DownloadUGCContentCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.DownloadUGCContentCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ugcid",
    "is_include_meta_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct DownloadUGCContentRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DownloadUGCContentResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_UGCMETA_DATA = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *ugcmeta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_UGCMETA_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return ugcmeta_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_UGCMETA_DATA) &&
           verifier.VerifyVector(ugcmeta_data()) &&
           verifier.EndTable();
  }
};

struct DownloadUGCContentResBuilder {
  typedef DownloadUGCContentRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(DownloadUGCContentRes::VT_RESULT, result, 0);
  }
  void add_ugcmeta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugcmeta_data) {
    fbb_.AddOffset(DownloadUGCContentRes::VT_UGCMETA_DATA, ugcmeta_data);
  }
  explicit DownloadUGCContentResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DownloadUGCContentRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DownloadUGCContentRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DownloadUGCContentRes> CreateDownloadUGCContentRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ugcmeta_data = 0) {
  DownloadUGCContentResBuilder builder_(_fbb);
  builder_.add_ugcmeta_data(ugcmeta_data);
  builder_.add_result(result);
  return builder_.Finish();
}

struct DownloadUGCContentRes::Traits {
  using type = DownloadUGCContentRes;
  static auto constexpr Create = CreateDownloadUGCContentRes;
  static constexpr auto name = "DownloadUGCContentRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.DownloadUGCContentRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "ugcmeta_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DownloadUGCContentRes> CreateDownloadUGCContentResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *ugcmeta_data = nullptr) {
  auto ugcmeta_data__ = ugcmeta_data ? _fbb.CreateVector<uint8_t>(*ugcmeta_data) : 0;
  return SF::Flat::Game::CreateDownloadUGCContentRes(
      _fbb,
      result,
      ugcmeta_data__);
}

struct RequestUGCZoneInstanceCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestUGCZoneInstanceCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UGCID = 4
  };
  uint64_t ugcid() const {
    return GetField<uint64_t>(VT_UGCID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ugcid();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UGCID, 8) &&
           verifier.EndTable();
  }
};

struct RequestUGCZoneInstanceCmdBuilder {
  typedef RequestUGCZoneInstanceCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ugcid(uint64_t ugcid) {
    fbb_.AddElement<uint64_t>(RequestUGCZoneInstanceCmd::VT_UGCID, ugcid, 0);
  }
  explicit RequestUGCZoneInstanceCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestUGCZoneInstanceCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestUGCZoneInstanceCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestUGCZoneInstanceCmd> CreateRequestUGCZoneInstanceCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ugcid = 0) {
  RequestUGCZoneInstanceCmdBuilder builder_(_fbb);
  builder_.add_ugcid(ugcid);
  return builder_.Finish();
}

struct RequestUGCZoneInstanceCmd::Traits {
  using type = RequestUGCZoneInstanceCmd;
  static auto constexpr Create = CreateRequestUGCZoneInstanceCmd;
  static constexpr auto name = "RequestUGCZoneInstanceCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestUGCZoneInstanceCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ugcid"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RequestUGCZoneInstanceRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestUGCZoneInstanceResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_GAME_INSTANCE = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *game_instance() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_GAME_INSTANCE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return game_instance();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_GAME_INSTANCE) &&
           verifier.VerifyVector(game_instance()) &&
           verifier.EndTable();
  }
};

struct RequestUGCZoneInstanceResBuilder {
  typedef RequestUGCZoneInstanceRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RequestUGCZoneInstanceRes::VT_RESULT, result, 0);
  }
  void add_game_instance(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_instance) {
    fbb_.AddOffset(RequestUGCZoneInstanceRes::VT_GAME_INSTANCE, game_instance);
  }
  explicit RequestUGCZoneInstanceResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestUGCZoneInstanceRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestUGCZoneInstanceRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestUGCZoneInstanceRes> CreateRequestUGCZoneInstanceRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> game_instance = 0) {
  RequestUGCZoneInstanceResBuilder builder_(_fbb);
  builder_.add_game_instance(game_instance);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RequestUGCZoneInstanceRes::Traits {
  using type = RequestUGCZoneInstanceRes;
  static auto constexpr Create = CreateRequestUGCZoneInstanceRes;
  static constexpr auto name = "RequestUGCZoneInstanceRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestUGCZoneInstanceRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "game_instance"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RequestUGCZoneInstanceRes> CreateRequestUGCZoneInstanceResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *game_instance = nullptr) {
  auto game_instance__ = game_instance ? _fbb.CreateVector<uint8_t>(*game_instance) : 0;
  return SF::Flat::Game::CreateRequestUGCZoneInstanceRes(
      _fbb,
      result,
      game_instance__);
}

struct BuyShopItemPrepareCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BuyShopItemPrepareCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOP_ITEM_ID = 4
  };
  uint32_t shop_item_id() const {
    return GetField<uint32_t>(VT_SHOP_ITEM_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return shop_item_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SHOP_ITEM_ID, 4) &&
           verifier.EndTable();
  }
};

struct BuyShopItemPrepareCmdBuilder {
  typedef BuyShopItemPrepareCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shop_item_id(uint32_t shop_item_id) {
    fbb_.AddElement<uint32_t>(BuyShopItemPrepareCmd::VT_SHOP_ITEM_ID, shop_item_id, 0);
  }
  explicit BuyShopItemPrepareCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BuyShopItemPrepareCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BuyShopItemPrepareCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BuyShopItemPrepareCmd> CreateBuyShopItemPrepareCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shop_item_id = 0) {
  BuyShopItemPrepareCmdBuilder builder_(_fbb);
  builder_.add_shop_item_id(shop_item_id);
  return builder_.Finish();
}

struct BuyShopItemPrepareCmd::Traits {
  using type = BuyShopItemPrepareCmd;
  static auto constexpr Create = CreateBuyShopItemPrepareCmd;
  static constexpr auto name = "BuyShopItemPrepareCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.BuyShopItemPrepareCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "shop_item_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct BuyShopItemPrepareRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BuyShopItemPrepareResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_SHOP_ITEM_ID = 6,
    VT_PURCHASE_ID = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t shop_item_id() const {
    return GetField<uint32_t>(VT_SHOP_ITEM_ID, 0);
  }
  const ::flatbuffers::String *purchase_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PURCHASE_ID);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return shop_item_id();
    else if constexpr (Index == 2) return purchase_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_SHOP_ITEM_ID, 4) &&
           VerifyOffsetRequired(verifier, VT_PURCHASE_ID) &&
           verifier.VerifyString(purchase_id()) &&
           verifier.EndTable();
  }
};

struct BuyShopItemPrepareResBuilder {
  typedef BuyShopItemPrepareRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(BuyShopItemPrepareRes::VT_RESULT, result, 0);
  }
  void add_shop_item_id(uint32_t shop_item_id) {
    fbb_.AddElement<uint32_t>(BuyShopItemPrepareRes::VT_SHOP_ITEM_ID, shop_item_id, 0);
  }
  void add_purchase_id(::flatbuffers::Offset<::flatbuffers::String> purchase_id) {
    fbb_.AddOffset(BuyShopItemPrepareRes::VT_PURCHASE_ID, purchase_id);
  }
  explicit BuyShopItemPrepareResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BuyShopItemPrepareRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BuyShopItemPrepareRes>(end);
    fbb_.Required(o, BuyShopItemPrepareRes::VT_PURCHASE_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<BuyShopItemPrepareRes> CreateBuyShopItemPrepareRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t shop_item_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> purchase_id = 0) {
  BuyShopItemPrepareResBuilder builder_(_fbb);
  builder_.add_purchase_id(purchase_id);
  builder_.add_shop_item_id(shop_item_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct BuyShopItemPrepareRes::Traits {
  using type = BuyShopItemPrepareRes;
  static auto constexpr Create = CreateBuyShopItemPrepareRes;
  static constexpr auto name = "BuyShopItemPrepareRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.BuyShopItemPrepareRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "shop_item_id",
    "purchase_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<BuyShopItemPrepareRes> CreateBuyShopItemPrepareResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t shop_item_id = 0,
    const char *purchase_id = nullptr) {
  auto purchase_id__ = purchase_id ? _fbb.CreateString(purchase_id) : 0;
  return SF::Flat::Game::CreateBuyShopItemPrepareRes(
      _fbb,
      result,
      shop_item_id,
      purchase_id__);
}

struct BuyShopItemCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BuyShopItemCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOP_ITEM_ID = 4,
    VT_PLATFORM = 6,
    VT_PACKAGE_NAME = 8,
    VT_PURCHASE_TRANSACTION_ID = 10,
    VT_PURCHASE_TOKEN = 12
  };
  uint32_t shop_item_id() const {
    return GetField<uint32_t>(VT_SHOP_ITEM_ID, 0);
  }
  const ::flatbuffers::String *platform() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLATFORM);
  }
  const ::flatbuffers::String *package_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PACKAGE_NAME);
  }
  const ::flatbuffers::String *purchase_transaction_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PURCHASE_TRANSACTION_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *purchase_token() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PURCHASE_TOKEN);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return shop_item_id();
    else if constexpr (Index == 1) return platform();
    else if constexpr (Index == 2) return package_name();
    else if constexpr (Index == 3) return purchase_transaction_id();
    else if constexpr (Index == 4) return purchase_token();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SHOP_ITEM_ID, 4) &&
           VerifyOffsetRequired(verifier, VT_PLATFORM) &&
           verifier.VerifyString(platform()) &&
           VerifyOffsetRequired(verifier, VT_PACKAGE_NAME) &&
           verifier.VerifyString(package_name()) &&
           VerifyOffsetRequired(verifier, VT_PURCHASE_TRANSACTION_ID) &&
           verifier.VerifyString(purchase_transaction_id()) &&
           VerifyOffset(verifier, VT_PURCHASE_TOKEN) &&
           verifier.VerifyVector(purchase_token()) &&
           verifier.EndTable();
  }
};

struct BuyShopItemCmdBuilder {
  typedef BuyShopItemCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shop_item_id(uint32_t shop_item_id) {
    fbb_.AddElement<uint32_t>(BuyShopItemCmd::VT_SHOP_ITEM_ID, shop_item_id, 0);
  }
  void add_platform(::flatbuffers::Offset<::flatbuffers::String> platform) {
    fbb_.AddOffset(BuyShopItemCmd::VT_PLATFORM, platform);
  }
  void add_package_name(::flatbuffers::Offset<::flatbuffers::String> package_name) {
    fbb_.AddOffset(BuyShopItemCmd::VT_PACKAGE_NAME, package_name);
  }
  void add_purchase_transaction_id(::flatbuffers::Offset<::flatbuffers::String> purchase_transaction_id) {
    fbb_.AddOffset(BuyShopItemCmd::VT_PURCHASE_TRANSACTION_ID, purchase_transaction_id);
  }
  void add_purchase_token(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> purchase_token) {
    fbb_.AddOffset(BuyShopItemCmd::VT_PURCHASE_TOKEN, purchase_token);
  }
  explicit BuyShopItemCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BuyShopItemCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BuyShopItemCmd>(end);
    fbb_.Required(o, BuyShopItemCmd::VT_PLATFORM);
    fbb_.Required(o, BuyShopItemCmd::VT_PACKAGE_NAME);
    fbb_.Required(o, BuyShopItemCmd::VT_PURCHASE_TRANSACTION_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<BuyShopItemCmd> CreateBuyShopItemCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shop_item_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> platform = 0,
    ::flatbuffers::Offset<::flatbuffers::String> package_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> purchase_transaction_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> purchase_token = 0) {
  BuyShopItemCmdBuilder builder_(_fbb);
  builder_.add_purchase_token(purchase_token);
  builder_.add_purchase_transaction_id(purchase_transaction_id);
  builder_.add_package_name(package_name);
  builder_.add_platform(platform);
  builder_.add_shop_item_id(shop_item_id);
  return builder_.Finish();
}

struct BuyShopItemCmd::Traits {
  using type = BuyShopItemCmd;
  static auto constexpr Create = CreateBuyShopItemCmd;
  static constexpr auto name = "BuyShopItemCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.BuyShopItemCmd";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "shop_item_id",
    "platform",
    "package_name",
    "purchase_transaction_id",
    "purchase_token"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<BuyShopItemCmd> CreateBuyShopItemCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shop_item_id = 0,
    const char *platform = nullptr,
    const char *package_name = nullptr,
    const char *purchase_transaction_id = nullptr,
    const std::vector<uint8_t> *purchase_token = nullptr) {
  auto platform__ = platform ? _fbb.CreateString(platform) : 0;
  auto package_name__ = package_name ? _fbb.CreateString(package_name) : 0;
  auto purchase_transaction_id__ = purchase_transaction_id ? _fbb.CreateString(purchase_transaction_id) : 0;
  auto purchase_token__ = purchase_token ? _fbb.CreateVector<uint8_t>(*purchase_token) : 0;
  return SF::Flat::Game::CreateBuyShopItemCmd(
      _fbb,
      shop_item_id,
      platform__,
      package_name__,
      purchase_transaction_id__,
      purchase_token__);
}

struct BuyShopItemRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BuyShopItemResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_SHOP_ITEM_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t shop_item_id() const {
    return GetField<uint32_t>(VT_SHOP_ITEM_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return shop_item_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_SHOP_ITEM_ID, 4) &&
           verifier.EndTable();
  }
};

struct BuyShopItemResBuilder {
  typedef BuyShopItemRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(BuyShopItemRes::VT_RESULT, result, 0);
  }
  void add_shop_item_id(uint32_t shop_item_id) {
    fbb_.AddElement<uint32_t>(BuyShopItemRes::VT_SHOP_ITEM_ID, shop_item_id, 0);
  }
  explicit BuyShopItemResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BuyShopItemRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BuyShopItemRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BuyShopItemRes> CreateBuyShopItemRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t shop_item_id = 0) {
  BuyShopItemResBuilder builder_(_fbb);
  builder_.add_shop_item_id(shop_item_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct BuyShopItemRes::Traits {
  using type = BuyShopItemRes;
  static auto constexpr Create = CreateBuyShopItemRes;
  static constexpr auto name = "BuyShopItemRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.BuyShopItemRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "shop_item_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CreateOrJoinChatChannelCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateOrJoinChatChannelCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNEL_NAME = 4,
    VT_PASSCODE = 6
  };
  const ::flatbuffers::String *channel_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHANNEL_NAME);
  }
  const ::flatbuffers::String *passcode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSCODE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return channel_name();
    else if constexpr (Index == 1) return passcode();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHANNEL_NAME) &&
           verifier.VerifyString(channel_name()) &&
           VerifyOffsetRequired(verifier, VT_PASSCODE) &&
           verifier.VerifyString(passcode()) &&
           verifier.EndTable();
  }
};

struct CreateOrJoinChatChannelCmdBuilder {
  typedef CreateOrJoinChatChannelCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_channel_name(::flatbuffers::Offset<::flatbuffers::String> channel_name) {
    fbb_.AddOffset(CreateOrJoinChatChannelCmd::VT_CHANNEL_NAME, channel_name);
  }
  void add_passcode(::flatbuffers::Offset<::flatbuffers::String> passcode) {
    fbb_.AddOffset(CreateOrJoinChatChannelCmd::VT_PASSCODE, passcode);
  }
  explicit CreateOrJoinChatChannelCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateOrJoinChatChannelCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateOrJoinChatChannelCmd>(end);
    fbb_.Required(o, CreateOrJoinChatChannelCmd::VT_CHANNEL_NAME);
    fbb_.Required(o, CreateOrJoinChatChannelCmd::VT_PASSCODE);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateOrJoinChatChannelCmd> CreateCreateOrJoinChatChannelCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> channel_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> passcode = 0) {
  CreateOrJoinChatChannelCmdBuilder builder_(_fbb);
  builder_.add_passcode(passcode);
  builder_.add_channel_name(channel_name);
  return builder_.Finish();
}

struct CreateOrJoinChatChannelCmd::Traits {
  using type = CreateOrJoinChatChannelCmd;
  static auto constexpr Create = CreateCreateOrJoinChatChannelCmd;
  static constexpr auto name = "CreateOrJoinChatChannelCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CreateOrJoinChatChannelCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "channel_name",
    "passcode"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CreateOrJoinChatChannelCmd> CreateCreateOrJoinChatChannelCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel_name = nullptr,
    const char *passcode = nullptr) {
  auto channel_name__ = channel_name ? _fbb.CreateString(channel_name) : 0;
  auto passcode__ = passcode ? _fbb.CreateString(passcode) : 0;
  return SF::Flat::Game::CreateCreateOrJoinChatChannelCmd(
      _fbb,
      channel_name__,
      passcode__);
}

struct CreateOrJoinChatChannelRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateOrJoinChatChannelResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_CHAT_UID = 6,
    VT_CHANNEL_LEADER_ID = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t channel_leader_id() const {
    return GetField<uint64_t>(VT_CHANNEL_LEADER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return chat_uid();
    else if constexpr (Index == 2) return channel_leader_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_CHANNEL_LEADER_ID, 8) &&
           verifier.EndTable();
  }
};

struct CreateOrJoinChatChannelResBuilder {
  typedef CreateOrJoinChatChannelRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CreateOrJoinChatChannelRes::VT_RESULT, result, 0);
  }
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(CreateOrJoinChatChannelRes::VT_CHAT_UID, chat_uid, 0);
  }
  void add_channel_leader_id(uint64_t channel_leader_id) {
    fbb_.AddElement<uint64_t>(CreateOrJoinChatChannelRes::VT_CHANNEL_LEADER_ID, channel_leader_id, 0);
  }
  explicit CreateOrJoinChatChannelResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateOrJoinChatChannelRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateOrJoinChatChannelRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateOrJoinChatChannelRes> CreateCreateOrJoinChatChannelRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t chat_uid = 0,
    uint64_t channel_leader_id = 0) {
  CreateOrJoinChatChannelResBuilder builder_(_fbb);
  builder_.add_channel_leader_id(channel_leader_id);
  builder_.add_chat_uid(chat_uid);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CreateOrJoinChatChannelRes::Traits {
  using type = CreateOrJoinChatChannelRes;
  static auto constexpr Create = CreateCreateOrJoinChatChannelRes;
  static constexpr auto name = "CreateOrJoinChatChannelRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CreateOrJoinChatChannelRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "chat_uid",
    "channel_leader_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct JoinChatChannelCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinChatChannelCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_INVITER_ID = 6,
    VT_PASSCODE = 8
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t inviter_id() const {
    return GetField<uint64_t>(VT_INVITER_ID, 0);
  }
  const ::flatbuffers::String *passcode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSCODE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return inviter_id();
    else if constexpr (Index == 2) return passcode();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_INVITER_ID, 8) &&
           VerifyOffsetRequired(verifier, VT_PASSCODE) &&
           verifier.VerifyString(passcode()) &&
           verifier.EndTable();
  }
};

struct JoinChatChannelCmdBuilder {
  typedef JoinChatChannelCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(JoinChatChannelCmd::VT_CHAT_UID, chat_uid, 0);
  }
  void add_inviter_id(uint64_t inviter_id) {
    fbb_.AddElement<uint64_t>(JoinChatChannelCmd::VT_INVITER_ID, inviter_id, 0);
  }
  void add_passcode(::flatbuffers::Offset<::flatbuffers::String> passcode) {
    fbb_.AddOffset(JoinChatChannelCmd::VT_PASSCODE, passcode);
  }
  explicit JoinChatChannelCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinChatChannelCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinChatChannelCmd>(end);
    fbb_.Required(o, JoinChatChannelCmd::VT_PASSCODE);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinChatChannelCmd> CreateJoinChatChannelCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t inviter_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> passcode = 0) {
  JoinChatChannelCmdBuilder builder_(_fbb);
  builder_.add_inviter_id(inviter_id);
  builder_.add_chat_uid(chat_uid);
  builder_.add_passcode(passcode);
  return builder_.Finish();
}

struct JoinChatChannelCmd::Traits {
  using type = JoinChatChannelCmd;
  static auto constexpr Create = CreateJoinChatChannelCmd;
  static constexpr auto name = "JoinChatChannelCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinChatChannelCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "inviter_id",
    "passcode"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<JoinChatChannelCmd> CreateJoinChatChannelCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t inviter_id = 0,
    const char *passcode = nullptr) {
  auto passcode__ = passcode ? _fbb.CreateString(passcode) : 0;
  return SF::Flat::Game::CreateJoinChatChannelCmd(
      _fbb,
      chat_uid,
      inviter_id,
      passcode__);
}

struct JoinChatChannelRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinChatChannelResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_CHAT_UID = 6,
    VT_CHANNEL_LEADER_ID = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t channel_leader_id() const {
    return GetField<uint64_t>(VT_CHANNEL_LEADER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return chat_uid();
    else if constexpr (Index == 2) return channel_leader_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_CHANNEL_LEADER_ID, 8) &&
           verifier.EndTable();
  }
};

struct JoinChatChannelResBuilder {
  typedef JoinChatChannelRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(JoinChatChannelRes::VT_RESULT, result, 0);
  }
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(JoinChatChannelRes::VT_CHAT_UID, chat_uid, 0);
  }
  void add_channel_leader_id(uint64_t channel_leader_id) {
    fbb_.AddElement<uint64_t>(JoinChatChannelRes::VT_CHANNEL_LEADER_ID, channel_leader_id, 0);
  }
  explicit JoinChatChannelResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinChatChannelRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinChatChannelRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinChatChannelRes> CreateJoinChatChannelRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t chat_uid = 0,
    uint64_t channel_leader_id = 0) {
  JoinChatChannelResBuilder builder_(_fbb);
  builder_.add_channel_leader_id(channel_leader_id);
  builder_.add_chat_uid(chat_uid);
  builder_.add_result(result);
  return builder_.Finish();
}

struct JoinChatChannelRes::Traits {
  using type = JoinChatChannelRes;
  static auto constexpr Create = CreateJoinChatChannelRes;
  static constexpr auto name = "JoinChatChannelRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.JoinChatChannelRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "chat_uid",
    "channel_leader_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelPlayerJoinedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelPlayerJoinedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_JOINED_PLAYER = 6
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  const SF::Flat::PlayerInformation *joined_player() const {
    return GetPointer<const SF::Flat::PlayerInformation *>(VT_JOINED_PLAYER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return joined_player();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyOffsetRequired(verifier, VT_JOINED_PLAYER) &&
           verifier.VerifyTable(joined_player()) &&
           verifier.EndTable();
  }
};

struct ChatChannelPlayerJoinedS2CEvtBuilder {
  typedef ChatChannelPlayerJoinedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(ChatChannelPlayerJoinedS2CEvt::VT_CHAT_UID, chat_uid, 0);
  }
  void add_joined_player(::flatbuffers::Offset<SF::Flat::PlayerInformation> joined_player) {
    fbb_.AddOffset(ChatChannelPlayerJoinedS2CEvt::VT_JOINED_PLAYER, joined_player);
  }
  explicit ChatChannelPlayerJoinedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelPlayerJoinedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelPlayerJoinedS2CEvt>(end);
    fbb_.Required(o, ChatChannelPlayerJoinedS2CEvt::VT_JOINED_PLAYER);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelPlayerJoinedS2CEvt> CreateChatChannelPlayerJoinedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    ::flatbuffers::Offset<SF::Flat::PlayerInformation> joined_player = 0) {
  ChatChannelPlayerJoinedS2CEvtBuilder builder_(_fbb);
  builder_.add_chat_uid(chat_uid);
  builder_.add_joined_player(joined_player);
  return builder_.Finish();
}

struct ChatChannelPlayerJoinedS2CEvt::Traits {
  using type = ChatChannelPlayerJoinedS2CEvt;
  static auto constexpr Create = CreateChatChannelPlayerJoinedS2CEvt;
  static constexpr auto name = "ChatChannelPlayerJoinedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelPlayerJoinedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "joined_player"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelLeaderChangedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelLeaderChangedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_NEW_LEADER_ID = 6
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t new_leader_id() const {
    return GetField<uint64_t>(VT_NEW_LEADER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return new_leader_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_NEW_LEADER_ID, 8) &&
           verifier.EndTable();
  }
};

struct ChatChannelLeaderChangedS2CEvtBuilder {
  typedef ChatChannelLeaderChangedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(ChatChannelLeaderChangedS2CEvt::VT_CHAT_UID, chat_uid, 0);
  }
  void add_new_leader_id(uint64_t new_leader_id) {
    fbb_.AddElement<uint64_t>(ChatChannelLeaderChangedS2CEvt::VT_NEW_LEADER_ID, new_leader_id, 0);
  }
  explicit ChatChannelLeaderChangedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelLeaderChangedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelLeaderChangedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelLeaderChangedS2CEvt> CreateChatChannelLeaderChangedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t new_leader_id = 0) {
  ChatChannelLeaderChangedS2CEvtBuilder builder_(_fbb);
  builder_.add_new_leader_id(new_leader_id);
  builder_.add_chat_uid(chat_uid);
  return builder_.Finish();
}

struct ChatChannelLeaderChangedS2CEvt::Traits {
  using type = ChatChannelLeaderChangedS2CEvt;
  static auto constexpr Create = CreateChatChannelLeaderChangedS2CEvt;
  static constexpr auto name = "ChatChannelLeaderChangedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelLeaderChangedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "new_leader_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct LeaveChatChannelCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaveChatChannelCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_PLAYER_ID = 6
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct LeaveChatChannelCmdBuilder {
  typedef LeaveChatChannelCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(LeaveChatChannelCmd::VT_CHAT_UID, chat_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(LeaveChatChannelCmd::VT_PLAYER_ID, player_id, 0);
  }
  explicit LeaveChatChannelCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaveChatChannelCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaveChatChannelCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaveChatChannelCmd> CreateLeaveChatChannelCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t player_id = 0) {
  LeaveChatChannelCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_chat_uid(chat_uid);
  return builder_.Finish();
}

struct LeaveChatChannelCmd::Traits {
  using type = LeaveChatChannelCmd;
  static auto constexpr Create = CreateLeaveChatChannelCmd;
  static constexpr auto name = "LeaveChatChannelCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LeaveChatChannelCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct LeaveChatChannelRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaveChatChannelResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct LeaveChatChannelResBuilder {
  typedef LeaveChatChannelRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(LeaveChatChannelRes::VT_RESULT, result, 0);
  }
  explicit LeaveChatChannelResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaveChatChannelRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaveChatChannelRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaveChatChannelRes> CreateLeaveChatChannelRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  LeaveChatChannelResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct LeaveChatChannelRes::Traits {
  using type = LeaveChatChannelRes;
  static auto constexpr Create = CreateLeaveChatChannelRes;
  static constexpr auto name = "LeaveChatChannelRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.LeaveChatChannelRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelPlayerLeftS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelPlayerLeftS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_LEFT_PLAYER_ID = 6
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t left_player_id() const {
    return GetField<uint64_t>(VT_LEFT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return left_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_LEFT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct ChatChannelPlayerLeftS2CEvtBuilder {
  typedef ChatChannelPlayerLeftS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(ChatChannelPlayerLeftS2CEvt::VT_CHAT_UID, chat_uid, 0);
  }
  void add_left_player_id(uint64_t left_player_id) {
    fbb_.AddElement<uint64_t>(ChatChannelPlayerLeftS2CEvt::VT_LEFT_PLAYER_ID, left_player_id, 0);
  }
  explicit ChatChannelPlayerLeftS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelPlayerLeftS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelPlayerLeftS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelPlayerLeftS2CEvt> CreateChatChannelPlayerLeftS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t left_player_id = 0) {
  ChatChannelPlayerLeftS2CEvtBuilder builder_(_fbb);
  builder_.add_left_player_id(left_player_id);
  builder_.add_chat_uid(chat_uid);
  return builder_.Finish();
}

struct ChatChannelPlayerLeftS2CEvt::Traits {
  using type = ChatChannelPlayerLeftS2CEvt;
  static auto constexpr Create = CreateChatChannelPlayerLeftS2CEvt;
  static constexpr auto name = "ChatChannelPlayerLeftS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelPlayerLeftS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "left_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelKickPlayerCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelKickPlayerCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_PLAYER_ID = 6,
    VT_PLAYER_TO_KICK = 8
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t player_to_kick() const {
    return GetField<uint64_t>(VT_PLAYER_TO_KICK, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return player_to_kick();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_TO_KICK, 8) &&
           verifier.EndTable();
  }
};

struct ChatChannelKickPlayerCmdBuilder {
  typedef ChatChannelKickPlayerCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(ChatChannelKickPlayerCmd::VT_CHAT_UID, chat_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(ChatChannelKickPlayerCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_to_kick(uint64_t player_to_kick) {
    fbb_.AddElement<uint64_t>(ChatChannelKickPlayerCmd::VT_PLAYER_TO_KICK, player_to_kick, 0);
  }
  explicit ChatChannelKickPlayerCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelKickPlayerCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelKickPlayerCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelKickPlayerCmd> CreateChatChannelKickPlayerCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t player_id = 0,
    uint64_t player_to_kick = 0) {
  ChatChannelKickPlayerCmdBuilder builder_(_fbb);
  builder_.add_player_to_kick(player_to_kick);
  builder_.add_player_id(player_id);
  builder_.add_chat_uid(chat_uid);
  return builder_.Finish();
}

struct ChatChannelKickPlayerCmd::Traits {
  using type = ChatChannelKickPlayerCmd;
  static auto constexpr Create = CreateChatChannelKickPlayerCmd;
  static constexpr auto name = "ChatChannelKickPlayerCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelKickPlayerCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "player_id",
    "player_to_kick"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelKickPlayerRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelKickPlayerResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct ChatChannelKickPlayerResBuilder {
  typedef ChatChannelKickPlayerRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(ChatChannelKickPlayerRes::VT_RESULT, result, 0);
  }
  explicit ChatChannelKickPlayerResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelKickPlayerRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelKickPlayerRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelKickPlayerRes> CreateChatChannelKickPlayerRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  ChatChannelKickPlayerResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct ChatChannelKickPlayerRes::Traits {
  using type = ChatChannelKickPlayerRes;
  static auto constexpr Create = CreateChatChannelKickPlayerRes;
  static constexpr auto name = "ChatChannelKickPlayerRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelKickPlayerRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelPlayerKickedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelPlayerKickedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_KICKED_PLAYER_ID = 6
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  uint64_t kicked_player_id() const {
    return GetField<uint64_t>(VT_KICKED_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return kicked_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_KICKED_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct ChatChannelPlayerKickedS2CEvtBuilder {
  typedef ChatChannelPlayerKickedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(ChatChannelPlayerKickedS2CEvt::VT_CHAT_UID, chat_uid, 0);
  }
  void add_kicked_player_id(uint64_t kicked_player_id) {
    fbb_.AddElement<uint64_t>(ChatChannelPlayerKickedS2CEvt::VT_KICKED_PLAYER_ID, kicked_player_id, 0);
  }
  explicit ChatChannelPlayerKickedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelPlayerKickedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelPlayerKickedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelPlayerKickedS2CEvt> CreateChatChannelPlayerKickedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    uint64_t kicked_player_id = 0) {
  ChatChannelPlayerKickedS2CEvtBuilder builder_(_fbb);
  builder_.add_kicked_player_id(kicked_player_id);
  builder_.add_chat_uid(chat_uid);
  return builder_.Finish();
}

struct ChatChannelPlayerKickedS2CEvt::Traits {
  using type = ChatChannelPlayerKickedS2CEvt;
  static auto constexpr Create = CreateChatChannelPlayerKickedS2CEvt;
  static constexpr auto name = "ChatChannelPlayerKickedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelPlayerKickedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "kicked_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelChatMessageCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelChatMessageCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAT_UID = 4,
    VT_CHAT_META_DATA = 6,
    VT_CHAT_MESSAGE = 8
  };
  uint64_t chat_uid() const {
    return GetField<uint64_t>(VT_CHAT_UID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_meta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_META_DATA);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return chat_uid();
    else if constexpr (Index == 1) return chat_meta_data();
    else if constexpr (Index == 2) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAT_UID, 8) &&
           VerifyOffset(verifier, VT_CHAT_META_DATA) &&
           verifier.VerifyVector(chat_meta_data()) &&
           VerifyOffsetRequired(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct ChatChannelChatMessageCmdBuilder {
  typedef ChatChannelChatMessageCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chat_uid(uint64_t chat_uid) {
    fbb_.AddElement<uint64_t>(ChatChannelChatMessageCmd::VT_CHAT_UID, chat_uid, 0);
  }
  void add_chat_meta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data) {
    fbb_.AddOffset(ChatChannelChatMessageCmd::VT_CHAT_META_DATA, chat_meta_data);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(ChatChannelChatMessageCmd::VT_CHAT_MESSAGE, chat_message);
  }
  explicit ChatChannelChatMessageCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelChatMessageCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelChatMessageCmd>(end);
    fbb_.Required(o, ChatChannelChatMessageCmd::VT_CHAT_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelChatMessageCmd> CreateChatChannelChatMessageCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  ChatChannelChatMessageCmdBuilder builder_(_fbb);
  builder_.add_chat_uid(chat_uid);
  builder_.add_chat_message(chat_message);
  builder_.add_chat_meta_data(chat_meta_data);
  return builder_.Finish();
}

struct ChatChannelChatMessageCmd::Traits {
  using type = ChatChannelChatMessageCmd;
  static auto constexpr Create = CreateChatChannelChatMessageCmd;
  static constexpr auto name = "ChatChannelChatMessageCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelChatMessageCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "chat_uid",
    "chat_meta_data",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ChatChannelChatMessageCmd> CreateChatChannelChatMessageCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chat_uid = 0,
    const std::vector<uint8_t> *chat_meta_data = nullptr,
    const char *chat_message = nullptr) {
  auto chat_meta_data__ = chat_meta_data ? _fbb.CreateVector<uint8_t>(*chat_meta_data) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::Game::CreateChatChannelChatMessageCmd(
      _fbb,
      chat_uid,
      chat_meta_data__,
      chat_message__);
}

struct ChatChannelChatMessageRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelChatMessageResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct ChatChannelChatMessageResBuilder {
  typedef ChatChannelChatMessageRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(ChatChannelChatMessageRes::VT_RESULT, result, 0);
  }
  explicit ChatChannelChatMessageResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelChatMessageRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelChatMessageRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelChatMessageRes> CreateChatChannelChatMessageRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  ChatChannelChatMessageResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct ChatChannelChatMessageRes::Traits {
  using type = ChatChannelChatMessageRes;
  static auto constexpr Create = CreateChatChannelChatMessageRes;
  static constexpr auto name = "ChatChannelChatMessageRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelChatMessageRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ChatChannelChatMessageS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChatChannelChatMessageS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENDER_ID = 4,
    VT_CHAT_META_DATA = 6,
    VT_CHAT_MESSAGE = 8
  };
  uint64_t sender_id() const {
    return GetField<uint64_t>(VT_SENDER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_meta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_META_DATA);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return sender_id();
    else if constexpr (Index == 1) return chat_meta_data();
    else if constexpr (Index == 2) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SENDER_ID, 8) &&
           VerifyOffset(verifier, VT_CHAT_META_DATA) &&
           verifier.VerifyVector(chat_meta_data()) &&
           VerifyOffsetRequired(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct ChatChannelChatMessageS2CEvtBuilder {
  typedef ChatChannelChatMessageS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sender_id(uint64_t sender_id) {
    fbb_.AddElement<uint64_t>(ChatChannelChatMessageS2CEvt::VT_SENDER_ID, sender_id, 0);
  }
  void add_chat_meta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data) {
    fbb_.AddOffset(ChatChannelChatMessageS2CEvt::VT_CHAT_META_DATA, chat_meta_data);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(ChatChannelChatMessageS2CEvt::VT_CHAT_MESSAGE, chat_message);
  }
  explicit ChatChannelChatMessageS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChatChannelChatMessageS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChatChannelChatMessageS2CEvt>(end);
    fbb_.Required(o, ChatChannelChatMessageS2CEvt::VT_CHAT_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<ChatChannelChatMessageS2CEvt> CreateChatChannelChatMessageS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  ChatChannelChatMessageS2CEvtBuilder builder_(_fbb);
  builder_.add_sender_id(sender_id);
  builder_.add_chat_message(chat_message);
  builder_.add_chat_meta_data(chat_meta_data);
  return builder_.Finish();
}

struct ChatChannelChatMessageS2CEvt::Traits {
  using type = ChatChannelChatMessageS2CEvt;
  static auto constexpr Create = CreateChatChannelChatMessageS2CEvt;
  static constexpr auto name = "ChatChannelChatMessageS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ChatChannelChatMessageS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "sender_id",
    "chat_meta_data",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ChatChannelChatMessageS2CEvt> CreateChatChannelChatMessageS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    const std::vector<uint8_t> *chat_meta_data = nullptr,
    const char *chat_message = nullptr) {
  auto chat_meta_data__ = chat_meta_data ? _fbb.CreateVector<uint8_t>(*chat_meta_data) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::Game::CreateChatChannelChatMessageS2CEvt(
      _fbb,
      sender_id,
      chat_meta_data__,
      chat_message__);
}

struct WhisperMessageCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhisperMessageCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECEIVER_ID = 4,
    VT_RECEIVER_NAME = 6,
    VT_CHAT_META_DATA = 8,
    VT_CHAT_MESSAGE = 10
  };
  uint64_t receiver_id() const {
    return GetField<uint64_t>(VT_RECEIVER_ID, 0);
  }
  const ::flatbuffers::String *receiver_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECEIVER_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_meta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_META_DATA);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return receiver_id();
    else if constexpr (Index == 1) return receiver_name();
    else if constexpr (Index == 2) return chat_meta_data();
    else if constexpr (Index == 3) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RECEIVER_ID, 8) &&
           VerifyOffsetRequired(verifier, VT_RECEIVER_NAME) &&
           verifier.VerifyString(receiver_name()) &&
           VerifyOffset(verifier, VT_CHAT_META_DATA) &&
           verifier.VerifyVector(chat_meta_data()) &&
           VerifyOffsetRequired(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct WhisperMessageCmdBuilder {
  typedef WhisperMessageCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_receiver_id(uint64_t receiver_id) {
    fbb_.AddElement<uint64_t>(WhisperMessageCmd::VT_RECEIVER_ID, receiver_id, 0);
  }
  void add_receiver_name(::flatbuffers::Offset<::flatbuffers::String> receiver_name) {
    fbb_.AddOffset(WhisperMessageCmd::VT_RECEIVER_NAME, receiver_name);
  }
  void add_chat_meta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data) {
    fbb_.AddOffset(WhisperMessageCmd::VT_CHAT_META_DATA, chat_meta_data);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(WhisperMessageCmd::VT_CHAT_MESSAGE, chat_message);
  }
  explicit WhisperMessageCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhisperMessageCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhisperMessageCmd>(end);
    fbb_.Required(o, WhisperMessageCmd::VT_RECEIVER_NAME);
    fbb_.Required(o, WhisperMessageCmd::VT_CHAT_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<WhisperMessageCmd> CreateWhisperMessageCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t receiver_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> receiver_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  WhisperMessageCmdBuilder builder_(_fbb);
  builder_.add_receiver_id(receiver_id);
  builder_.add_chat_message(chat_message);
  builder_.add_chat_meta_data(chat_meta_data);
  builder_.add_receiver_name(receiver_name);
  return builder_.Finish();
}

struct WhisperMessageCmd::Traits {
  using type = WhisperMessageCmd;
  static auto constexpr Create = CreateWhisperMessageCmd;
  static constexpr auto name = "WhisperMessageCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.WhisperMessageCmd";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "receiver_id",
    "receiver_name",
    "chat_meta_data",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<WhisperMessageCmd> CreateWhisperMessageCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t receiver_id = 0,
    const char *receiver_name = nullptr,
    const std::vector<uint8_t> *chat_meta_data = nullptr,
    const char *chat_message = nullptr) {
  auto receiver_name__ = receiver_name ? _fbb.CreateString(receiver_name) : 0;
  auto chat_meta_data__ = chat_meta_data ? _fbb.CreateVector<uint8_t>(*chat_meta_data) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::Game::CreateWhisperMessageCmd(
      _fbb,
      receiver_id,
      receiver_name__,
      chat_meta_data__,
      chat_message__);
}

struct WhisperMessageRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhisperMessageResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct WhisperMessageResBuilder {
  typedef WhisperMessageRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(WhisperMessageRes::VT_RESULT, result, 0);
  }
  explicit WhisperMessageResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhisperMessageRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhisperMessageRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhisperMessageRes> CreateWhisperMessageRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  WhisperMessageResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct WhisperMessageRes::Traits {
  using type = WhisperMessageRes;
  static auto constexpr Create = CreateWhisperMessageRes;
  static constexpr auto name = "WhisperMessageRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.WhisperMessageRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct WhisperMessageS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhisperMessageS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENDER_ID = 4,
    VT_CHAT_META_DATA = 6,
    VT_CHAT_MESSAGE = 8
  };
  uint64_t sender_id() const {
    return GetField<uint64_t>(VT_SENDER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_meta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_META_DATA);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return sender_id();
    else if constexpr (Index == 1) return chat_meta_data();
    else if constexpr (Index == 2) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SENDER_ID, 8) &&
           VerifyOffset(verifier, VT_CHAT_META_DATA) &&
           verifier.VerifyVector(chat_meta_data()) &&
           VerifyOffsetRequired(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct WhisperMessageS2CEvtBuilder {
  typedef WhisperMessageS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sender_id(uint64_t sender_id) {
    fbb_.AddElement<uint64_t>(WhisperMessageS2CEvt::VT_SENDER_ID, sender_id, 0);
  }
  void add_chat_meta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data) {
    fbb_.AddOffset(WhisperMessageS2CEvt::VT_CHAT_META_DATA, chat_meta_data);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(WhisperMessageS2CEvt::VT_CHAT_MESSAGE, chat_message);
  }
  explicit WhisperMessageS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhisperMessageS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhisperMessageS2CEvt>(end);
    fbb_.Required(o, WhisperMessageS2CEvt::VT_CHAT_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<WhisperMessageS2CEvt> CreateWhisperMessageS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  WhisperMessageS2CEvtBuilder builder_(_fbb);
  builder_.add_sender_id(sender_id);
  builder_.add_chat_message(chat_message);
  builder_.add_chat_meta_data(chat_meta_data);
  return builder_.Finish();
}

struct WhisperMessageS2CEvt::Traits {
  using type = WhisperMessageS2CEvt;
  static auto constexpr Create = CreateWhisperMessageS2CEvt;
  static constexpr auto name = "WhisperMessageS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.WhisperMessageS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "sender_id",
    "chat_meta_data",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<WhisperMessageS2CEvt> CreateWhisperMessageS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t sender_id = 0,
    const std::vector<uint8_t> *chat_meta_data = nullptr,
    const char *chat_message = nullptr) {
  auto chat_meta_data__ = chat_meta_data ? _fbb.CreateVector<uint8_t>(*chat_meta_data) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::Game::CreateWhisperMessageS2CEvt(
      _fbb,
      sender_id,
      chat_meta_data__,
      chat_message__);
}

struct CreateCharacterCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateCharacterCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_NAME = 4,
    VT_PUBLIC_DATA = 6,
    VT_PRIVATE_DATA = 8
  };
  const ::flatbuffers::String *character_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARACTER_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *public_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PUBLIC_DATA);
  }
  const ::flatbuffers::Vector<uint8_t> *private_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PRIVATE_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return character_name();
    else if constexpr (Index == 1) return public_data();
    else if constexpr (Index == 2) return private_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CHARACTER_NAME) &&
           verifier.VerifyString(character_name()) &&
           VerifyOffset(verifier, VT_PUBLIC_DATA) &&
           verifier.VerifyVector(public_data()) &&
           VerifyOffset(verifier, VT_PRIVATE_DATA) &&
           verifier.VerifyVector(private_data()) &&
           verifier.EndTable();
  }
};

struct CreateCharacterCmdBuilder {
  typedef CreateCharacterCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_name(::flatbuffers::Offset<::flatbuffers::String> character_name) {
    fbb_.AddOffset(CreateCharacterCmd::VT_CHARACTER_NAME, character_name);
  }
  void add_public_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> public_data) {
    fbb_.AddOffset(CreateCharacterCmd::VT_PUBLIC_DATA, public_data);
  }
  void add_private_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> private_data) {
    fbb_.AddOffset(CreateCharacterCmd::VT_PRIVATE_DATA, private_data);
  }
  explicit CreateCharacterCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateCharacterCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateCharacterCmd>(end);
    fbb_.Required(o, CreateCharacterCmd::VT_CHARACTER_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateCharacterCmd> CreateCreateCharacterCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> character_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> public_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> private_data = 0) {
  CreateCharacterCmdBuilder builder_(_fbb);
  builder_.add_private_data(private_data);
  builder_.add_public_data(public_data);
  builder_.add_character_name(character_name);
  return builder_.Finish();
}

struct CreateCharacterCmd::Traits {
  using type = CreateCharacterCmd;
  static auto constexpr Create = CreateCreateCharacterCmd;
  static constexpr auto name = "CreateCharacterCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CreateCharacterCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "character_name",
    "public_data",
    "private_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CreateCharacterCmd> CreateCreateCharacterCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *character_name = nullptr,
    const std::vector<uint8_t> *public_data = nullptr,
    const std::vector<uint8_t> *private_data = nullptr) {
  auto character_name__ = character_name ? _fbb.CreateString(character_name) : 0;
  auto public_data__ = public_data ? _fbb.CreateVector<uint8_t>(*public_data) : 0;
  auto private_data__ = private_data ? _fbb.CreateVector<uint8_t>(*private_data) : 0;
  return SF::Flat::Game::CreateCreateCharacterCmd(
      _fbb,
      character_name__,
      public_data__,
      private_data__);
}

struct CreateCharacterRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateCharacterResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_CHARACTER_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return character_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           verifier.EndTable();
  }
};

struct CreateCharacterResBuilder {
  typedef CreateCharacterRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CreateCharacterRes::VT_RESULT, result, 0);
  }
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(CreateCharacterRes::VT_CHARACTER_ID, character_id, 0);
  }
  explicit CreateCharacterResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateCharacterRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateCharacterRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateCharacterRes> CreateCreateCharacterRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t character_id = 0) {
  CreateCharacterResBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CreateCharacterRes::Traits {
  using type = CreateCharacterRes;
  static auto constexpr Create = CreateCreateCharacterRes;
  static constexpr auto name = "CreateCharacterRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CreateCharacterRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "character_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct DeleteCharacterCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteCharacterCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4
  };
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return character_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           verifier.EndTable();
  }
};

struct DeleteCharacterCmdBuilder {
  typedef DeleteCharacterCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(DeleteCharacterCmd::VT_CHARACTER_ID, character_id, 0);
  }
  explicit DeleteCharacterCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteCharacterCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteCharacterCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteCharacterCmd> CreateDeleteCharacterCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t character_id = 0) {
  DeleteCharacterCmdBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct DeleteCharacterCmd::Traits {
  using type = DeleteCharacterCmd;
  static auto constexpr Create = CreateDeleteCharacterCmd;
  static constexpr auto name = "DeleteCharacterCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.DeleteCharacterCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "character_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct DeleteCharacterRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteCharacterResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct DeleteCharacterResBuilder {
  typedef DeleteCharacterRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(DeleteCharacterRes::VT_RESULT, result, 0);
  }
  explicit DeleteCharacterResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteCharacterRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteCharacterRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteCharacterRes> CreateDeleteCharacterRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  DeleteCharacterResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct DeleteCharacterRes::Traits {
  using type = DeleteCharacterRes;
  static auto constexpr Create = CreateDeleteCharacterRes;
  static constexpr auto name = "DeleteCharacterRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.DeleteCharacterRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetCharacterListCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetCharacterListCmdBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetCharacterListCmdBuilder {
  typedef GetCharacterListCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetCharacterListCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetCharacterListCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetCharacterListCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetCharacterListCmd> CreateGetCharacterListCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetCharacterListCmdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetCharacterListCmd::Traits {
  using type = GetCharacterListCmd;
  static auto constexpr Create = CreateGetCharacterListCmd;
  static constexpr auto name = "GetCharacterListCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetCharacterListCmd";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct GetCharacterListRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetCharacterListResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_CHARACTERS = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *characters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHARACTERS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return characters();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_CHARACTERS) &&
           verifier.VerifyVector(characters()) &&
           verifier.EndTable();
  }
};

struct GetCharacterListResBuilder {
  typedef GetCharacterListRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetCharacterListRes::VT_RESULT, result, 0);
  }
  void add_characters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> characters) {
    fbb_.AddOffset(GetCharacterListRes::VT_CHARACTERS, characters);
  }
  explicit GetCharacterListResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetCharacterListRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetCharacterListRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetCharacterListRes> CreateGetCharacterListRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> characters = 0) {
  GetCharacterListResBuilder builder_(_fbb);
  builder_.add_characters(characters);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetCharacterListRes::Traits {
  using type = GetCharacterListRes;
  static auto constexpr Create = CreateGetCharacterListRes;
  static constexpr auto name = "GetCharacterListRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetCharacterListRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "characters"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetCharacterListRes> CreateGetCharacterListResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *characters = nullptr) {
  auto characters__ = characters ? _fbb.CreateVector<uint8_t>(*characters) : 0;
  return SF::Flat::Game::CreateGetCharacterListRes(
      _fbb,
      result,
      characters__);
}

struct GetCharacterDataCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetCharacterDataCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4
  };
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return character_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           verifier.EndTable();
  }
};

struct GetCharacterDataCmdBuilder {
  typedef GetCharacterDataCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(GetCharacterDataCmd::VT_CHARACTER_ID, character_id, 0);
  }
  explicit GetCharacterDataCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetCharacterDataCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetCharacterDataCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetCharacterDataCmd> CreateGetCharacterDataCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t character_id = 0) {
  GetCharacterDataCmdBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct GetCharacterDataCmd::Traits {
  using type = GetCharacterDataCmd;
  static auto constexpr Create = CreateGetCharacterDataCmd;
  static constexpr auto name = "GetCharacterDataCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetCharacterDataCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "character_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetCharacterDataRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetCharacterDataResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PRIVATE_DATA = 6,
    VT_EQUIP_DATA = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *private_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PRIVATE_DATA);
  }
  const ::flatbuffers::Vector<uint8_t> *equip_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_EQUIP_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return private_data();
    else if constexpr (Index == 2) return equip_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_PRIVATE_DATA) &&
           verifier.VerifyVector(private_data()) &&
           VerifyOffset(verifier, VT_EQUIP_DATA) &&
           verifier.VerifyVector(equip_data()) &&
           verifier.EndTable();
  }
};

struct GetCharacterDataResBuilder {
  typedef GetCharacterDataRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetCharacterDataRes::VT_RESULT, result, 0);
  }
  void add_private_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> private_data) {
    fbb_.AddOffset(GetCharacterDataRes::VT_PRIVATE_DATA, private_data);
  }
  void add_equip_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> equip_data) {
    fbb_.AddOffset(GetCharacterDataRes::VT_EQUIP_DATA, equip_data);
  }
  explicit GetCharacterDataResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetCharacterDataRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetCharacterDataRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetCharacterDataRes> CreateGetCharacterDataRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> private_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> equip_data = 0) {
  GetCharacterDataResBuilder builder_(_fbb);
  builder_.add_equip_data(equip_data);
  builder_.add_private_data(private_data);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetCharacterDataRes::Traits {
  using type = GetCharacterDataRes;
  static auto constexpr Create = CreateGetCharacterDataRes;
  static constexpr auto name = "GetCharacterDataRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.GetCharacterDataRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "private_data",
    "equip_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetCharacterDataRes> CreateGetCharacterDataResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *private_data = nullptr,
    const std::vector<uint8_t> *equip_data = nullptr) {
  auto private_data__ = private_data ? _fbb.CreateVector<uint8_t>(*private_data) : 0;
  auto equip_data__ = equip_data ? _fbb.CreateVector<uint8_t>(*equip_data) : 0;
  return SF::Flat::Game::CreateGetCharacterDataRes(
      _fbb,
      result,
      private_data__,
      equip_data__);
}

struct SelectCharacterCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SelectCharacterCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4
  };
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return character_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           verifier.EndTable();
  }
};

struct SelectCharacterCmdBuilder {
  typedef SelectCharacterCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(SelectCharacterCmd::VT_CHARACTER_ID, character_id, 0);
  }
  explicit SelectCharacterCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SelectCharacterCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SelectCharacterCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SelectCharacterCmd> CreateSelectCharacterCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t character_id = 0) {
  SelectCharacterCmdBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct SelectCharacterCmd::Traits {
  using type = SelectCharacterCmd;
  static auto constexpr Create = CreateSelectCharacterCmd;
  static constexpr auto name = "SelectCharacterCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SelectCharacterCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "character_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct SelectCharacterRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SelectCharacterResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_CHARACTER_ID = 6,
    VT_ATTRIBUTES = 8
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ATTRIBUTES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return character_id();
    else if constexpr (Index == 2) return attributes();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.EndTable();
  }
};

struct SelectCharacterResBuilder {
  typedef SelectCharacterRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SelectCharacterRes::VT_RESULT, result, 0);
  }
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(SelectCharacterRes::VT_CHARACTER_ID, character_id, 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> attributes) {
    fbb_.AddOffset(SelectCharacterRes::VT_ATTRIBUTES, attributes);
  }
  explicit SelectCharacterResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SelectCharacterRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SelectCharacterRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SelectCharacterRes> CreateSelectCharacterRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t character_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> attributes = 0) {
  SelectCharacterResBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_character_id(character_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SelectCharacterRes::Traits {
  using type = SelectCharacterRes;
  static auto constexpr Create = CreateSelectCharacterRes;
  static constexpr auto name = "SelectCharacterRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.SelectCharacterRes";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "character_id",
    "attributes"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SelectCharacterRes> CreateSelectCharacterResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t character_id = 0,
    const std::vector<uint8_t> *attributes = nullptr) {
  auto attributes__ = attributes ? _fbb.CreateVector<uint8_t>(*attributes) : 0;
  return SF::Flat::Game::CreateSelectCharacterRes(
      _fbb,
      result,
      character_id,
      attributes__);
}

struct RequestServerNoticeUpdateCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestServerNoticeUpdateCmdBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestServerNoticeUpdateCmdBuilder {
  typedef RequestServerNoticeUpdateCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestServerNoticeUpdateCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestServerNoticeUpdateCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestServerNoticeUpdateCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestServerNoticeUpdateCmd> CreateRequestServerNoticeUpdateCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestServerNoticeUpdateCmdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestServerNoticeUpdateCmd::Traits {
  using type = RequestServerNoticeUpdateCmd;
  static auto constexpr Create = CreateRequestServerNoticeUpdateCmd;
  static constexpr auto name = "RequestServerNoticeUpdateCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestServerNoticeUpdateCmd";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

struct RequestServerNoticeUpdateRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestServerNoticeUpdateResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct RequestServerNoticeUpdateResBuilder {
  typedef RequestServerNoticeUpdateRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RequestServerNoticeUpdateRes::VT_RESULT, result, 0);
  }
  explicit RequestServerNoticeUpdateResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestServerNoticeUpdateRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestServerNoticeUpdateRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestServerNoticeUpdateRes> CreateRequestServerNoticeUpdateRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  RequestServerNoticeUpdateResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RequestServerNoticeUpdateRes::Traits {
  using type = RequestServerNoticeUpdateRes;
  static auto constexpr Create = CreateRequestServerNoticeUpdateRes;
  static constexpr auto name = "RequestServerNoticeUpdateRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.RequestServerNoticeUpdateRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ServerNoticeS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerNoticeS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTICE_CATEGORY = 4,
    VT_SERVER_NOTICE_MESSAGE = 6
  };
  int8_t notice_category() const {
    return GetField<int8_t>(VT_NOTICE_CATEGORY, 0);
  }
  const ::flatbuffers::String *server_notice_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVER_NOTICE_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return notice_category();
    else if constexpr (Index == 1) return server_notice_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_NOTICE_CATEGORY, 1) &&
           VerifyOffsetRequired(verifier, VT_SERVER_NOTICE_MESSAGE) &&
           verifier.VerifyString(server_notice_message()) &&
           verifier.EndTable();
  }
};

struct ServerNoticeS2CEvtBuilder {
  typedef ServerNoticeS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notice_category(int8_t notice_category) {
    fbb_.AddElement<int8_t>(ServerNoticeS2CEvt::VT_NOTICE_CATEGORY, notice_category, 0);
  }
  void add_server_notice_message(::flatbuffers::Offset<::flatbuffers::String> server_notice_message) {
    fbb_.AddOffset(ServerNoticeS2CEvt::VT_SERVER_NOTICE_MESSAGE, server_notice_message);
  }
  explicit ServerNoticeS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerNoticeS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerNoticeS2CEvt>(end);
    fbb_.Required(o, ServerNoticeS2CEvt::VT_SERVER_NOTICE_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerNoticeS2CEvt> CreateServerNoticeS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t notice_category = 0,
    ::flatbuffers::Offset<::flatbuffers::String> server_notice_message = 0) {
  ServerNoticeS2CEvtBuilder builder_(_fbb);
  builder_.add_server_notice_message(server_notice_message);
  builder_.add_notice_category(notice_category);
  return builder_.Finish();
}

struct ServerNoticeS2CEvt::Traits {
  using type = ServerNoticeS2CEvt;
  static auto constexpr Create = CreateServerNoticeS2CEvt;
  static constexpr auto name = "ServerNoticeS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.ServerNoticeS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "notice_category",
    "server_notice_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ServerNoticeS2CEvt> CreateServerNoticeS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t notice_category = 0,
    const char *server_notice_message = nullptr) {
  auto server_notice_message__ = server_notice_message ? _fbb.CreateString(server_notice_message) : 0;
  return SF::Flat::Game::CreateServerNoticeS2CEvt(
      _fbb,
      notice_category,
      server_notice_message__);
}

struct CallFunctionCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallFunctionCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION_NAME = 4,
    VT_PARAMETERS = 6
  };
  uint32_t function_name() const {
    return GetField<uint32_t>(VT_FUNCTION_NAME, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return function_name();
    else if constexpr (Index == 1) return parameters();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FUNCTION_NAME, 4) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.EndTable();
  }
};

struct CallFunctionCmdBuilder {
  typedef CallFunctionCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_function_name(uint32_t function_name) {
    fbb_.AddElement<uint32_t>(CallFunctionCmd::VT_FUNCTION_NAME, function_name, 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters) {
    fbb_.AddOffset(CallFunctionCmd::VT_PARAMETERS, parameters);
  }
  explicit CallFunctionCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallFunctionCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallFunctionCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallFunctionCmd> CreateCallFunctionCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t function_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters = 0) {
  CallFunctionCmdBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_function_name(function_name);
  return builder_.Finish();
}

struct CallFunctionCmd::Traits {
  using type = CallFunctionCmd;
  static auto constexpr Create = CreateCallFunctionCmd;
  static constexpr auto name = "CallFunctionCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CallFunctionCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "function_name",
    "parameters"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CallFunctionCmd> CreateCallFunctionCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t function_name = 0,
    const std::vector<uint8_t> *parameters = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateVector<uint8_t>(*parameters) : 0;
  return SF::Flat::Game::CreateCallFunctionCmd(
      _fbb,
      function_name,
      parameters__);
}

struct CallFunctionRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallFunctionResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_RESULTS = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *results() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESULTS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return results();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.EndTable();
  }
};

struct CallFunctionResBuilder {
  typedef CallFunctionRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CallFunctionRes::VT_RESULT, result, 0);
  }
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> results) {
    fbb_.AddOffset(CallFunctionRes::VT_RESULTS, results);
  }
  explicit CallFunctionResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallFunctionRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallFunctionRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallFunctionRes> CreateCallFunctionRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> results = 0) {
  CallFunctionResBuilder builder_(_fbb);
  builder_.add_results(results);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CallFunctionRes::Traits {
  using type = CallFunctionRes;
  static auto constexpr Create = CreateCallFunctionRes;
  static constexpr auto name = "CallFunctionRes";
  static constexpr auto fully_qualified_name = "SF.Flat.Game.CallFunctionRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "results"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CallFunctionRes> CreateCallFunctionResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<uint8_t>(*results) : 0;
  return SF::Flat::Game::CreateCallFunctionRes(
      _fbb,
      result,
      results__);
}

inline const SF::Flat::Game::CallFunctionRes *GetCallFunctionRes(const void *buf) {
  return ::flatbuffers::GetRoot<SF::Flat::Game::CallFunctionRes>(buf);
}

inline const SF::Flat::Game::CallFunctionRes *GetSizePrefixedCallFunctionRes(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SF::Flat::Game::CallFunctionRes>(buf);
}

inline bool VerifyCallFunctionResBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SF::Flat::Game::CallFunctionRes>(nullptr);
}

inline bool VerifySizePrefixedCallFunctionResBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SF::Flat::Game::CallFunctionRes>(nullptr);
}

inline void FinishCallFunctionResBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SF::Flat::Game::CallFunctionRes> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCallFunctionResBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SF::Flat::Game::CallFunctionRes> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Game
}  // namespace Flat
}  // namespace SF

#endif  // FLATBUFFERS_GENERATED_GAME_SF_FLAT_GAME_H_
