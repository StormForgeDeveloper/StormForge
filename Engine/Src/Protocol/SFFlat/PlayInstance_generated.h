// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PLAYINSTANCE_SF_FLAT_PLAYINSTANCE_H_
#define FLATBUFFERS_GENERATED_PLAYINSTANCE_SF_FLAT_PLAYINSTANCE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

#include "LocalTypes_generated.h"

namespace SF {
namespace Flat {
namespace PlayInstance {

struct JoinPlayInstanceCmd;
struct JoinPlayInstanceCmdBuilder;

struct JoinPlayInstanceRes;
struct JoinPlayInstanceResBuilder;

struct PlayerKickedS2CEvt;
struct PlayerKickedS2CEvtBuilder;

struct PlayPacketC2SEvt;
struct PlayPacketC2SEvtBuilder;

struct NewActorInViewS2CEvt;
struct NewActorInViewS2CEvtBuilder;

struct RemoveActorFromViewS2CEvt;
struct RemoveActorFromViewS2CEvtBuilder;

struct PlayerMovementC2SEvt;
struct PlayerMovementC2SEvtBuilder;

struct ActorMovementS2CEvt;
struct ActorMovementS2CEvtBuilder;

struct ActorMovementsS2CEvt;
struct ActorMovementsS2CEvtBuilder;

struct PlayerStateChangedS2CEvt;
struct PlayerStateChangedS2CEvtBuilder;

struct ClientSyncReliableC2SEvt;
struct ClientSyncReliableC2SEvtBuilder;

struct ClientSyncC2SEvt;
struct ClientSyncC2SEvtBuilder;

struct SetCharacterPublicMessageCmd;
struct SetCharacterPublicMessageCmdBuilder;

struct SetCharacterPublicMessageRes;
struct SetCharacterPublicMessageResBuilder;

struct CharacterPrivateDataChangedS2CEvt;
struct CharacterPrivateDataChangedS2CEvtBuilder;

struct CharacterPublicDataChangedS2CEvt;
struct CharacterPublicDataChangedS2CEvtBuilder;

struct RequestWhiteboardSharingCmd;
struct RequestWhiteboardSharingCmdBuilder;

struct RequestWhiteboardSharingRes;
struct RequestWhiteboardSharingResBuilder;

struct AcceptWhiteboardSharingCmd;
struct AcceptWhiteboardSharingCmdBuilder;

struct AcceptWhiteboardSharingRes;
struct AcceptWhiteboardSharingResBuilder;

struct CloseWhiteboardSharingCmd;
struct CloseWhiteboardSharingCmdBuilder;

struct CloseWhiteboardSharingRes;
struct CloseWhiteboardSharingResBuilder;

struct AddWhiteboardSharingLogEntryCmd;
struct AddWhiteboardSharingLogEntryCmdBuilder;

struct AddWhiteboardSharingLogEntryRes;
struct AddWhiteboardSharingLogEntryResBuilder;

struct UpdateWhiteboardSharingLogEntryCmd;
struct UpdateWhiteboardSharingLogEntryCmdBuilder;

struct UpdateWhiteboardSharingLogEntryRes;
struct UpdateWhiteboardSharingLogEntryResBuilder;

struct RemoveWhiteboardSharingLogEntryCmd;
struct RemoveWhiteboardSharingLogEntryCmdBuilder;

struct RemoveWhiteboardSharingLogEntryRes;
struct RemoveWhiteboardSharingLogEntryResBuilder;

struct WhiteboardSharingRequestedS2CEvt;
struct WhiteboardSharingRequestedS2CEvtBuilder;

struct WhiteboardSharingRejectedS2CEvt;
struct WhiteboardSharingRejectedS2CEvtBuilder;

struct WhiteboardSharingStartedS2CEvt;
struct WhiteboardSharingStartedS2CEvtBuilder;

struct WhiteboardSharingHasClosedS2CEvt;
struct WhiteboardSharingHasClosedS2CEvtBuilder;

struct WhiteboardSharingNewLogEntryAddedS2CEvt;
struct WhiteboardSharingNewLogEntryAddedS2CEvtBuilder;

struct WhiteboardSharingNewLogEntryRemovedS2CEvt;
struct WhiteboardSharingNewLogEntryRemovedS2CEvtBuilder;

struct WhiteboardSharingNewLogEntryUpdatedS2CEvt;
struct WhiteboardSharingNewLogEntryUpdatedS2CEvtBuilder;

struct OccupyMapObjectCmd;
struct OccupyMapObjectCmdBuilder;

struct OccupyMapObjectRes;
struct OccupyMapObjectResBuilder;

struct UnoccupyMapObjectCmd;
struct UnoccupyMapObjectCmdBuilder;

struct UnoccupyMapObjectRes;
struct UnoccupyMapObjectResBuilder;

struct UseMapObjectCmd;
struct UseMapObjectCmdBuilder;

struct UseMapObjectRes;
struct UseMapObjectResBuilder;

struct ZoneChatCmd;
struct ZoneChatCmdBuilder;

struct ZoneChatRes;
struct ZoneChatResBuilder;

struct ZoneChatS2CEvt;
struct ZoneChatS2CEvtBuilder;

struct LevelUpS2CEvt;
struct LevelUpS2CEvtBuilder;

struct CallFunctionCmd;
struct CallFunctionCmdBuilder;

struct CallFunctionRes;
struct CallFunctionResBuilder;

struct SendVoiceDataC2SEvt;
struct SendVoiceDataC2SEvtBuilder;

struct VoiceDataS2CEvt;
struct VoiceDataS2CEvtBuilder;

struct CreateStreamCmd;
struct CreateStreamCmdBuilder;

struct CreateStreamRes;
struct CreateStreamResBuilder;

struct FindStreamCmd;
struct FindStreamCmdBuilder;

struct FindStreamRes;
struct FindStreamResBuilder;

struct DeleteStreamCmd;
struct DeleteStreamCmdBuilder;

struct DeleteStreamRes;
struct DeleteStreamResBuilder;

struct GetStreamListCmd;
struct GetStreamListCmdBuilder;

struct GetStreamListRes;
struct GetStreamListResBuilder;

struct JoinPlayInstanceCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinPlayInstanceCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_PLAYER_IDENTIFIER = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::String *player_identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLAYER_IDENTIFIER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return player_identifier();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_PLAYER_IDENTIFIER) &&
           verifier.VerifyString(player_identifier()) &&
           verifier.EndTable();
  }
};

struct JoinPlayInstanceCmdBuilder {
  typedef JoinPlayInstanceCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(JoinPlayInstanceCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(JoinPlayInstanceCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_identifier(::flatbuffers::Offset<::flatbuffers::String> player_identifier) {
    fbb_.AddOffset(JoinPlayInstanceCmd::VT_PLAYER_IDENTIFIER, player_identifier);
  }
  explicit JoinPlayInstanceCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinPlayInstanceCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinPlayInstanceCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinPlayInstanceCmd> CreateJoinPlayInstanceCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> player_identifier = 0) {
  JoinPlayInstanceCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_player_identifier(player_identifier);
  return builder_.Finish();
}

struct JoinPlayInstanceCmd::Traits {
  using type = JoinPlayInstanceCmd;
  static auto constexpr Create = CreateJoinPlayInstanceCmd;
  static constexpr auto name = "JoinPlayInstanceCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.JoinPlayInstanceCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "player_identifier"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<JoinPlayInstanceCmd> CreateJoinPlayInstanceCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const char *player_identifier = nullptr) {
  auto player_identifier__ = player_identifier ? _fbb.CreateString(player_identifier) : 0;
  return SF::Flat::PlayInstance::CreateJoinPlayInstanceCmd(
      _fbb,
      play_instance_uid,
      player_id,
      player_identifier__);
}

struct JoinPlayInstanceRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinPlayInstanceResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAY_INSTANCE_UID = 6,
    VT_PLAYER_ID = 8,
    VT_CHARACTER_ID = 10,
    VT_CHARACTER_PRIVATE_DATA = 12,
    VT_MOVEMENT = 14
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *character_private_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHARACTER_PRIVATE_DATA);
  }
  const SF::Flat::ActorMovement *movement() const {
    return GetPointer<const SF::Flat::ActorMovement *>(VT_MOVEMENT);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return play_instance_uid();
    else if constexpr (Index == 2) return player_id();
    else if constexpr (Index == 3) return character_id();
    else if constexpr (Index == 4) return character_private_data();
    else if constexpr (Index == 5) return movement();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyOffset(verifier, VT_CHARACTER_PRIVATE_DATA) &&
           verifier.VerifyVector(character_private_data()) &&
           VerifyOffset(verifier, VT_MOVEMENT) &&
           verifier.VerifyTable(movement()) &&
           verifier.EndTable();
  }
};

struct JoinPlayInstanceResBuilder {
  typedef JoinPlayInstanceRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(JoinPlayInstanceRes::VT_RESULT, result, 0);
  }
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(JoinPlayInstanceRes::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(JoinPlayInstanceRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(JoinPlayInstanceRes::VT_CHARACTER_ID, character_id, 0);
  }
  void add_character_private_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> character_private_data) {
    fbb_.AddOffset(JoinPlayInstanceRes::VT_CHARACTER_PRIVATE_DATA, character_private_data);
  }
  void add_movement(::flatbuffers::Offset<SF::Flat::ActorMovement> movement) {
    fbb_.AddOffset(JoinPlayInstanceRes::VT_MOVEMENT, movement);
  }
  explicit JoinPlayInstanceResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinPlayInstanceRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinPlayInstanceRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinPlayInstanceRes> CreateJoinPlayInstanceRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t character_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> character_private_data = 0,
    ::flatbuffers::Offset<SF::Flat::ActorMovement> movement = 0) {
  JoinPlayInstanceResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_movement(movement);
  builder_.add_character_private_data(character_private_data);
  builder_.add_character_id(character_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct JoinPlayInstanceRes::Traits {
  using type = JoinPlayInstanceRes;
  static auto constexpr Create = CreateJoinPlayInstanceRes;
  static constexpr auto name = "JoinPlayInstanceRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.JoinPlayInstanceRes";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "play_instance_uid",
    "player_id",
    "character_id",
    "character_private_data",
    "movement"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<JoinPlayInstanceRes> CreateJoinPlayInstanceResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t character_id = 0,
    const std::vector<uint8_t> *character_private_data = nullptr,
    ::flatbuffers::Offset<SF::Flat::ActorMovement> movement = 0) {
  auto character_private_data__ = character_private_data ? _fbb.CreateVector<uint8_t>(*character_private_data) : 0;
  return SF::Flat::PlayInstance::CreateJoinPlayInstanceRes(
      _fbb,
      result,
      play_instance_uid,
      player_id,
      character_id,
      character_private_data__,
      movement);
}

struct PlayerKickedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerKickedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_KICKED_PLAYER_ID = 6
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t kicked_player_id() const {
    return GetField<uint64_t>(VT_KICKED_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return kicked_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_KICKED_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct PlayerKickedS2CEvtBuilder {
  typedef PlayerKickedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(PlayerKickedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_kicked_player_id(uint64_t kicked_player_id) {
    fbb_.AddElement<uint64_t>(PlayerKickedS2CEvt::VT_KICKED_PLAYER_ID, kicked_player_id, 0);
  }
  explicit PlayerKickedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerKickedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerKickedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerKickedS2CEvt> CreatePlayerKickedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t kicked_player_id = 0) {
  PlayerKickedS2CEvtBuilder builder_(_fbb);
  builder_.add_kicked_player_id(kicked_player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  return builder_.Finish();
}

struct PlayerKickedS2CEvt::Traits {
  using type = PlayerKickedS2CEvt;
  static auto constexpr Create = CreatePlayerKickedS2CEvt;
  static constexpr auto name = "PlayerKickedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.PlayerKickedS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "kicked_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PlayPacketC2SEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayPacketC2SEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_SENDER_ENDPOINT_ID = 6,
    VT_TARGET_ENDPOINT_MASK = 8,
    VT_PAYLOAD = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint32_t sender_endpoint_id() const {
    return GetField<uint32_t>(VT_SENDER_ENDPOINT_ID, 0);
  }
  uint32_t target_endpoint_mask() const {
    return GetField<uint32_t>(VT_TARGET_ENDPOINT_MASK, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return sender_endpoint_id();
    else if constexpr (Index == 2) return target_endpoint_mask();
    else if constexpr (Index == 3) return payload();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint32_t>(verifier, VT_SENDER_ENDPOINT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_ENDPOINT_MASK, 4) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct PlayPacketC2SEvtBuilder {
  typedef PlayPacketC2SEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(PlayPacketC2SEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_sender_endpoint_id(uint32_t sender_endpoint_id) {
    fbb_.AddElement<uint32_t>(PlayPacketC2SEvt::VT_SENDER_ENDPOINT_ID, sender_endpoint_id, 0);
  }
  void add_target_endpoint_mask(uint32_t target_endpoint_mask) {
    fbb_.AddElement<uint32_t>(PlayPacketC2SEvt::VT_TARGET_ENDPOINT_MASK, target_endpoint_mask, 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(PlayPacketC2SEvt::VT_PAYLOAD, payload);
  }
  explicit PlayPacketC2SEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayPacketC2SEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayPacketC2SEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayPacketC2SEvt> CreatePlayPacketC2SEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint32_t sender_endpoint_id = 0,
    uint32_t target_endpoint_mask = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  PlayPacketC2SEvtBuilder builder_(_fbb);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_payload(payload);
  builder_.add_target_endpoint_mask(target_endpoint_mask);
  builder_.add_sender_endpoint_id(sender_endpoint_id);
  return builder_.Finish();
}

struct PlayPacketC2SEvt::Traits {
  using type = PlayPacketC2SEvt;
  static auto constexpr Create = CreatePlayPacketC2SEvt;
  static constexpr auto name = "PlayPacketC2SEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.PlayPacketC2SEvt";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "sender_endpoint_id",
    "target_endpoint_mask",
    "payload"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PlayPacketC2SEvt> CreatePlayPacketC2SEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint32_t sender_endpoint_id = 0,
    uint32_t target_endpoint_mask = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return SF::Flat::PlayInstance::CreatePlayPacketC2SEvt(
      _fbb,
      play_instance_uid,
      sender_endpoint_id,
      target_endpoint_mask,
      payload__);
}

struct NewActorInViewS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NewActorInViewS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_PLAYER_PLATFORM_ID = 8,
    VT_PUBLIC_DATA = 10,
    VT_EQUIP_DATA = 12,
    VT_MOVEMENT = 14,
    VT_STATE = 16,
    VT_STATE_VALUES = 18
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const SF::Flat::PlayerPlatformID *player_platform_id() const {
    return GetStruct<const SF::Flat::PlayerPlatformID *>(VT_PLAYER_PLATFORM_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *public_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PUBLIC_DATA);
  }
  const ::flatbuffers::Vector<uint8_t> *equip_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_EQUIP_DATA);
  }
  const SF::Flat::ActorMovement *movement() const {
    return GetPointer<const SF::Flat::ActorMovement *>(VT_MOVEMENT);
  }
  uint32_t state() const {
    return GetField<uint32_t>(VT_STATE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *state_values() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_STATE_VALUES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return player_platform_id();
    else if constexpr (Index == 3) return public_data();
    else if constexpr (Index == 4) return equip_data();
    else if constexpr (Index == 5) return movement();
    else if constexpr (Index == 6) return state();
    else if constexpr (Index == 7) return state_values();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<SF::Flat::PlayerPlatformID>(verifier, VT_PLAYER_PLATFORM_ID, 8) &&
           VerifyOffset(verifier, VT_PUBLIC_DATA) &&
           verifier.VerifyVector(public_data()) &&
           VerifyOffset(verifier, VT_EQUIP_DATA) &&
           verifier.VerifyVector(equip_data()) &&
           VerifyOffset(verifier, VT_MOVEMENT) &&
           verifier.VerifyTable(movement()) &&
           VerifyField<uint32_t>(verifier, VT_STATE, 4) &&
           VerifyOffset(verifier, VT_STATE_VALUES) &&
           verifier.VerifyVector(state_values()) &&
           verifier.EndTable();
  }
};

struct NewActorInViewS2CEvtBuilder {
  typedef NewActorInViewS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(NewActorInViewS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(NewActorInViewS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_player_platform_id(const SF::Flat::PlayerPlatformID *player_platform_id) {
    fbb_.AddStruct(NewActorInViewS2CEvt::VT_PLAYER_PLATFORM_ID, player_platform_id);
  }
  void add_public_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> public_data) {
    fbb_.AddOffset(NewActorInViewS2CEvt::VT_PUBLIC_DATA, public_data);
  }
  void add_equip_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> equip_data) {
    fbb_.AddOffset(NewActorInViewS2CEvt::VT_EQUIP_DATA, equip_data);
  }
  void add_movement(::flatbuffers::Offset<SF::Flat::ActorMovement> movement) {
    fbb_.AddOffset(NewActorInViewS2CEvt::VT_MOVEMENT, movement);
  }
  void add_state(uint32_t state) {
    fbb_.AddElement<uint32_t>(NewActorInViewS2CEvt::VT_STATE, state, 0);
  }
  void add_state_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> state_values) {
    fbb_.AddOffset(NewActorInViewS2CEvt::VT_STATE_VALUES, state_values);
  }
  explicit NewActorInViewS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NewActorInViewS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NewActorInViewS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NewActorInViewS2CEvt> CreateNewActorInViewS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> public_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> equip_data = 0,
    ::flatbuffers::Offset<SF::Flat::ActorMovement> movement = 0,
    uint32_t state = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> state_values = 0) {
  NewActorInViewS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_state_values(state_values);
  builder_.add_state(state);
  builder_.add_movement(movement);
  builder_.add_equip_data(equip_data);
  builder_.add_public_data(public_data);
  builder_.add_player_platform_id(player_platform_id);
  return builder_.Finish();
}

struct NewActorInViewS2CEvt::Traits {
  using type = NewActorInViewS2CEvt;
  static auto constexpr Create = CreateNewActorInViewS2CEvt;
  static constexpr auto name = "NewActorInViewS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.NewActorInViewS2CEvt";
  static constexpr size_t fields_number = 8;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "player_platform_id",
    "public_data",
    "equip_data",
    "movement",
    "state",
    "state_values"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NewActorInViewS2CEvt> CreateNewActorInViewS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const SF::Flat::PlayerPlatformID *player_platform_id = nullptr,
    const std::vector<uint8_t> *public_data = nullptr,
    const std::vector<uint8_t> *equip_data = nullptr,
    ::flatbuffers::Offset<SF::Flat::ActorMovement> movement = 0,
    uint32_t state = 0,
    const std::vector<uint8_t> *state_values = nullptr) {
  auto public_data__ = public_data ? _fbb.CreateVector<uint8_t>(*public_data) : 0;
  auto equip_data__ = equip_data ? _fbb.CreateVector<uint8_t>(*equip_data) : 0;
  auto state_values__ = state_values ? _fbb.CreateVector<uint8_t>(*state_values) : 0;
  return SF::Flat::PlayInstance::CreateNewActorInViewS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      player_platform_id,
      public_data__,
      equip_data__,
      movement,
      state,
      state_values__);
}

struct RemoveActorFromViewS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveActorFromViewS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_ACTOR_ID = 6
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint32_t actor_id() const {
    return GetField<uint32_t>(VT_ACTOR_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return actor_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint32_t>(verifier, VT_ACTOR_ID, 4) &&
           verifier.EndTable();
  }
};

struct RemoveActorFromViewS2CEvtBuilder {
  typedef RemoveActorFromViewS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(RemoveActorFromViewS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_actor_id(uint32_t actor_id) {
    fbb_.AddElement<uint32_t>(RemoveActorFromViewS2CEvt::VT_ACTOR_ID, actor_id, 0);
  }
  explicit RemoveActorFromViewS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveActorFromViewS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveActorFromViewS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveActorFromViewS2CEvt> CreateRemoveActorFromViewS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint32_t actor_id = 0) {
  RemoveActorFromViewS2CEvtBuilder builder_(_fbb);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_actor_id(actor_id);
  return builder_.Finish();
}

struct RemoveActorFromViewS2CEvt::Traits {
  using type = RemoveActorFromViewS2CEvt;
  static auto constexpr Create = CreateRemoveActorFromViewS2CEvt;
  static constexpr auto name = "RemoveActorFromViewS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.RemoveActorFromViewS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "actor_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PlayerMovementC2SEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerMovementC2SEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_MOVEMENT = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const SF::Flat::ActorMovement *movement() const {
    return GetPointer<const SF::Flat::ActorMovement *>(VT_MOVEMENT);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return movement();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_MOVEMENT) &&
           verifier.VerifyTable(movement()) &&
           verifier.EndTable();
  }
};

struct PlayerMovementC2SEvtBuilder {
  typedef PlayerMovementC2SEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(PlayerMovementC2SEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(PlayerMovementC2SEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_movement(::flatbuffers::Offset<SF::Flat::ActorMovement> movement) {
    fbb_.AddOffset(PlayerMovementC2SEvt::VT_MOVEMENT, movement);
  }
  explicit PlayerMovementC2SEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerMovementC2SEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerMovementC2SEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerMovementC2SEvt> CreatePlayerMovementC2SEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<SF::Flat::ActorMovement> movement = 0) {
  PlayerMovementC2SEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_movement(movement);
  return builder_.Finish();
}

struct PlayerMovementC2SEvt::Traits {
  using type = PlayerMovementC2SEvt;
  static auto constexpr Create = CreatePlayerMovementC2SEvt;
  static constexpr auto name = "PlayerMovementC2SEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.PlayerMovementC2SEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "movement"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ActorMovementS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActorMovementS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_MOVEMENT = 6
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  const SF::Flat::ActorMovement *movement() const {
    return GetPointer<const SF::Flat::ActorMovement *>(VT_MOVEMENT);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return movement();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyOffset(verifier, VT_MOVEMENT) &&
           verifier.VerifyTable(movement()) &&
           verifier.EndTable();
  }
};

struct ActorMovementS2CEvtBuilder {
  typedef ActorMovementS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(ActorMovementS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_movement(::flatbuffers::Offset<SF::Flat::ActorMovement> movement) {
    fbb_.AddOffset(ActorMovementS2CEvt::VT_MOVEMENT, movement);
  }
  explicit ActorMovementS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActorMovementS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActorMovementS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActorMovementS2CEvt> CreateActorMovementS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    ::flatbuffers::Offset<SF::Flat::ActorMovement> movement = 0) {
  ActorMovementS2CEvtBuilder builder_(_fbb);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_movement(movement);
  return builder_.Finish();
}

struct ActorMovementS2CEvt::Traits {
  using type = ActorMovementS2CEvt;
  static auto constexpr Create = CreateActorMovementS2CEvt;
  static constexpr auto name = "ActorMovementS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ActorMovementS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "movement"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ActorMovementsS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActorMovementsS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_MOVEMENT = 6
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::ActorMovement>> *movement() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::ActorMovement>> *>(VT_MOVEMENT);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return movement();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyOffset(verifier, VT_MOVEMENT) &&
           verifier.VerifyVector(movement()) &&
           verifier.VerifyVectorOfTables(movement()) &&
           verifier.EndTable();
  }
};

struct ActorMovementsS2CEvtBuilder {
  typedef ActorMovementsS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(ActorMovementsS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_movement(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::ActorMovement>>> movement) {
    fbb_.AddOffset(ActorMovementsS2CEvt::VT_MOVEMENT, movement);
  }
  explicit ActorMovementsS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActorMovementsS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActorMovementsS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActorMovementsS2CEvt> CreateActorMovementsS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SF::Flat::ActorMovement>>> movement = 0) {
  ActorMovementsS2CEvtBuilder builder_(_fbb);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_movement(movement);
  return builder_.Finish();
}

struct ActorMovementsS2CEvt::Traits {
  using type = ActorMovementsS2CEvt;
  static auto constexpr Create = CreateActorMovementsS2CEvt;
  static constexpr auto name = "ActorMovementsS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ActorMovementsS2CEvt";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "movement"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ActorMovementsS2CEvt> CreateActorMovementsS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    const std::vector<::flatbuffers::Offset<SF::Flat::ActorMovement>> *movement = nullptr) {
  auto movement__ = movement ? _fbb.CreateVector<::flatbuffers::Offset<SF::Flat::ActorMovement>>(*movement) : 0;
  return SF::Flat::PlayInstance::CreateActorMovementsS2CEvt(
      _fbb,
      play_instance_uid,
      movement__);
}

struct PlayerStateChangedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerStateChangedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_STATE = 8,
    VT_MOVE_FRAME = 10,
    VT_POSITION = 12,
    VT_STATE_VALUES = 14
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t state() const {
    return GetField<uint32_t>(VT_STATE, 0);
  }
  uint32_t move_frame() const {
    return GetField<uint32_t>(VT_MOVE_FRAME, 0);
  }
  const SF::Flat::Vector4 *position() const {
    return GetStruct<const SF::Flat::Vector4 *>(VT_POSITION);
  }
  const ::flatbuffers::Vector<uint8_t> *state_values() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_STATE_VALUES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return state();
    else if constexpr (Index == 3) return move_frame();
    else if constexpr (Index == 4) return position();
    else if constexpr (Index == 5) return state_values();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_STATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOVE_FRAME, 4) &&
           VerifyField<SF::Flat::Vector4>(verifier, VT_POSITION, 4) &&
           VerifyOffset(verifier, VT_STATE_VALUES) &&
           verifier.VerifyVector(state_values()) &&
           verifier.EndTable();
  }
};

struct PlayerStateChangedS2CEvtBuilder {
  typedef PlayerStateChangedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(PlayerStateChangedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(PlayerStateChangedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_state(uint32_t state) {
    fbb_.AddElement<uint32_t>(PlayerStateChangedS2CEvt::VT_STATE, state, 0);
  }
  void add_move_frame(uint32_t move_frame) {
    fbb_.AddElement<uint32_t>(PlayerStateChangedS2CEvt::VT_MOVE_FRAME, move_frame, 0);
  }
  void add_position(const SF::Flat::Vector4 *position) {
    fbb_.AddStruct(PlayerStateChangedS2CEvt::VT_POSITION, position);
  }
  void add_state_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> state_values) {
    fbb_.AddOffset(PlayerStateChangedS2CEvt::VT_STATE_VALUES, state_values);
  }
  explicit PlayerStateChangedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerStateChangedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerStateChangedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerStateChangedS2CEvt> CreatePlayerStateChangedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t state = 0,
    uint32_t move_frame = 0,
    const SF::Flat::Vector4 *position = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> state_values = 0) {
  PlayerStateChangedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_state_values(state_values);
  builder_.add_position(position);
  builder_.add_move_frame(move_frame);
  builder_.add_state(state);
  return builder_.Finish();
}

struct PlayerStateChangedS2CEvt::Traits {
  using type = PlayerStateChangedS2CEvt;
  static auto constexpr Create = CreatePlayerStateChangedS2CEvt;
  static constexpr auto name = "PlayerStateChangedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.PlayerStateChangedS2CEvt";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "state",
    "move_frame",
    "position",
    "state_values"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<PlayerStateChangedS2CEvt> CreatePlayerStateChangedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t state = 0,
    uint32_t move_frame = 0,
    const SF::Flat::Vector4 *position = nullptr,
    const std::vector<uint8_t> *state_values = nullptr) {
  auto state_values__ = state_values ? _fbb.CreateVector<uint8_t>(*state_values) : 0;
  return SF::Flat::PlayInstance::CreatePlayerStateChangedS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      state,
      move_frame,
      position,
      state_values__);
}

struct ClientSyncReliableC2SEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientSyncReliableC2SEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_SYNC_DATA = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *sync_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SYNC_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return sync_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_SYNC_DATA) &&
           verifier.VerifyVector(sync_data()) &&
           verifier.EndTable();
  }
};

struct ClientSyncReliableC2SEvtBuilder {
  typedef ClientSyncReliableC2SEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(ClientSyncReliableC2SEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(ClientSyncReliableC2SEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_sync_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sync_data) {
    fbb_.AddOffset(ClientSyncReliableC2SEvt::VT_SYNC_DATA, sync_data);
  }
  explicit ClientSyncReliableC2SEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientSyncReliableC2SEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientSyncReliableC2SEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientSyncReliableC2SEvt> CreateClientSyncReliableC2SEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sync_data = 0) {
  ClientSyncReliableC2SEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_sync_data(sync_data);
  return builder_.Finish();
}

struct ClientSyncReliableC2SEvt::Traits {
  using type = ClientSyncReliableC2SEvt;
  static auto constexpr Create = CreateClientSyncReliableC2SEvt;
  static constexpr auto name = "ClientSyncReliableC2SEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ClientSyncReliableC2SEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "sync_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ClientSyncReliableC2SEvt> CreateClientSyncReliableC2SEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *sync_data = nullptr) {
  auto sync_data__ = sync_data ? _fbb.CreateVector<uint8_t>(*sync_data) : 0;
  return SF::Flat::PlayInstance::CreateClientSyncReliableC2SEvt(
      _fbb,
      play_instance_uid,
      player_id,
      sync_data__);
}

struct ClientSyncC2SEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientSyncC2SEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_SYNC_DATA = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *sync_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SYNC_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return sync_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_SYNC_DATA) &&
           verifier.VerifyVector(sync_data()) &&
           verifier.EndTable();
  }
};

struct ClientSyncC2SEvtBuilder {
  typedef ClientSyncC2SEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(ClientSyncC2SEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(ClientSyncC2SEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_sync_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sync_data) {
    fbb_.AddOffset(ClientSyncC2SEvt::VT_SYNC_DATA, sync_data);
  }
  explicit ClientSyncC2SEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientSyncC2SEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientSyncC2SEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientSyncC2SEvt> CreateClientSyncC2SEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sync_data = 0) {
  ClientSyncC2SEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_sync_data(sync_data);
  return builder_.Finish();
}

struct ClientSyncC2SEvt::Traits {
  using type = ClientSyncC2SEvt;
  static auto constexpr Create = CreateClientSyncC2SEvt;
  static constexpr auto name = "ClientSyncC2SEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ClientSyncC2SEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "sync_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ClientSyncC2SEvt> CreateClientSyncC2SEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *sync_data = nullptr) {
  auto sync_data__ = sync_data ? _fbb.CreateVector<uint8_t>(*sync_data) : 0;
  return SF::Flat::PlayInstance::CreateClientSyncC2SEvt(
      _fbb,
      play_instance_uid,
      player_id,
      sync_data__);
}

struct SetCharacterPublicMessageCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCharacterPublicMessageCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_PUBLIC_MESSAGE = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::String *public_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PUBLIC_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return public_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_PUBLIC_MESSAGE) &&
           verifier.VerifyString(public_message()) &&
           verifier.EndTable();
  }
};

struct SetCharacterPublicMessageCmdBuilder {
  typedef SetCharacterPublicMessageCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(SetCharacterPublicMessageCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(SetCharacterPublicMessageCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_public_message(::flatbuffers::Offset<::flatbuffers::String> public_message) {
    fbb_.AddOffset(SetCharacterPublicMessageCmd::VT_PUBLIC_MESSAGE, public_message);
  }
  explicit SetCharacterPublicMessageCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCharacterPublicMessageCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCharacterPublicMessageCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCharacterPublicMessageCmd> CreateSetCharacterPublicMessageCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> public_message = 0) {
  SetCharacterPublicMessageCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_public_message(public_message);
  return builder_.Finish();
}

struct SetCharacterPublicMessageCmd::Traits {
  using type = SetCharacterPublicMessageCmd;
  static auto constexpr Create = CreateSetCharacterPublicMessageCmd;
  static constexpr auto name = "SetCharacterPublicMessageCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.SetCharacterPublicMessageCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "public_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SetCharacterPublicMessageCmd> CreateSetCharacterPublicMessageCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const char *public_message = nullptr) {
  auto public_message__ = public_message ? _fbb.CreateString(public_message) : 0;
  return SF::Flat::PlayInstance::CreateSetCharacterPublicMessageCmd(
      _fbb,
      play_instance_uid,
      player_id,
      public_message__);
}

struct SetCharacterPublicMessageRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCharacterPublicMessageResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct SetCharacterPublicMessageResBuilder {
  typedef SetCharacterPublicMessageRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(SetCharacterPublicMessageRes::VT_RESULT, result, 0);
  }
  explicit SetCharacterPublicMessageResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCharacterPublicMessageRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCharacterPublicMessageRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCharacterPublicMessageRes> CreateSetCharacterPublicMessageRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  SetCharacterPublicMessageResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct SetCharacterPublicMessageRes::Traits {
  using type = SetCharacterPublicMessageRes;
  static auto constexpr Create = CreateSetCharacterPublicMessageRes;
  static constexpr auto name = "SetCharacterPublicMessageRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.SetCharacterPublicMessageRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CharacterPrivateDataChangedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterPrivateDataChangedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_CHARACTER_ID = 8,
    VT_PRIVATE_DATA = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t character_id() const {
    return GetField<uint32_t>(VT_CHARACTER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *private_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PRIVATE_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return character_id();
    else if constexpr (Index == 3) return private_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyOffset(verifier, VT_PRIVATE_DATA) &&
           verifier.VerifyVector(private_data()) &&
           verifier.EndTable();
  }
};

struct CharacterPrivateDataChangedS2CEvtBuilder {
  typedef CharacterPrivateDataChangedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(CharacterPrivateDataChangedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(CharacterPrivateDataChangedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_character_id(uint32_t character_id) {
    fbb_.AddElement<uint32_t>(CharacterPrivateDataChangedS2CEvt::VT_CHARACTER_ID, character_id, 0);
  }
  void add_private_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> private_data) {
    fbb_.AddOffset(CharacterPrivateDataChangedS2CEvt::VT_PRIVATE_DATA, private_data);
  }
  explicit CharacterPrivateDataChangedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterPrivateDataChangedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterPrivateDataChangedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterPrivateDataChangedS2CEvt> CreateCharacterPrivateDataChangedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t character_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> private_data = 0) {
  CharacterPrivateDataChangedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_private_data(private_data);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct CharacterPrivateDataChangedS2CEvt::Traits {
  using type = CharacterPrivateDataChangedS2CEvt;
  static auto constexpr Create = CreateCharacterPrivateDataChangedS2CEvt;
  static constexpr auto name = "CharacterPrivateDataChangedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CharacterPrivateDataChangedS2CEvt";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "character_id",
    "private_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CharacterPrivateDataChangedS2CEvt> CreateCharacterPrivateDataChangedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t character_id = 0,
    const std::vector<uint8_t> *private_data = nullptr) {
  auto private_data__ = private_data ? _fbb.CreateVector<uint8_t>(*private_data) : 0;
  return SF::Flat::PlayInstance::CreateCharacterPrivateDataChangedS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      character_id,
      private_data__);
}

struct CharacterPublicDataChangedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterPublicDataChangedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_PUBLIC_DATA = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *public_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PUBLIC_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return public_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_PUBLIC_DATA) &&
           verifier.VerifyVector(public_data()) &&
           verifier.EndTable();
  }
};

struct CharacterPublicDataChangedS2CEvtBuilder {
  typedef CharacterPublicDataChangedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(CharacterPublicDataChangedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(CharacterPublicDataChangedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_public_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> public_data) {
    fbb_.AddOffset(CharacterPublicDataChangedS2CEvt::VT_PUBLIC_DATA, public_data);
  }
  explicit CharacterPublicDataChangedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterPublicDataChangedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterPublicDataChangedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterPublicDataChangedS2CEvt> CreateCharacterPublicDataChangedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> public_data = 0) {
  CharacterPublicDataChangedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_public_data(public_data);
  return builder_.Finish();
}

struct CharacterPublicDataChangedS2CEvt::Traits {
  using type = CharacterPublicDataChangedS2CEvt;
  static auto constexpr Create = CreateCharacterPublicDataChangedS2CEvt;
  static constexpr auto name = "CharacterPublicDataChangedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CharacterPublicDataChangedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "public_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CharacterPublicDataChangedS2CEvt> CreateCharacterPublicDataChangedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *public_data = nullptr) {
  auto public_data__ = public_data ? _fbb.CreateVector<uint8_t>(*public_data) : 0;
  return SF::Flat::PlayInstance::CreateCharacterPublicDataChangedS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      public_data__);
}

struct RequestWhiteboardSharingCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestWhiteboardSharingCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_TARGET_PLAYER_ID = 8,
    VT_WHITEBOARD_INFO = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t target_player_id() const {
    return GetField<uint64_t>(VT_TARGET_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *whiteboard_info() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WHITEBOARD_INFO);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return target_player_id();
    else if constexpr (Index == 3) return whiteboard_info();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_TARGET_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_WHITEBOARD_INFO) &&
           verifier.VerifyVector(whiteboard_info()) &&
           verifier.EndTable();
  }
};

struct RequestWhiteboardSharingCmdBuilder {
  typedef RequestWhiteboardSharingCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(RequestWhiteboardSharingCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(RequestWhiteboardSharingCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_target_player_id(uint64_t target_player_id) {
    fbb_.AddElement<uint64_t>(RequestWhiteboardSharingCmd::VT_TARGET_PLAYER_ID, target_player_id, 0);
  }
  void add_whiteboard_info(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> whiteboard_info) {
    fbb_.AddOffset(RequestWhiteboardSharingCmd::VT_WHITEBOARD_INFO, whiteboard_info);
  }
  explicit RequestWhiteboardSharingCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestWhiteboardSharingCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestWhiteboardSharingCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestWhiteboardSharingCmd> CreateRequestWhiteboardSharingCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t target_player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> whiteboard_info = 0) {
  RequestWhiteboardSharingCmdBuilder builder_(_fbb);
  builder_.add_target_player_id(target_player_id);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_whiteboard_info(whiteboard_info);
  return builder_.Finish();
}

struct RequestWhiteboardSharingCmd::Traits {
  using type = RequestWhiteboardSharingCmd;
  static auto constexpr Create = CreateRequestWhiteboardSharingCmd;
  static constexpr auto name = "RequestWhiteboardSharingCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.RequestWhiteboardSharingCmd";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "target_player_id",
    "whiteboard_info"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RequestWhiteboardSharingCmd> CreateRequestWhiteboardSharingCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t target_player_id = 0,
    const std::vector<uint8_t> *whiteboard_info = nullptr) {
  auto whiteboard_info__ = whiteboard_info ? _fbb.CreateVector<uint8_t>(*whiteboard_info) : 0;
  return SF::Flat::PlayInstance::CreateRequestWhiteboardSharingCmd(
      _fbb,
      play_instance_uid,
      player_id,
      target_player_id,
      whiteboard_info__);
}

struct RequestWhiteboardSharingRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestWhiteboardSharingResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct RequestWhiteboardSharingResBuilder {
  typedef RequestWhiteboardSharingRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RequestWhiteboardSharingRes::VT_RESULT, result, 0);
  }
  explicit RequestWhiteboardSharingResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestWhiteboardSharingRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestWhiteboardSharingRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestWhiteboardSharingRes> CreateRequestWhiteboardSharingRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  RequestWhiteboardSharingResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RequestWhiteboardSharingRes::Traits {
  using type = RequestWhiteboardSharingRes;
  static auto constexpr Create = CreateRequestWhiteboardSharingRes;
  static constexpr auto name = "RequestWhiteboardSharingRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.RequestWhiteboardSharingRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AcceptWhiteboardSharingCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AcceptWhiteboardSharingCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_REQUESTED_PLAYER_ID = 8,
    VT_ANSWER = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t requested_player_id() const {
    return GetField<uint64_t>(VT_REQUESTED_PLAYER_ID, 0);
  }
  uint8_t answer() const {
    return GetField<uint8_t>(VT_ANSWER, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return requested_player_id();
    else if constexpr (Index == 3) return answer();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTED_PLAYER_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_ANSWER, 1) &&
           verifier.EndTable();
  }
};

struct AcceptWhiteboardSharingCmdBuilder {
  typedef AcceptWhiteboardSharingCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(AcceptWhiteboardSharingCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(AcceptWhiteboardSharingCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_requested_player_id(uint64_t requested_player_id) {
    fbb_.AddElement<uint64_t>(AcceptWhiteboardSharingCmd::VT_REQUESTED_PLAYER_ID, requested_player_id, 0);
  }
  void add_answer(uint8_t answer) {
    fbb_.AddElement<uint8_t>(AcceptWhiteboardSharingCmd::VT_ANSWER, answer, 0);
  }
  explicit AcceptWhiteboardSharingCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AcceptWhiteboardSharingCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AcceptWhiteboardSharingCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AcceptWhiteboardSharingCmd> CreateAcceptWhiteboardSharingCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t requested_player_id = 0,
    uint8_t answer = 0) {
  AcceptWhiteboardSharingCmdBuilder builder_(_fbb);
  builder_.add_requested_player_id(requested_player_id);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_answer(answer);
  return builder_.Finish();
}

struct AcceptWhiteboardSharingCmd::Traits {
  using type = AcceptWhiteboardSharingCmd;
  static auto constexpr Create = CreateAcceptWhiteboardSharingCmd;
  static constexpr auto name = "AcceptWhiteboardSharingCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.AcceptWhiteboardSharingCmd";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "requested_player_id",
    "answer"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AcceptWhiteboardSharingRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AcceptWhiteboardSharingResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct AcceptWhiteboardSharingResBuilder {
  typedef AcceptWhiteboardSharingRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(AcceptWhiteboardSharingRes::VT_RESULT, result, 0);
  }
  explicit AcceptWhiteboardSharingResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AcceptWhiteboardSharingRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AcceptWhiteboardSharingRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AcceptWhiteboardSharingRes> CreateAcceptWhiteboardSharingRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  AcceptWhiteboardSharingResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct AcceptWhiteboardSharingRes::Traits {
  using type = AcceptWhiteboardSharingRes;
  static auto constexpr Create = CreateAcceptWhiteboardSharingRes;
  static constexpr auto name = "AcceptWhiteboardSharingRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.AcceptWhiteboardSharingRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CloseWhiteboardSharingCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseWhiteboardSharingCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct CloseWhiteboardSharingCmdBuilder {
  typedef CloseWhiteboardSharingCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(CloseWhiteboardSharingCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(CloseWhiteboardSharingCmd::VT_PLAYER_ID, player_id, 0);
  }
  explicit CloseWhiteboardSharingCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseWhiteboardSharingCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseWhiteboardSharingCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseWhiteboardSharingCmd> CreateCloseWhiteboardSharingCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0) {
  CloseWhiteboardSharingCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  return builder_.Finish();
}

struct CloseWhiteboardSharingCmd::Traits {
  using type = CloseWhiteboardSharingCmd;
  static auto constexpr Create = CreateCloseWhiteboardSharingCmd;
  static constexpr auto name = "CloseWhiteboardSharingCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CloseWhiteboardSharingCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CloseWhiteboardSharingRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseWhiteboardSharingResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct CloseWhiteboardSharingResBuilder {
  typedef CloseWhiteboardSharingRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CloseWhiteboardSharingRes::VT_RESULT, result, 0);
  }
  explicit CloseWhiteboardSharingResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseWhiteboardSharingRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseWhiteboardSharingRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseWhiteboardSharingRes> CreateCloseWhiteboardSharingRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  CloseWhiteboardSharingResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CloseWhiteboardSharingRes::Traits {
  using type = CloseWhiteboardSharingRes;
  static auto constexpr Create = CreateCloseWhiteboardSharingRes;
  static constexpr auto name = "CloseWhiteboardSharingRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CloseWhiteboardSharingRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct AddWhiteboardSharingLogEntryCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddWhiteboardSharingLogEntryCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_LOG_ENTRY = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *log_entry() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_LOG_ENTRY);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return log_entry();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_LOG_ENTRY) &&
           verifier.VerifyVector(log_entry()) &&
           verifier.EndTable();
  }
};

struct AddWhiteboardSharingLogEntryCmdBuilder {
  typedef AddWhiteboardSharingLogEntryCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(AddWhiteboardSharingLogEntryCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(AddWhiteboardSharingLogEntryCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_log_entry(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry) {
    fbb_.AddOffset(AddWhiteboardSharingLogEntryCmd::VT_LOG_ENTRY, log_entry);
  }
  explicit AddWhiteboardSharingLogEntryCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddWhiteboardSharingLogEntryCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddWhiteboardSharingLogEntryCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddWhiteboardSharingLogEntryCmd> CreateAddWhiteboardSharingLogEntryCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry = 0) {
  AddWhiteboardSharingLogEntryCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_log_entry(log_entry);
  return builder_.Finish();
}

struct AddWhiteboardSharingLogEntryCmd::Traits {
  using type = AddWhiteboardSharingLogEntryCmd;
  static auto constexpr Create = CreateAddWhiteboardSharingLogEntryCmd;
  static constexpr auto name = "AddWhiteboardSharingLogEntryCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.AddWhiteboardSharingLogEntryCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "log_entry"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<AddWhiteboardSharingLogEntryCmd> CreateAddWhiteboardSharingLogEntryCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *log_entry = nullptr) {
  auto log_entry__ = log_entry ? _fbb.CreateVector<uint8_t>(*log_entry) : 0;
  return SF::Flat::PlayInstance::CreateAddWhiteboardSharingLogEntryCmd(
      _fbb,
      play_instance_uid,
      player_id,
      log_entry__);
}

struct AddWhiteboardSharingLogEntryRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddWhiteboardSharingLogEntryResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_LOG_ENTRY_ID = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint32_t log_entry_id() const {
    return GetField<uint32_t>(VT_LOG_ENTRY_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return log_entry_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint32_t>(verifier, VT_LOG_ENTRY_ID, 4) &&
           verifier.EndTable();
  }
};

struct AddWhiteboardSharingLogEntryResBuilder {
  typedef AddWhiteboardSharingLogEntryRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(AddWhiteboardSharingLogEntryRes::VT_RESULT, result, 0);
  }
  void add_log_entry_id(uint32_t log_entry_id) {
    fbb_.AddElement<uint32_t>(AddWhiteboardSharingLogEntryRes::VT_LOG_ENTRY_ID, log_entry_id, 0);
  }
  explicit AddWhiteboardSharingLogEntryResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddWhiteboardSharingLogEntryRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddWhiteboardSharingLogEntryRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddWhiteboardSharingLogEntryRes> CreateAddWhiteboardSharingLogEntryRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint32_t log_entry_id = 0) {
  AddWhiteboardSharingLogEntryResBuilder builder_(_fbb);
  builder_.add_log_entry_id(log_entry_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct AddWhiteboardSharingLogEntryRes::Traits {
  using type = AddWhiteboardSharingLogEntryRes;
  static auto constexpr Create = CreateAddWhiteboardSharingLogEntryRes;
  static constexpr auto name = "AddWhiteboardSharingLogEntryRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.AddWhiteboardSharingLogEntryRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "log_entry_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct UpdateWhiteboardSharingLogEntryCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateWhiteboardSharingLogEntryCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_LOG_ENTRY = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *log_entry() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_LOG_ENTRY);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return log_entry();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_LOG_ENTRY) &&
           verifier.VerifyVector(log_entry()) &&
           verifier.EndTable();
  }
};

struct UpdateWhiteboardSharingLogEntryCmdBuilder {
  typedef UpdateWhiteboardSharingLogEntryCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(UpdateWhiteboardSharingLogEntryCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(UpdateWhiteboardSharingLogEntryCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_log_entry(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry) {
    fbb_.AddOffset(UpdateWhiteboardSharingLogEntryCmd::VT_LOG_ENTRY, log_entry);
  }
  explicit UpdateWhiteboardSharingLogEntryCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryCmd> CreateUpdateWhiteboardSharingLogEntryCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry = 0) {
  UpdateWhiteboardSharingLogEntryCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_log_entry(log_entry);
  return builder_.Finish();
}

struct UpdateWhiteboardSharingLogEntryCmd::Traits {
  using type = UpdateWhiteboardSharingLogEntryCmd;
  static auto constexpr Create = CreateUpdateWhiteboardSharingLogEntryCmd;
  static constexpr auto name = "UpdateWhiteboardSharingLogEntryCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.UpdateWhiteboardSharingLogEntryCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "log_entry"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryCmd> CreateUpdateWhiteboardSharingLogEntryCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *log_entry = nullptr) {
  auto log_entry__ = log_entry ? _fbb.CreateVector<uint8_t>(*log_entry) : 0;
  return SF::Flat::PlayInstance::CreateUpdateWhiteboardSharingLogEntryCmd(
      _fbb,
      play_instance_uid,
      player_id,
      log_entry__);
}

struct UpdateWhiteboardSharingLogEntryRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateWhiteboardSharingLogEntryResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct UpdateWhiteboardSharingLogEntryResBuilder {
  typedef UpdateWhiteboardSharingLogEntryRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(UpdateWhiteboardSharingLogEntryRes::VT_RESULT, result, 0);
  }
  explicit UpdateWhiteboardSharingLogEntryResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateWhiteboardSharingLogEntryRes> CreateUpdateWhiteboardSharingLogEntryRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  UpdateWhiteboardSharingLogEntryResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct UpdateWhiteboardSharingLogEntryRes::Traits {
  using type = UpdateWhiteboardSharingLogEntryRes;
  static auto constexpr Create = CreateUpdateWhiteboardSharingLogEntryRes;
  static constexpr auto name = "UpdateWhiteboardSharingLogEntryRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.UpdateWhiteboardSharingLogEntryRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RemoveWhiteboardSharingLogEntryCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveWhiteboardSharingLogEntryCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_LOG_ENTRY_ID = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t log_entry_id() const {
    return GetField<uint32_t>(VT_LOG_ENTRY_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return log_entry_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_LOG_ENTRY_ID, 4) &&
           verifier.EndTable();
  }
};

struct RemoveWhiteboardSharingLogEntryCmdBuilder {
  typedef RemoveWhiteboardSharingLogEntryCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(RemoveWhiteboardSharingLogEntryCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(RemoveWhiteboardSharingLogEntryCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_log_entry_id(uint32_t log_entry_id) {
    fbb_.AddElement<uint32_t>(RemoveWhiteboardSharingLogEntryCmd::VT_LOG_ENTRY_ID, log_entry_id, 0);
  }
  explicit RemoveWhiteboardSharingLogEntryCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveWhiteboardSharingLogEntryCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveWhiteboardSharingLogEntryCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveWhiteboardSharingLogEntryCmd> CreateRemoveWhiteboardSharingLogEntryCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t log_entry_id = 0) {
  RemoveWhiteboardSharingLogEntryCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_log_entry_id(log_entry_id);
  return builder_.Finish();
}

struct RemoveWhiteboardSharingLogEntryCmd::Traits {
  using type = RemoveWhiteboardSharingLogEntryCmd;
  static auto constexpr Create = CreateRemoveWhiteboardSharingLogEntryCmd;
  static constexpr auto name = "RemoveWhiteboardSharingLogEntryCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.RemoveWhiteboardSharingLogEntryCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "log_entry_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct RemoveWhiteboardSharingLogEntryRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveWhiteboardSharingLogEntryResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct RemoveWhiteboardSharingLogEntryResBuilder {
  typedef RemoveWhiteboardSharingLogEntryRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(RemoveWhiteboardSharingLogEntryRes::VT_RESULT, result, 0);
  }
  explicit RemoveWhiteboardSharingLogEntryResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveWhiteboardSharingLogEntryRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveWhiteboardSharingLogEntryRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveWhiteboardSharingLogEntryRes> CreateRemoveWhiteboardSharingLogEntryRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  RemoveWhiteboardSharingLogEntryResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RemoveWhiteboardSharingLogEntryRes::Traits {
  using type = RemoveWhiteboardSharingLogEntryRes;
  static auto constexpr Create = CreateRemoveWhiteboardSharingLogEntryRes;
  static constexpr auto name = "RemoveWhiteboardSharingLogEntryRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.RemoveWhiteboardSharingLogEntryRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct WhiteboardSharingRequestedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingRequestedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_REQUESTED_PLAYER_ID = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t requested_player_id() const {
    return GetField<uint64_t>(VT_REQUESTED_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return requested_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTED_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingRequestedS2CEvtBuilder {
  typedef WhiteboardSharingRequestedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingRequestedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingRequestedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_requested_player_id(uint64_t requested_player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingRequestedS2CEvt::VT_REQUESTED_PLAYER_ID, requested_player_id, 0);
  }
  explicit WhiteboardSharingRequestedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingRequestedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingRequestedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingRequestedS2CEvt> CreateWhiteboardSharingRequestedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t requested_player_id = 0) {
  WhiteboardSharingRequestedS2CEvtBuilder builder_(_fbb);
  builder_.add_requested_player_id(requested_player_id);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  return builder_.Finish();
}

struct WhiteboardSharingRequestedS2CEvt::Traits {
  using type = WhiteboardSharingRequestedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingRequestedS2CEvt;
  static constexpr auto name = "WhiteboardSharingRequestedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingRequestedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "requested_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct WhiteboardSharingRejectedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingRejectedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_REJECTED_PLAYER_ID = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t rejected_player_id() const {
    return GetField<uint64_t>(VT_REJECTED_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return rejected_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_REJECTED_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingRejectedS2CEvtBuilder {
  typedef WhiteboardSharingRejectedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingRejectedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingRejectedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_rejected_player_id(uint64_t rejected_player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingRejectedS2CEvt::VT_REJECTED_PLAYER_ID, rejected_player_id, 0);
  }
  explicit WhiteboardSharingRejectedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingRejectedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingRejectedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingRejectedS2CEvt> CreateWhiteboardSharingRejectedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t rejected_player_id = 0) {
  WhiteboardSharingRejectedS2CEvtBuilder builder_(_fbb);
  builder_.add_rejected_player_id(rejected_player_id);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  return builder_.Finish();
}

struct WhiteboardSharingRejectedS2CEvt::Traits {
  using type = WhiteboardSharingRejectedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingRejectedS2CEvt;
  static constexpr auto name = "WhiteboardSharingRejectedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingRejectedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "rejected_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct WhiteboardSharingStartedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingStartedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_OTHER_PLAYER_ID = 8,
    VT_WHITEBOARD_INFO = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t other_player_id() const {
    return GetField<uint64_t>(VT_OTHER_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *whiteboard_info() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WHITEBOARD_INFO);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return other_player_id();
    else if constexpr (Index == 3) return whiteboard_info();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_OTHER_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_WHITEBOARD_INFO) &&
           verifier.VerifyVector(whiteboard_info()) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingStartedS2CEvtBuilder {
  typedef WhiteboardSharingStartedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingStartedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingStartedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_other_player_id(uint64_t other_player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingStartedS2CEvt::VT_OTHER_PLAYER_ID, other_player_id, 0);
  }
  void add_whiteboard_info(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> whiteboard_info) {
    fbb_.AddOffset(WhiteboardSharingStartedS2CEvt::VT_WHITEBOARD_INFO, whiteboard_info);
  }
  explicit WhiteboardSharingStartedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingStartedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingStartedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingStartedS2CEvt> CreateWhiteboardSharingStartedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t other_player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> whiteboard_info = 0) {
  WhiteboardSharingStartedS2CEvtBuilder builder_(_fbb);
  builder_.add_other_player_id(other_player_id);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_whiteboard_info(whiteboard_info);
  return builder_.Finish();
}

struct WhiteboardSharingStartedS2CEvt::Traits {
  using type = WhiteboardSharingStartedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingStartedS2CEvt;
  static constexpr auto name = "WhiteboardSharingStartedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingStartedS2CEvt";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "other_player_id",
    "whiteboard_info"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<WhiteboardSharingStartedS2CEvt> CreateWhiteboardSharingStartedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t other_player_id = 0,
    const std::vector<uint8_t> *whiteboard_info = nullptr) {
  auto whiteboard_info__ = whiteboard_info ? _fbb.CreateVector<uint8_t>(*whiteboard_info) : 0;
  return SF::Flat::PlayInstance::CreateWhiteboardSharingStartedS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      other_player_id,
      whiteboard_info__);
}

struct WhiteboardSharingHasClosedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingHasClosedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_CLOSED_PLAYER_ID = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint64_t closed_player_id() const {
    return GetField<uint64_t>(VT_CLOSED_PLAYER_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return closed_player_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_CLOSED_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingHasClosedS2CEvtBuilder {
  typedef WhiteboardSharingHasClosedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingHasClosedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingHasClosedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_closed_player_id(uint64_t closed_player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingHasClosedS2CEvt::VT_CLOSED_PLAYER_ID, closed_player_id, 0);
  }
  explicit WhiteboardSharingHasClosedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingHasClosedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingHasClosedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingHasClosedS2CEvt> CreateWhiteboardSharingHasClosedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint64_t closed_player_id = 0) {
  WhiteboardSharingHasClosedS2CEvtBuilder builder_(_fbb);
  builder_.add_closed_player_id(closed_player_id);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  return builder_.Finish();
}

struct WhiteboardSharingHasClosedS2CEvt::Traits {
  using type = WhiteboardSharingHasClosedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingHasClosedS2CEvt;
  static constexpr auto name = "WhiteboardSharingHasClosedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingHasClosedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "closed_player_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct WhiteboardSharingNewLogEntryAddedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingNewLogEntryAddedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_LOG_ENTRY = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *log_entry() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_LOG_ENTRY);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return log_entry();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_LOG_ENTRY) &&
           verifier.VerifyVector(log_entry()) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingNewLogEntryAddedS2CEvtBuilder {
  typedef WhiteboardSharingNewLogEntryAddedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingNewLogEntryAddedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingNewLogEntryAddedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_log_entry(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry) {
    fbb_.AddOffset(WhiteboardSharingNewLogEntryAddedS2CEvt::VT_LOG_ENTRY, log_entry);
  }
  explicit WhiteboardSharingNewLogEntryAddedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingNewLogEntryAddedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingNewLogEntryAddedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingNewLogEntryAddedS2CEvt> CreateWhiteboardSharingNewLogEntryAddedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry = 0) {
  WhiteboardSharingNewLogEntryAddedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_log_entry(log_entry);
  return builder_.Finish();
}

struct WhiteboardSharingNewLogEntryAddedS2CEvt::Traits {
  using type = WhiteboardSharingNewLogEntryAddedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingNewLogEntryAddedS2CEvt;
  static constexpr auto name = "WhiteboardSharingNewLogEntryAddedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingNewLogEntryAddedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "log_entry"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<WhiteboardSharingNewLogEntryAddedS2CEvt> CreateWhiteboardSharingNewLogEntryAddedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *log_entry = nullptr) {
  auto log_entry__ = log_entry ? _fbb.CreateVector<uint8_t>(*log_entry) : 0;
  return SF::Flat::PlayInstance::CreateWhiteboardSharingNewLogEntryAddedS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      log_entry__);
}

struct WhiteboardSharingNewLogEntryRemovedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingNewLogEntryRemovedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_LOG_ENTRY_ID = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t log_entry_id() const {
    return GetField<uint32_t>(VT_LOG_ENTRY_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return log_entry_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_LOG_ENTRY_ID, 4) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingNewLogEntryRemovedS2CEvtBuilder {
  typedef WhiteboardSharingNewLogEntryRemovedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingNewLogEntryRemovedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingNewLogEntryRemovedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_log_entry_id(uint32_t log_entry_id) {
    fbb_.AddElement<uint32_t>(WhiteboardSharingNewLogEntryRemovedS2CEvt::VT_LOG_ENTRY_ID, log_entry_id, 0);
  }
  explicit WhiteboardSharingNewLogEntryRemovedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingNewLogEntryRemovedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingNewLogEntryRemovedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingNewLogEntryRemovedS2CEvt> CreateWhiteboardSharingNewLogEntryRemovedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t log_entry_id = 0) {
  WhiteboardSharingNewLogEntryRemovedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_log_entry_id(log_entry_id);
  return builder_.Finish();
}

struct WhiteboardSharingNewLogEntryRemovedS2CEvt::Traits {
  using type = WhiteboardSharingNewLogEntryRemovedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingNewLogEntryRemovedS2CEvt;
  static constexpr auto name = "WhiteboardSharingNewLogEntryRemovedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingNewLogEntryRemovedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "log_entry_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct WhiteboardSharingNewLogEntryUpdatedS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhiteboardSharingNewLogEntryUpdatedS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_LOG_ENTRY = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *log_entry() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_LOG_ENTRY);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return log_entry();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_LOG_ENTRY) &&
           verifier.VerifyVector(log_entry()) &&
           verifier.EndTable();
  }
};

struct WhiteboardSharingNewLogEntryUpdatedS2CEvtBuilder {
  typedef WhiteboardSharingNewLogEntryUpdatedS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingNewLogEntryUpdatedS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(WhiteboardSharingNewLogEntryUpdatedS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_log_entry(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry) {
    fbb_.AddOffset(WhiteboardSharingNewLogEntryUpdatedS2CEvt::VT_LOG_ENTRY, log_entry);
  }
  explicit WhiteboardSharingNewLogEntryUpdatedS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhiteboardSharingNewLogEntryUpdatedS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhiteboardSharingNewLogEntryUpdatedS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhiteboardSharingNewLogEntryUpdatedS2CEvt> CreateWhiteboardSharingNewLogEntryUpdatedS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> log_entry = 0) {
  WhiteboardSharingNewLogEntryUpdatedS2CEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_log_entry(log_entry);
  return builder_.Finish();
}

struct WhiteboardSharingNewLogEntryUpdatedS2CEvt::Traits {
  using type = WhiteboardSharingNewLogEntryUpdatedS2CEvt;
  static auto constexpr Create = CreateWhiteboardSharingNewLogEntryUpdatedS2CEvt;
  static constexpr auto name = "WhiteboardSharingNewLogEntryUpdatedS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.WhiteboardSharingNewLogEntryUpdatedS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "log_entry"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<WhiteboardSharingNewLogEntryUpdatedS2CEvt> CreateWhiteboardSharingNewLogEntryUpdatedS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *log_entry = nullptr) {
  auto log_entry__ = log_entry ? _fbb.CreateVector<uint8_t>(*log_entry) : 0;
  return SF::Flat::PlayInstance::CreateWhiteboardSharingNewLogEntryUpdatedS2CEvt(
      _fbb,
      play_instance_uid,
      player_id,
      log_entry__);
}

struct OccupyMapObjectCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OccupyMapObjectCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_MAP_OBJECT_ID = 8,
    VT_USAGE_ID = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t map_object_id() const {
    return GetField<uint32_t>(VT_MAP_OBJECT_ID, 0);
  }
  uint32_t usage_id() const {
    return GetField<uint32_t>(VT_USAGE_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return map_object_id();
    else if constexpr (Index == 3) return usage_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAP_OBJECT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_USAGE_ID, 4) &&
           verifier.EndTable();
  }
};

struct OccupyMapObjectCmdBuilder {
  typedef OccupyMapObjectCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(OccupyMapObjectCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(OccupyMapObjectCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_map_object_id(uint32_t map_object_id) {
    fbb_.AddElement<uint32_t>(OccupyMapObjectCmd::VT_MAP_OBJECT_ID, map_object_id, 0);
  }
  void add_usage_id(uint32_t usage_id) {
    fbb_.AddElement<uint32_t>(OccupyMapObjectCmd::VT_USAGE_ID, usage_id, 0);
  }
  explicit OccupyMapObjectCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OccupyMapObjectCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OccupyMapObjectCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OccupyMapObjectCmd> CreateOccupyMapObjectCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0,
    uint32_t usage_id = 0) {
  OccupyMapObjectCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_usage_id(usage_id);
  builder_.add_map_object_id(map_object_id);
  return builder_.Finish();
}

struct OccupyMapObjectCmd::Traits {
  using type = OccupyMapObjectCmd;
  static auto constexpr Create = CreateOccupyMapObjectCmd;
  static constexpr auto name = "OccupyMapObjectCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.OccupyMapObjectCmd";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "map_object_id",
    "usage_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct OccupyMapObjectRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OccupyMapObjectResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAY_INSTANCE_UID = 6,
    VT_PLAYER_ID = 8,
    VT_MAP_OBJECT_ID = 10
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t map_object_id() const {
    return GetField<uint32_t>(VT_MAP_OBJECT_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return play_instance_uid();
    else if constexpr (Index == 2) return player_id();
    else if constexpr (Index == 3) return map_object_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAP_OBJECT_ID, 4) &&
           verifier.EndTable();
  }
};

struct OccupyMapObjectResBuilder {
  typedef OccupyMapObjectRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(OccupyMapObjectRes::VT_RESULT, result, 0);
  }
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(OccupyMapObjectRes::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(OccupyMapObjectRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_map_object_id(uint32_t map_object_id) {
    fbb_.AddElement<uint32_t>(OccupyMapObjectRes::VT_MAP_OBJECT_ID, map_object_id, 0);
  }
  explicit OccupyMapObjectResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OccupyMapObjectRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OccupyMapObjectRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OccupyMapObjectRes> CreateOccupyMapObjectRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0) {
  OccupyMapObjectResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_map_object_id(map_object_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct OccupyMapObjectRes::Traits {
  using type = OccupyMapObjectRes;
  static auto constexpr Create = CreateOccupyMapObjectRes;
  static constexpr auto name = "OccupyMapObjectRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.OccupyMapObjectRes";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "play_instance_uid",
    "player_id",
    "map_object_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct UnoccupyMapObjectCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnoccupyMapObjectCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_MAP_OBJECT_ID = 8
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t map_object_id() const {
    return GetField<uint32_t>(VT_MAP_OBJECT_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return map_object_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAP_OBJECT_ID, 4) &&
           verifier.EndTable();
  }
};

struct UnoccupyMapObjectCmdBuilder {
  typedef UnoccupyMapObjectCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(UnoccupyMapObjectCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(UnoccupyMapObjectCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_map_object_id(uint32_t map_object_id) {
    fbb_.AddElement<uint32_t>(UnoccupyMapObjectCmd::VT_MAP_OBJECT_ID, map_object_id, 0);
  }
  explicit UnoccupyMapObjectCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnoccupyMapObjectCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnoccupyMapObjectCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnoccupyMapObjectCmd> CreateUnoccupyMapObjectCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0) {
  UnoccupyMapObjectCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_map_object_id(map_object_id);
  return builder_.Finish();
}

struct UnoccupyMapObjectCmd::Traits {
  using type = UnoccupyMapObjectCmd;
  static auto constexpr Create = CreateUnoccupyMapObjectCmd;
  static constexpr auto name = "UnoccupyMapObjectCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.UnoccupyMapObjectCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "map_object_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct UnoccupyMapObjectRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnoccupyMapObjectResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAY_INSTANCE_UID = 6,
    VT_PLAYER_ID = 8,
    VT_MAP_OBJECT_ID = 10
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t map_object_id() const {
    return GetField<uint32_t>(VT_MAP_OBJECT_ID, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return play_instance_uid();
    else if constexpr (Index == 2) return player_id();
    else if constexpr (Index == 3) return map_object_id();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAP_OBJECT_ID, 4) &&
           verifier.EndTable();
  }
};

struct UnoccupyMapObjectResBuilder {
  typedef UnoccupyMapObjectRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(UnoccupyMapObjectRes::VT_RESULT, result, 0);
  }
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(UnoccupyMapObjectRes::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(UnoccupyMapObjectRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_map_object_id(uint32_t map_object_id) {
    fbb_.AddElement<uint32_t>(UnoccupyMapObjectRes::VT_MAP_OBJECT_ID, map_object_id, 0);
  }
  explicit UnoccupyMapObjectResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnoccupyMapObjectRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnoccupyMapObjectRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnoccupyMapObjectRes> CreateUnoccupyMapObjectRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0) {
  UnoccupyMapObjectResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_map_object_id(map_object_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct UnoccupyMapObjectRes::Traits {
  using type = UnoccupyMapObjectRes;
  static auto constexpr Create = CreateUnoccupyMapObjectRes;
  static constexpr auto name = "UnoccupyMapObjectRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.UnoccupyMapObjectRes";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "play_instance_uid",
    "player_id",
    "map_object_id"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct UseMapObjectCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UseMapObjectCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_MAP_OBJECT_ID = 8,
    VT_USE_PARAMETERS = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t map_object_id() const {
    return GetField<uint32_t>(VT_MAP_OBJECT_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *use_parameters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_USE_PARAMETERS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return map_object_id();
    else if constexpr (Index == 3) return use_parameters();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAP_OBJECT_ID, 4) &&
           VerifyOffset(verifier, VT_USE_PARAMETERS) &&
           verifier.VerifyVector(use_parameters()) &&
           verifier.EndTable();
  }
};

struct UseMapObjectCmdBuilder {
  typedef UseMapObjectCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(UseMapObjectCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(UseMapObjectCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_map_object_id(uint32_t map_object_id) {
    fbb_.AddElement<uint32_t>(UseMapObjectCmd::VT_MAP_OBJECT_ID, map_object_id, 0);
  }
  void add_use_parameters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> use_parameters) {
    fbb_.AddOffset(UseMapObjectCmd::VT_USE_PARAMETERS, use_parameters);
  }
  explicit UseMapObjectCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UseMapObjectCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UseMapObjectCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UseMapObjectCmd> CreateUseMapObjectCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> use_parameters = 0) {
  UseMapObjectCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_use_parameters(use_parameters);
  builder_.add_map_object_id(map_object_id);
  return builder_.Finish();
}

struct UseMapObjectCmd::Traits {
  using type = UseMapObjectCmd;
  static auto constexpr Create = CreateUseMapObjectCmd;
  static constexpr auto name = "UseMapObjectCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.UseMapObjectCmd";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "map_object_id",
    "use_parameters"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<UseMapObjectCmd> CreateUseMapObjectCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0,
    const std::vector<uint8_t> *use_parameters = nullptr) {
  auto use_parameters__ = use_parameters ? _fbb.CreateVector<uint8_t>(*use_parameters) : 0;
  return SF::Flat::PlayInstance::CreateUseMapObjectCmd(
      _fbb,
      play_instance_uid,
      player_id,
      map_object_id,
      use_parameters__);
}

struct UseMapObjectRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UseMapObjectResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PLAY_INSTANCE_UID = 6,
    VT_PLAYER_ID = 8,
    VT_MAP_OBJECT_ID = 10,
    VT_RESULT_ATTRIBUTES = 12
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint32_t map_object_id() const {
    return GetField<uint32_t>(VT_MAP_OBJECT_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *result_attributes() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESULT_ATTRIBUTES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return play_instance_uid();
    else if constexpr (Index == 2) return player_id();
    else if constexpr (Index == 3) return map_object_id();
    else if constexpr (Index == 4) return result_attributes();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAP_OBJECT_ID, 4) &&
           VerifyOffset(verifier, VT_RESULT_ATTRIBUTES) &&
           verifier.VerifyVector(result_attributes()) &&
           verifier.EndTable();
  }
};

struct UseMapObjectResBuilder {
  typedef UseMapObjectRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(UseMapObjectRes::VT_RESULT, result, 0);
  }
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(UseMapObjectRes::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(UseMapObjectRes::VT_PLAYER_ID, player_id, 0);
  }
  void add_map_object_id(uint32_t map_object_id) {
    fbb_.AddElement<uint32_t>(UseMapObjectRes::VT_MAP_OBJECT_ID, map_object_id, 0);
  }
  void add_result_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> result_attributes) {
    fbb_.AddOffset(UseMapObjectRes::VT_RESULT_ATTRIBUTES, result_attributes);
  }
  explicit UseMapObjectResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UseMapObjectRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UseMapObjectRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UseMapObjectRes> CreateUseMapObjectRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> result_attributes = 0) {
  UseMapObjectResBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_result_attributes(result_attributes);
  builder_.add_map_object_id(map_object_id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct UseMapObjectRes::Traits {
  using type = UseMapObjectRes;
  static auto constexpr Create = CreateUseMapObjectRes;
  static constexpr auto name = "UseMapObjectRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.UseMapObjectRes";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "play_instance_uid",
    "player_id",
    "map_object_id",
    "result_attributes"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<UseMapObjectRes> CreateUseMapObjectResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint32_t map_object_id = 0,
    const std::vector<uint8_t> *result_attributes = nullptr) {
  auto result_attributes__ = result_attributes ? _fbb.CreateVector<uint8_t>(*result_attributes) : 0;
  return SF::Flat::PlayInstance::CreateUseMapObjectRes(
      _fbb,
      result,
      play_instance_uid,
      player_id,
      map_object_id,
      result_attributes__);
}

struct ZoneChatCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZoneChatCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_MESSAGE_TYPE = 8,
    VT_CHAT_META_DATA = 10,
    VT_CHAT_MESSAGE = 12
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  int8_t message_type() const {
    return GetField<int8_t>(VT_MESSAGE_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_meta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_META_DATA);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return message_type();
    else if constexpr (Index == 3) return chat_meta_data();
    else if constexpr (Index == 4) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<int8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CHAT_META_DATA) &&
           verifier.VerifyVector(chat_meta_data()) &&
           VerifyOffset(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct ZoneChatCmdBuilder {
  typedef ZoneChatCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(ZoneChatCmd::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(ZoneChatCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_message_type(int8_t message_type) {
    fbb_.AddElement<int8_t>(ZoneChatCmd::VT_MESSAGE_TYPE, message_type, 0);
  }
  void add_chat_meta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data) {
    fbb_.AddOffset(ZoneChatCmd::VT_CHAT_META_DATA, chat_meta_data);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(ZoneChatCmd::VT_CHAT_MESSAGE, chat_message);
  }
  explicit ZoneChatCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZoneChatCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZoneChatCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZoneChatCmd> CreateZoneChatCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    int8_t message_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  ZoneChatCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_chat_message(chat_message);
  builder_.add_chat_meta_data(chat_meta_data);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct ZoneChatCmd::Traits {
  using type = ZoneChatCmd;
  static auto constexpr Create = CreateZoneChatCmd;
  static constexpr auto name = "ZoneChatCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ZoneChatCmd";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "message_type",
    "chat_meta_data",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ZoneChatCmd> CreateZoneChatCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    int8_t message_type = 0,
    const std::vector<uint8_t> *chat_meta_data = nullptr,
    const char *chat_message = nullptr) {
  auto chat_meta_data__ = chat_meta_data ? _fbb.CreateVector<uint8_t>(*chat_meta_data) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::PlayInstance::CreateZoneChatCmd(
      _fbb,
      play_instance_uid,
      player_id,
      message_type,
      chat_meta_data__,
      chat_message__);
}

struct ZoneChatRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZoneChatResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
};

struct ZoneChatResBuilder {
  typedef ZoneChatRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(ZoneChatRes::VT_RESULT, result, 0);
  }
  explicit ZoneChatResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZoneChatRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZoneChatRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZoneChatRes> CreateZoneChatRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0) {
  ZoneChatResBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct ZoneChatRes::Traits {
  using type = ZoneChatRes;
  static auto constexpr Create = CreateZoneChatRes;
  static constexpr auto name = "ZoneChatRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ZoneChatRes";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct ZoneChatS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZoneChatS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_SENDER_ID = 6,
    VT_MESSAGE_TYPE = 8,
    VT_CHAT_META_DATA = 10,
    VT_CHAT_MESSAGE = 12
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t sender_id() const {
    return GetField<uint64_t>(VT_SENDER_ID, 0);
  }
  int8_t message_type() const {
    return GetField<int8_t>(VT_MESSAGE_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *chat_meta_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHAT_META_DATA);
  }
  const ::flatbuffers::String *chat_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHAT_MESSAGE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return sender_id();
    else if constexpr (Index == 2) return message_type();
    else if constexpr (Index == 3) return chat_meta_data();
    else if constexpr (Index == 4) return chat_message();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_SENDER_ID, 8) &&
           VerifyField<int8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CHAT_META_DATA) &&
           verifier.VerifyVector(chat_meta_data()) &&
           VerifyOffset(verifier, VT_CHAT_MESSAGE) &&
           verifier.VerifyString(chat_message()) &&
           verifier.EndTable();
  }
};

struct ZoneChatS2CEvtBuilder {
  typedef ZoneChatS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(ZoneChatS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_sender_id(uint64_t sender_id) {
    fbb_.AddElement<uint64_t>(ZoneChatS2CEvt::VT_SENDER_ID, sender_id, 0);
  }
  void add_message_type(int8_t message_type) {
    fbb_.AddElement<int8_t>(ZoneChatS2CEvt::VT_MESSAGE_TYPE, message_type, 0);
  }
  void add_chat_meta_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data) {
    fbb_.AddOffset(ZoneChatS2CEvt::VT_CHAT_META_DATA, chat_meta_data);
  }
  void add_chat_message(::flatbuffers::Offset<::flatbuffers::String> chat_message) {
    fbb_.AddOffset(ZoneChatS2CEvt::VT_CHAT_MESSAGE, chat_message);
  }
  explicit ZoneChatS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZoneChatS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZoneChatS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZoneChatS2CEvt> CreateZoneChatS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t sender_id = 0,
    int8_t message_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> chat_meta_data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chat_message = 0) {
  ZoneChatS2CEvtBuilder builder_(_fbb);
  builder_.add_sender_id(sender_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_chat_message(chat_message);
  builder_.add_chat_meta_data(chat_meta_data);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct ZoneChatS2CEvt::Traits {
  using type = ZoneChatS2CEvt;
  static auto constexpr Create = CreateZoneChatS2CEvt;
  static constexpr auto name = "ZoneChatS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.ZoneChatS2CEvt";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "sender_id",
    "message_type",
    "chat_meta_data",
    "chat_message"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ZoneChatS2CEvt> CreateZoneChatS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t sender_id = 0,
    int8_t message_type = 0,
    const std::vector<uint8_t> *chat_meta_data = nullptr,
    const char *chat_message = nullptr) {
  auto chat_meta_data__ = chat_meta_data ? _fbb.CreateVector<uint8_t>(*chat_meta_data) : 0;
  auto chat_message__ = chat_message ? _fbb.CreateString(chat_message) : 0;
  return SF::Flat::PlayInstance::CreateZoneChatS2CEvt(
      _fbb,
      play_instance_uid,
      sender_id,
      message_type,
      chat_meta_data__,
      chat_message__);
}

struct LevelUpS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LevelUpS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_CURRENT_EXP = 8,
    VT_CURRENT_LEVEL = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  int64_t current_exp() const {
    return GetField<int64_t>(VT_CURRENT_EXP, 0);
  }
  int32_t current_level() const {
    return GetField<int32_t>(VT_CURRENT_LEVEL, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return current_exp();
    else if constexpr (Index == 3) return current_level();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_CURRENT_EXP, 8) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_LEVEL, 4) &&
           verifier.EndTable();
  }
};

struct LevelUpS2CEvtBuilder {
  typedef LevelUpS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(LevelUpS2CEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(LevelUpS2CEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_current_exp(int64_t current_exp) {
    fbb_.AddElement<int64_t>(LevelUpS2CEvt::VT_CURRENT_EXP, current_exp, 0);
  }
  void add_current_level(int32_t current_level) {
    fbb_.AddElement<int32_t>(LevelUpS2CEvt::VT_CURRENT_LEVEL, current_level, 0);
  }
  explicit LevelUpS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LevelUpS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LevelUpS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LevelUpS2CEvt> CreateLevelUpS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    int64_t current_exp = 0,
    int32_t current_level = 0) {
  LevelUpS2CEvtBuilder builder_(_fbb);
  builder_.add_current_exp(current_exp);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_current_level(current_level);
  return builder_.Finish();
}

struct LevelUpS2CEvt::Traits {
  using type = LevelUpS2CEvt;
  static auto constexpr Create = CreateLevelUpS2CEvt;
  static constexpr auto name = "LevelUpS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.LevelUpS2CEvt";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "current_exp",
    "current_level"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CallFunctionCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallFunctionCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION_NAME = 4,
    VT_PLAYER_ID = 6,
    VT_PARAMETERS = 8
  };
  uint32_t function_name() const {
    return GetField<uint32_t>(VT_FUNCTION_NAME, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return function_name();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return parameters();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FUNCTION_NAME, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.EndTable();
  }
};

struct CallFunctionCmdBuilder {
  typedef CallFunctionCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_function_name(uint32_t function_name) {
    fbb_.AddElement<uint32_t>(CallFunctionCmd::VT_FUNCTION_NAME, function_name, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(CallFunctionCmd::VT_PLAYER_ID, player_id, 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters) {
    fbb_.AddOffset(CallFunctionCmd::VT_PARAMETERS, parameters);
  }
  explicit CallFunctionCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallFunctionCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallFunctionCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallFunctionCmd> CreateCallFunctionCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t function_name = 0,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters = 0) {
  CallFunctionCmdBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_parameters(parameters);
  builder_.add_function_name(function_name);
  return builder_.Finish();
}

struct CallFunctionCmd::Traits {
  using type = CallFunctionCmd;
  static auto constexpr Create = CreateCallFunctionCmd;
  static constexpr auto name = "CallFunctionCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CallFunctionCmd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "function_name",
    "player_id",
    "parameters"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CallFunctionCmd> CreateCallFunctionCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t function_name = 0,
    uint64_t player_id = 0,
    const std::vector<uint8_t> *parameters = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateVector<uint8_t>(*parameters) : 0;
  return SF::Flat::PlayInstance::CreateCallFunctionCmd(
      _fbb,
      function_name,
      player_id,
      parameters__);
}

struct CallFunctionRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallFunctionResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_RESULTS = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *results() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESULTS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return results();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.EndTable();
  }
};

struct CallFunctionResBuilder {
  typedef CallFunctionRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CallFunctionRes::VT_RESULT, result, 0);
  }
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> results) {
    fbb_.AddOffset(CallFunctionRes::VT_RESULTS, results);
  }
  explicit CallFunctionResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallFunctionRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallFunctionRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallFunctionRes> CreateCallFunctionRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> results = 0) {
  CallFunctionResBuilder builder_(_fbb);
  builder_.add_results(results);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CallFunctionRes::Traits {
  using type = CallFunctionRes;
  static auto constexpr Create = CreateCallFunctionRes;
  static constexpr auto name = "CallFunctionRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CallFunctionRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "results"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CallFunctionRes> CreateCallFunctionResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<uint8_t> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<uint8_t>(*results) : 0;
  return SF::Flat::PlayInstance::CreateCallFunctionRes(
      _fbb,
      result,
      results__);
}

struct SendVoiceDataC2SEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendVoiceDataC2SEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAY_INSTANCE_UID = 4,
    VT_PLAYER_ID = 6,
    VT_FRAME_INDEX = 8,
    VT_VOICE_DATA = 10
  };
  uint64_t play_instance_uid() const {
    return GetField<uint64_t>(VT_PLAY_INSTANCE_UID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  uint16_t frame_index() const {
    return GetField<uint16_t>(VT_FRAME_INDEX, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *voice_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VOICE_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return play_instance_uid();
    else if constexpr (Index == 1) return player_id();
    else if constexpr (Index == 2) return frame_index();
    else if constexpr (Index == 3) return voice_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAY_INSTANCE_UID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<uint16_t>(verifier, VT_FRAME_INDEX, 2) &&
           VerifyOffset(verifier, VT_VOICE_DATA) &&
           verifier.VerifyVector(voice_data()) &&
           verifier.EndTable();
  }
};

struct SendVoiceDataC2SEvtBuilder {
  typedef SendVoiceDataC2SEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_play_instance_uid(uint64_t play_instance_uid) {
    fbb_.AddElement<uint64_t>(SendVoiceDataC2SEvt::VT_PLAY_INSTANCE_UID, play_instance_uid, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(SendVoiceDataC2SEvt::VT_PLAYER_ID, player_id, 0);
  }
  void add_frame_index(uint16_t frame_index) {
    fbb_.AddElement<uint16_t>(SendVoiceDataC2SEvt::VT_FRAME_INDEX, frame_index, 0);
  }
  void add_voice_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> voice_data) {
    fbb_.AddOffset(SendVoiceDataC2SEvt::VT_VOICE_DATA, voice_data);
  }
  explicit SendVoiceDataC2SEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendVoiceDataC2SEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendVoiceDataC2SEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SendVoiceDataC2SEvt> CreateSendVoiceDataC2SEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint16_t frame_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> voice_data = 0) {
  SendVoiceDataC2SEvtBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_play_instance_uid(play_instance_uid);
  builder_.add_voice_data(voice_data);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

struct SendVoiceDataC2SEvt::Traits {
  using type = SendVoiceDataC2SEvt;
  static auto constexpr Create = CreateSendVoiceDataC2SEvt;
  static constexpr auto name = "SendVoiceDataC2SEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.SendVoiceDataC2SEvt";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "play_instance_uid",
    "player_id",
    "frame_index",
    "voice_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SendVoiceDataC2SEvt> CreateSendVoiceDataC2SEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t play_instance_uid = 0,
    uint64_t player_id = 0,
    uint16_t frame_index = 0,
    const std::vector<uint8_t> *voice_data = nullptr) {
  auto voice_data__ = voice_data ? _fbb.CreateVector<uint8_t>(*voice_data) : 0;
  return SF::Flat::PlayInstance::CreateSendVoiceDataC2SEvt(
      _fbb,
      play_instance_uid,
      player_id,
      frame_index,
      voice_data__);
}

struct VoiceDataS2CEvt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VoiceDataS2CEvtBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTOR_ID = 4,
    VT_FRAME_INDEX = 6,
    VT_VOICE_DATA = 8
  };
  uint32_t actor_id() const {
    return GetField<uint32_t>(VT_ACTOR_ID, 0);
  }
  uint16_t frame_index() const {
    return GetField<uint16_t>(VT_FRAME_INDEX, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *voice_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VOICE_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return actor_id();
    else if constexpr (Index == 1) return frame_index();
    else if constexpr (Index == 2) return voice_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACTOR_ID, 4) &&
           VerifyField<uint16_t>(verifier, VT_FRAME_INDEX, 2) &&
           VerifyOffset(verifier, VT_VOICE_DATA) &&
           verifier.VerifyVector(voice_data()) &&
           verifier.EndTable();
  }
};

struct VoiceDataS2CEvtBuilder {
  typedef VoiceDataS2CEvt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actor_id(uint32_t actor_id) {
    fbb_.AddElement<uint32_t>(VoiceDataS2CEvt::VT_ACTOR_ID, actor_id, 0);
  }
  void add_frame_index(uint16_t frame_index) {
    fbb_.AddElement<uint16_t>(VoiceDataS2CEvt::VT_FRAME_INDEX, frame_index, 0);
  }
  void add_voice_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> voice_data) {
    fbb_.AddOffset(VoiceDataS2CEvt::VT_VOICE_DATA, voice_data);
  }
  explicit VoiceDataS2CEvtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VoiceDataS2CEvt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VoiceDataS2CEvt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VoiceDataS2CEvt> CreateVoiceDataS2CEvt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t actor_id = 0,
    uint16_t frame_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> voice_data = 0) {
  VoiceDataS2CEvtBuilder builder_(_fbb);
  builder_.add_voice_data(voice_data);
  builder_.add_actor_id(actor_id);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

struct VoiceDataS2CEvt::Traits {
  using type = VoiceDataS2CEvt;
  static auto constexpr Create = CreateVoiceDataS2CEvt;
  static constexpr auto name = "VoiceDataS2CEvt";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.VoiceDataS2CEvt";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "actor_id",
    "frame_index",
    "voice_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<VoiceDataS2CEvt> CreateVoiceDataS2CEvtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t actor_id = 0,
    uint16_t frame_index = 0,
    const std::vector<uint8_t> *voice_data = nullptr) {
  auto voice_data__ = voice_data ? _fbb.CreateVector<uint8_t>(*voice_data) : 0;
  return SF::Flat::PlayInstance::CreateVoiceDataS2CEvt(
      _fbb,
      actor_id,
      frame_index,
      voice_data__);
}

struct CreateStreamCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateStreamCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_STREAM_NAME = 6
  };
  uint64_t ticket() const {
    return GetField<uint64_t>(VT_TICKET, 0);
  }
  const ::flatbuffers::String *stream_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ticket();
    else if constexpr (Index == 1) return stream_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TICKET, 8) &&
           VerifyOffset(verifier, VT_STREAM_NAME) &&
           verifier.VerifyString(stream_name()) &&
           verifier.EndTable();
  }
};

struct CreateStreamCmdBuilder {
  typedef CreateStreamCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ticket(uint64_t ticket) {
    fbb_.AddElement<uint64_t>(CreateStreamCmd::VT_TICKET, ticket, 0);
  }
  void add_stream_name(::flatbuffers::Offset<::flatbuffers::String> stream_name) {
    fbb_.AddOffset(CreateStreamCmd::VT_STREAM_NAME, stream_name);
  }
  explicit CreateStreamCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateStreamCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateStreamCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateStreamCmd> CreateCreateStreamCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stream_name = 0) {
  CreateStreamCmdBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_stream_name(stream_name);
  return builder_.Finish();
}

struct CreateStreamCmd::Traits {
  using type = CreateStreamCmd;
  static auto constexpr Create = CreateCreateStreamCmd;
  static constexpr auto name = "CreateStreamCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CreateStreamCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ticket",
    "stream_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CreateStreamCmd> CreateCreateStreamCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0,
    const char *stream_name = nullptr) {
  auto stream_name__ = stream_name ? _fbb.CreateString(stream_name) : 0;
  return SF::Flat::PlayInstance::CreateCreateStreamCmd(
      _fbb,
      ticket,
      stream_name__);
}

struct CreateStreamRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateStreamResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_STREAM_NAME = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::String *stream_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return stream_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_STREAM_NAME) &&
           verifier.VerifyString(stream_name()) &&
           verifier.EndTable();
  }
};

struct CreateStreamResBuilder {
  typedef CreateStreamRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(CreateStreamRes::VT_RESULT, result, 0);
  }
  void add_stream_name(::flatbuffers::Offset<::flatbuffers::String> stream_name) {
    fbb_.AddOffset(CreateStreamRes::VT_STREAM_NAME, stream_name);
  }
  explicit CreateStreamResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateStreamRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateStreamRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateStreamRes> CreateCreateStreamRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stream_name = 0) {
  CreateStreamResBuilder builder_(_fbb);
  builder_.add_stream_name(stream_name);
  builder_.add_result(result);
  return builder_.Finish();
}

struct CreateStreamRes::Traits {
  using type = CreateStreamRes;
  static auto constexpr Create = CreateCreateStreamRes;
  static constexpr auto name = "CreateStreamRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.CreateStreamRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "stream_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<CreateStreamRes> CreateCreateStreamResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const char *stream_name = nullptr) {
  auto stream_name__ = stream_name ? _fbb.CreateString(stream_name) : 0;
  return SF::Flat::PlayInstance::CreateCreateStreamRes(
      _fbb,
      result,
      stream_name__);
}

struct FindStreamCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindStreamCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_STREAM_NAME = 6
  };
  uint64_t ticket() const {
    return GetField<uint64_t>(VT_TICKET, 0);
  }
  const ::flatbuffers::String *stream_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ticket();
    else if constexpr (Index == 1) return stream_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TICKET, 8) &&
           VerifyOffset(verifier, VT_STREAM_NAME) &&
           verifier.VerifyString(stream_name()) &&
           verifier.EndTable();
  }
};

struct FindStreamCmdBuilder {
  typedef FindStreamCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ticket(uint64_t ticket) {
    fbb_.AddElement<uint64_t>(FindStreamCmd::VT_TICKET, ticket, 0);
  }
  void add_stream_name(::flatbuffers::Offset<::flatbuffers::String> stream_name) {
    fbb_.AddOffset(FindStreamCmd::VT_STREAM_NAME, stream_name);
  }
  explicit FindStreamCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindStreamCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindStreamCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FindStreamCmd> CreateFindStreamCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stream_name = 0) {
  FindStreamCmdBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_stream_name(stream_name);
  return builder_.Finish();
}

struct FindStreamCmd::Traits {
  using type = FindStreamCmd;
  static auto constexpr Create = CreateFindStreamCmd;
  static constexpr auto name = "FindStreamCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.FindStreamCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ticket",
    "stream_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<FindStreamCmd> CreateFindStreamCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0,
    const char *stream_name = nullptr) {
  auto stream_name__ = stream_name ? _fbb.CreateString(stream_name) : 0;
  return SF::Flat::PlayInstance::CreateFindStreamCmd(
      _fbb,
      ticket,
      stream_name__);
}

struct FindStreamRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FindStreamResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_STREAM_NAME = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::String *stream_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return stream_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_STREAM_NAME) &&
           verifier.VerifyString(stream_name()) &&
           verifier.EndTable();
  }
};

struct FindStreamResBuilder {
  typedef FindStreamRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(FindStreamRes::VT_RESULT, result, 0);
  }
  void add_stream_name(::flatbuffers::Offset<::flatbuffers::String> stream_name) {
    fbb_.AddOffset(FindStreamRes::VT_STREAM_NAME, stream_name);
  }
  explicit FindStreamResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FindStreamRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FindStreamRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FindStreamRes> CreateFindStreamRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stream_name = 0) {
  FindStreamResBuilder builder_(_fbb);
  builder_.add_stream_name(stream_name);
  builder_.add_result(result);
  return builder_.Finish();
}

struct FindStreamRes::Traits {
  using type = FindStreamRes;
  static auto constexpr Create = CreateFindStreamRes;
  static constexpr auto name = "FindStreamRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.FindStreamRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "stream_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<FindStreamRes> CreateFindStreamResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const char *stream_name = nullptr) {
  auto stream_name__ = stream_name ? _fbb.CreateString(stream_name) : 0;
  return SF::Flat::PlayInstance::CreateFindStreamRes(
      _fbb,
      result,
      stream_name__);
}

struct DeleteStreamCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteStreamCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_STREAM_NAME = 6
  };
  uint64_t ticket() const {
    return GetField<uint64_t>(VT_TICKET, 0);
  }
  const ::flatbuffers::String *stream_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ticket();
    else if constexpr (Index == 1) return stream_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TICKET, 8) &&
           VerifyOffset(verifier, VT_STREAM_NAME) &&
           verifier.VerifyString(stream_name()) &&
           verifier.EndTable();
  }
};

struct DeleteStreamCmdBuilder {
  typedef DeleteStreamCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ticket(uint64_t ticket) {
    fbb_.AddElement<uint64_t>(DeleteStreamCmd::VT_TICKET, ticket, 0);
  }
  void add_stream_name(::flatbuffers::Offset<::flatbuffers::String> stream_name) {
    fbb_.AddOffset(DeleteStreamCmd::VT_STREAM_NAME, stream_name);
  }
  explicit DeleteStreamCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteStreamCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteStreamCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteStreamCmd> CreateDeleteStreamCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stream_name = 0) {
  DeleteStreamCmdBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  builder_.add_stream_name(stream_name);
  return builder_.Finish();
}

struct DeleteStreamCmd::Traits {
  using type = DeleteStreamCmd;
  static auto constexpr Create = CreateDeleteStreamCmd;
  static constexpr auto name = "DeleteStreamCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.DeleteStreamCmd";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ticket",
    "stream_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DeleteStreamCmd> CreateDeleteStreamCmdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0,
    const char *stream_name = nullptr) {
  auto stream_name__ = stream_name ? _fbb.CreateString(stream_name) : 0;
  return SF::Flat::PlayInstance::CreateDeleteStreamCmd(
      _fbb,
      ticket,
      stream_name__);
}

struct DeleteStreamRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteStreamResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_STREAM_NAME = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::String *stream_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return stream_name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_STREAM_NAME) &&
           verifier.VerifyString(stream_name()) &&
           verifier.EndTable();
  }
};

struct DeleteStreamResBuilder {
  typedef DeleteStreamRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(DeleteStreamRes::VT_RESULT, result, 0);
  }
  void add_stream_name(::flatbuffers::Offset<::flatbuffers::String> stream_name) {
    fbb_.AddOffset(DeleteStreamRes::VT_STREAM_NAME, stream_name);
  }
  explicit DeleteStreamResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteStreamRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteStreamRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteStreamRes> CreateDeleteStreamRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stream_name = 0) {
  DeleteStreamResBuilder builder_(_fbb);
  builder_.add_stream_name(stream_name);
  builder_.add_result(result);
  return builder_.Finish();
}

struct DeleteStreamRes::Traits {
  using type = DeleteStreamRes;
  static auto constexpr Create = CreateDeleteStreamRes;
  static constexpr auto name = "DeleteStreamRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.DeleteStreamRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "stream_name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DeleteStreamRes> CreateDeleteStreamResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const char *stream_name = nullptr) {
  auto stream_name__ = stream_name ? _fbb.CreateString(stream_name) : 0;
  return SF::Flat::PlayInstance::CreateDeleteStreamRes(
      _fbb,
      result,
      stream_name__);
}

struct GetStreamListCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStreamListCmdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4
  };
  uint64_t ticket() const {
    return GetField<uint64_t>(VT_TICKET, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ticket();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TICKET, 8) &&
           verifier.EndTable();
  }
};

struct GetStreamListCmdBuilder {
  typedef GetStreamListCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ticket(uint64_t ticket) {
    fbb_.AddElement<uint64_t>(GetStreamListCmd::VT_TICKET, ticket, 0);
  }
  explicit GetStreamListCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStreamListCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStreamListCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStreamListCmd> CreateGetStreamListCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ticket = 0) {
  GetStreamListCmdBuilder builder_(_fbb);
  builder_.add_ticket(ticket);
  return builder_.Finish();
}

struct GetStreamListCmd::Traits {
  using type = GetStreamListCmd;
  static auto constexpr Create = CreateGetStreamListCmd;
  static constexpr auto name = "GetStreamListCmd";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.GetStreamListCmd";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ticket"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct GetStreamListRes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStreamListResBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_STREAM_NAMES = 6
  };
  uint32_t result() const {
    return GetField<uint32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *stream_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STREAM_NAMES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return result();
    else if constexpr (Index == 1) return stream_names();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_STREAM_NAMES) &&
           verifier.VerifyVector(stream_names()) &&
           verifier.VerifyVectorOfStrings(stream_names()) &&
           verifier.EndTable();
  }
};

struct GetStreamListResBuilder {
  typedef GetStreamListRes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(uint32_t result) {
    fbb_.AddElement<uint32_t>(GetStreamListRes::VT_RESULT, result, 0);
  }
  void add_stream_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> stream_names) {
    fbb_.AddOffset(GetStreamListRes::VT_STREAM_NAMES, stream_names);
  }
  explicit GetStreamListResBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStreamListRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStreamListRes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStreamListRes> CreateGetStreamListRes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> stream_names = 0) {
  GetStreamListResBuilder builder_(_fbb);
  builder_.add_stream_names(stream_names);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GetStreamListRes::Traits {
  using type = GetStreamListRes;
  static auto constexpr Create = CreateGetStreamListRes;
  static constexpr auto name = "GetStreamListRes";
  static constexpr auto fully_qualified_name = "SF.Flat.PlayInstance.GetStreamListRes";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "result",
    "stream_names"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<GetStreamListRes> CreateGetStreamListResDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t result = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *stream_names = nullptr) {
  auto stream_names__ = stream_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*stream_names) : 0;
  return SF::Flat::PlayInstance::CreateGetStreamListRes(
      _fbb,
      result,
      stream_names__);
}

inline const SF::Flat::PlayInstance::GetStreamListRes *GetGetStreamListRes(const void *buf) {
  return ::flatbuffers::GetRoot<SF::Flat::PlayInstance::GetStreamListRes>(buf);
}

inline const SF::Flat::PlayInstance::GetStreamListRes *GetSizePrefixedGetStreamListRes(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SF::Flat::PlayInstance::GetStreamListRes>(buf);
}

inline bool VerifyGetStreamListResBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SF::Flat::PlayInstance::GetStreamListRes>(nullptr);
}

inline bool VerifySizePrefixedGetStreamListResBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SF::Flat::PlayInstance::GetStreamListRes>(nullptr);
}

inline void FinishGetStreamListResBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SF::Flat::PlayInstance::GetStreamListRes> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGetStreamListResBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SF::Flat::PlayInstance::GetStreamListRes> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace PlayInstance
}  // namespace Flat
}  // namespace SF

#endif  // FLATBUFFERS_GENERATED_PLAYINSTANCE_SF_FLAT_PLAYINSTANCE_H_
